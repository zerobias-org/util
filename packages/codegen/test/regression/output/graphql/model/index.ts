/* eslint-disable */
// ===============================================
// This file is autogenerated - Please do not edit
// ===============================================
export * from './ConnectionProfile.js';
import * as stream from 'stream';

import { NumberFormat, DateTime, DateFormat, CoreType, PagedResults, IllegalArgumentError as RealIllegalArgumentError } from '@zerobias-org/types-core-js';

import { ConnectionProfile } from './ConnectionProfile.js';

/* tslint:disable:no-unused-variable */
const primitives = [
                    "string",
                    "boolean",
                    "double",
                    "integer",
                    "long",
                    "float",
                    "number",
                    "any"
                 ];

const trueStrings = [
    'yes',
    'y',
    'true',
    '1'
];

export interface RequestDetailedFile {
    value: string | Buffer | stream.Readable;
    options?: {
        filename?: string;
        contentType?: string;
        attachment?: boolean;
    }
}
export type RequestFile = string | Buffer | stream.Readable | RequestDetailedFile;

let enumsMap: {[index: string]: any} = {
  }

const typeMap: {[index: string]: any} = {
    "ConnectionProfile": ConnectionProfile,
}

const unionMap: {[index: string]: {discriminator: string, mapping: Record<string, string>}} = {
}

const schemaMap: {[index: string]: string} = {
  "ConnectionProfile": 'ewogICJyZXF1aXJlZCIgOiBbICJzZXJ2ZXIiIF0sCiAgInR5cGUiIDogIm9iamVjdCIsCiAgInByb3BlcnRpZXMiIDogewogICAgInNlcnZlciIgOiB7CiAgICAgICJ0eXBlIiA6ICJzdHJpbmciLAogICAgICAiZGVzY3JpcHRpb24iIDogIkdyYXBoUUwgQVBJIHNlcnZlciBVUkwiLAogICAgICAiZm9ybWF0IiA6ICJ1cmkiLAogICAgICAiZXhhbXBsZSIgOiAiaHR0cHM6Ly9hcGkuemVyb2JpYXMuY29tIgogICAgfSwKICAgICJhcGlLZXkiIDogewogICAgICAidHlwZSIgOiAic3RyaW5nIiwKICAgICAgImRlc2NyaXB0aW9uIiA6ICJBUEkga2V5IGZvciBhdXRoZW50aWNhdGlvbiIsCiAgICAgICJmb3JtYXQiIDogInBhc3N3b3JkIgogICAgfSwKICAgICJvcmdJZCIgOiB7CiAgICAgICJ0eXBlIiA6ICJzdHJpbmciLAogICAgICAiZGVzY3JpcHRpb24iIDogIk9yZ2FuaXphdGlvbiBJRCBmb3IgbXVsdGktdGVuYW50IGFjY2VzcyIsCiAgICAgICJmb3JtYXQiIDogInV1aWQiCiAgICB9LAogICAgInRpbWVvdXQiIDogewogICAgICAibWF4aW11bSIgOiAzMDAwMDAsCiAgICAgICJtaW5pbXVtIiA6IDEwMDAsCiAgICAgICJ0eXBlIiA6ICJpbnRlZ2VyIiwKICAgICAgImRlc2NyaXB0aW9uIiA6ICJSZXF1ZXN0IHRpbWVvdXQgaW4gbWlsbGlzZWNvbmRzIiwKICAgICAgImRlZmF1bHQiIDogMzAwMDAKICAgIH0KICB9LAogICJkZXNjcmlwdGlvbiIgOiAiQ29ubmVjdGlvbiBwcm9maWxlIGZvciBHcmFwaFFMIEFQSSBjbGllbnQiCn0=',
};

export class ObjectSerializer {
    public static hasType(type: string): boolean {
        return type === "Date" || enumsMap[type] || typeMap[type] || unionMap[type];
    }

    public static findCorrectType(data: any, expectedType: string) {
        if (data == undefined) {
            return expectedType;
        } else if (primitives.indexOf(expectedType.toLowerCase()) !== -1) {
            return expectedType;
        } else if (expectedType === "Date") {
            return expectedType;
        } else {
            if (enumsMap[expectedType]) {
                return expectedType;
            }

            if (!typeMap[expectedType] && !unionMap[expectedType]) {
                return expectedType; // w/e we don't know the type
            }

            if (unionMap[expectedType]) {
                const discriminator = unionMap[expectedType];
                let discriminatorValue = data[discriminator.discriminator];
                if (discriminatorValue && discriminator.mapping[discriminatorValue]) {
                    // found a subclass
                    return discriminator.mapping[discriminatorValue];
                } else if (discriminatorValue && typeMap[discriminatorValue]) {
                    // legacy fallback behavior
                    return typeMap[discriminatorValue];
                } else {
                    throw new RealIllegalArgumentError(
                      `Bad discriminator ${discriminator} for ${expectedType}`
                    );
                }
            } else {
                // Check the discriminator
                let discriminatorProperty = typeMap[expectedType].discriminator;
                if (discriminatorProperty == null) {
                    return expectedType; // the type does not have a discriminator. use it.
                } else {
                    if (data[discriminatorProperty]) {
                        var discriminatorType = data[discriminatorProperty];
                        if(typeMap[discriminatorType]){
                            return discriminatorType; // use the type given in the discriminator
                        } else {
                            return expectedType; // discriminator did not map to a type
                        }
                    } else {
                        return expectedType; // discriminator was not present (or an empty string)
                    }
                }
            }
        }
    }

    public static serialize(data: any, type: string, format?: string) {
        if (data == undefined) {
            return data;
        } else if (type === "Date") {
            return data.toISOString();
        } else if (format && CoreType.allFormats().includes(format)) {
            // data *should* be an instance of the actual CoreType
            return Object.prototype.hasOwnProperty.call(data, 'toJSON')
                ? data.toJSON()
                : data.toString();
        } else if (primitives.indexOf(type.toLowerCase()) !== -1) {
            return data;
        } else if (type.lastIndexOf("Array<", 0) === 0) { // string.startsWith pre es6
            let subType: string = type.replace("Array<", ""); // Array<Type> => Type>
            subType = subType.substring(0, subType.length - 1); // Type> => Type
            let transformedData: any[] = [];
            for (let index in data) {
                let datum = data[index];
                transformedData.push(ObjectSerializer.serialize(datum, subType, format));
            }
            return transformedData;
        } else {
            if (enumsMap[type]) {
                return data.toString();
            }
            if (!typeMap[type]) { // in case we dont know the type
                return data;
            }

            // Get the actual type of this object
            type = this.findCorrectType(data, type);

            // get the map for the correct type.
            let attributeTypes = typeMap[type].getAttributeTypeMap();
            let instance: {[index: string]: any} = {};
            for (let index in attributeTypes) {
                let attributeType = attributeTypes[index];
                instance[attributeType.baseName] = ObjectSerializer.serialize(data[attributeType.name], attributeType.type, attributeType.format);
            }
            return instance;
        }
    }

    public static deserialize(data: any, type: string, format?: string) {
        // polymorphism may change the actual type.
        type = ObjectSerializer.findCorrectType(data, type);
        if (data == undefined || data === '') {
            return undefined;
        } else if (type.lastIndexOf("Array<", 0) === 0) { // string.startsWith pre es6
            let subType: string = type.replace("Array<", ""); // Array<Type> => Type>
            subType = subType.substring(0, subType.length - 1); // Type> => Type
            let transformedData: any[] = [];
            for (let index in data) {
                let datum = data[index];
                transformedData.push(ObjectSerializer.deserialize(datum, subType, format));
            }
            return transformedData;
        } else if (type.lastIndexOf("PagedResults<", 0) === 0) {
            let subType: string = type.replace("PagedResults<", "");
            subType = subType.substring(0, subType.length - 1);
            return PagedResults.newInstance(data, ((obj: any) => ObjectSerializer.deserialize(obj, subType, format)));
        } else if (type === "Date" && typeof data === 'string') {
            return new Date(data);
        } else if (format && CoreType.allFormats().includes(format)) {
            let sanitizedData = data;
            if (data instanceof Date) {
                sanitizedData = data.toISOString();
            } else if (type === 'number' || type === 'integer') {
                sanitizedData = Number(data.toString());
            } else if (typeof data !== 'string') {
                if (format.toLowerCase() !== 'oid') {
                    return data;
                }
                if (!Array.isArray(data)) {
                    return data;
                }
                sanitizedData = data;
            } else if (format === 'password') {
                return data;
            }
            const ct = CoreType.get(format)
            const ctInstance = ct.newInstance(sanitizedData);
            if (ctInstance instanceof NumberFormat) {
                return ctInstance.toNumber();
            } else if (ctInstance instanceof DateTime || ctInstance instanceof DateFormat) {
                return ctInstance.toDate();
            }
            return ctInstance;
        } else if (primitives.indexOf(type.toLowerCase()) !== -1) {
            switch (type.toLowerCase()) {
                case 'boolean':
                    return trueStrings.includes(data.toString().toLowerCase());
                case 'double':
                case 'integer':
                case 'long':
                case 'float':
                case 'number':
                    return Number(data);
                default: 
                    return data;
            }
        } else if (type.startsWith('{ [key:') && !type.includes(' | ')) {
          // deserialize additionalProperties. The key will be either a string or number, so the native type is fine there
          let transformedData = {};
          let valType = type.substring(type.lastIndexOf(': ') + 2, type.length - 3);
          for (let key in data) {
            transformedData[key] = ObjectSerializer.deserialize(data[key], valType);
          }
          return transformedData;
        } else {
            if (enumsMap[type]) {
              if (typeof enumsMap[type] === 'string') {
                let mod = require(enumsMap[type]);
                type.split('.').forEach((k) => (mod = mod[k]));
                enumsMap[type] = mod;
              }
              // is Enum
              if (`${Number(data)}` === `${data}`) {
                return enumsMap[type].from(Number(data));
              }
              return enumsMap[type].from(`${data}`);
            }

            if (!typeMap[type]) {
              // dont know the type
              return data;
            }
            let instance = new typeMap[type]();
            let attributeTypes = typeMap[type].getAttributeTypeMap();
            for (let index in attributeTypes) {
                let attributeType = attributeTypes[index];
                instance[attributeType.name] = ObjectSerializer.deserialize(data[attributeType.baseName], attributeType.type, attributeType.format);
            }
            return instance;
        }
    }

    public static getSchema(name: string): string | undefined {
      return schemaMap[name];
    }
}
