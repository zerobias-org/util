/* eslint-disable */
// ===============================================
// This file is autogenerated - Please do not edit
// ===============================================
import { AxiosInstance } from 'axios';
import { BoundaryStandardBaselineMetrics, ComplianceFeatureExtended, ControlTreeNode, ElementCrosswalkElement, ElementExtended, ResultsColumnOptionsWrapper, ResultsSearchOptionsWrapper, SearchElementBody, SearchElementComplianceFeatureBody, SearchElementCrosswalkElementBody, SearchStandardBody, SearchStandardByTypeBody, SortObject, StandardExtended, StandardFilterTreeNode, StandardFilters, StandardTypeDef } from '../model/index.js';
import { URL, EnumValue, IllegalArgumentError, PagedResults, Int32, UUID, CoreError, ParameterRequiredError, UnexpectedError, HttpMethod } from '@zerobias-org/types-core-js';
import { RequestFile, ObjectSerializer } from '../model/index.js';

export namespace StandardApi {
}

/**
 * StandardApi - interface
 * @export
 * @interface StandardApi
 */
export interface StandardApi {
  /**
   * Returns standard elements crosswalk graph
   * @summary Returns standard elements crosswalk graph
   * @param {UUID} standardId 
   * @param {UUID} elementId 
   * @param {number} [depth] 
   * @param {*} [options] Override http request option.
   * @throws {@link @zerobias-org/types-core-js#ParameterRequiredError} if any required parameter is not provided
   * @example
   * ```typescript
   * const result = await api.elementCrosswalkGraph('00000000-0000-0000-0000-000000000000', '00000000-0000-0000-0000-000000000000', null);
   * ```
   * @openapi operation=elementCrosswalkGraph path=/standards/{standardId}/elements/{elementId}/crosswalkGraph method=GET
   * @memberof StandardApi
   */
  elementCrosswalkGraph(standardId: UUID, elementId: UUID, depth?: number): Promise<Array<ElementCrosswalkElement>>;

  /**
   * Get boundary standard baseline control tree
   * @summary Get boundary standard baseline control tree
   * @param {UUID} boundaryStandardBaselineId 
   * @param {*} [options] Override http request option.
   * @throws {@link @zerobias-org/types-core-js#ParameterRequiredError} if any required parameter is not provided
   * @example
   * ```typescript
   * const result = await api.getBoundaryStandardBaselineControlTree('00000000-0000-0000-0000-000000000000');
   * ```
   * @openapi operation=getBoundaryStandardBaselineControlTree path=/boundaryStandardBaselines/{boundaryStandardBaselineId}/controlTree method=GET
   * @memberof StandardApi
   */
  getBoundaryStandardBaselineControlTree(boundaryStandardBaselineId: UUID): Promise<{ [key: string]: ControlTreeNode; }>;

  /**
   * Get standard filter tree
   * @summary Get standard filter tree
   * @param {UUID} boundaryStandardBaselineId 
   * @param {*} [options] Override http request option.
   * @throws {@link @zerobias-org/types-core-js#ParameterRequiredError} if any required parameter is not provided
   * @example
   * ```typescript
   * const result = await api.getBoundaryStandardBaselineFilterTree('00000000-0000-0000-0000-000000000000');
   * ```
   * @openapi operation=getBoundaryStandardBaselineFilterTree path=/boundaryStandardBaselines/{boundaryStandardBaselineId}/filterTree method=GET
   * @memberof StandardApi
   */
  getBoundaryStandardBaselineFilterTree(boundaryStandardBaselineId: UUID): Promise<{ [key: string]: StandardFilterTreeNode; }>;

  /**
   * List boundary standard baseline metrics
   * @summary List boundary standard baseline metrics
   * @param {UUID} boundaryStandardBaselineId 
   * @param {*} [options] Override http request option.
   * @throws {@link @zerobias-org/types-core-js#ParameterRequiredError} if any required parameter is not provided
   * @example
   * ```typescript
   * const result = await api.getBoundaryStandardBaselineMetrics('00000000-0000-0000-0000-000000000000');
   * ```
   * @openapi operation=getBoundaryStandardBaselineMetrics path=/boundaryStandardBaselines/{boundaryStandardBaselineId}/metrics method=GET
   * @memberof StandardApi
   */
  getBoundaryStandardBaselineMetrics(boundaryStandardBaselineId: UUID): Promise<BoundaryStandardBaselineMetrics>;

  /**
   * Get element crosswalk chain
   * @summary Get element crosswalk chain
   * @param {UUID} standardId 
   * @param {UUID} elementId 
   * @param {UUID} mappedElementId 
   * @param {number} mappedElementRank 
   * @param {*} [options] Override http request option.
   * @throws {@link @zerobias-org/types-core-js#ParameterRequiredError} if any required parameter is not provided
   * @example
   * ```typescript
   * const result = await api.getElementCrosswalkChain('00000000-0000-0000-0000-000000000000', '00000000-0000-0000-0000-000000000000', '00000000-0000-0000-0000-000000000000', null);
   * ```
   * @openapi operation=getElementCrosswalkChain path=/standards/{standardId}/elements/{elementId}/crosswalkChain method=GET
   * @memberof StandardApi
   */
  getElementCrosswalkChain(standardId: UUID, elementId: UUID, mappedElementId: UUID, mappedElementRank: number): Promise<Array<ElementCrosswalkElement>>;

  /**
   * Get standard by id
   * @summary Get standard by id
   * @param {UUID} standardId 
   * @param {*} [options] Override http request option.
   * @throws {@link @zerobias-org/types-core-js#ParameterRequiredError} if any required parameter is not provided
   * @example
   * ```typescript
   * const result = await api.get('00000000-0000-0000-0000-000000000000');
   * ```
   * @openapi operation=getStandard path=/standards/{standardId} method=GET
   * @memberof StandardApi
   */
  get(standardId: UUID): Promise<StandardExtended>;

  /**
   * Get standard element by id
   * @summary Get standard element by id
   * @param {UUID} standardId 
   * @param {UUID} elementId 
   * @param {*} [options] Override http request option.
   * @throws {@link @zerobias-org/types-core-js#ParameterRequiredError} if any required parameter is not provided
   * @example
   * ```typescript
   * const result = await api.getElement('00000000-0000-0000-0000-000000000000', '00000000-0000-0000-0000-000000000000');
   * ```
   * @openapi operation=getStandardElement path=/standards/{standardId}/elements/{elementId} method=GET
   * @memberof StandardApi
   */
  getElement(standardId: UUID, elementId: UUID): Promise<ElementExtended>;

  /**
   * Get standard filter tree
   * @summary Get standard filter tree
   * @param {UUID} standardId 
   * @param {*} [options] Override http request option.
   * @throws {@link @zerobias-org/types-core-js#ParameterRequiredError} if any required parameter is not provided
   * @example
   * ```typescript
   * const result = await api.getFilterTree('00000000-0000-0000-0000-000000000000');
   * ```
   * @openapi operation=getStandardFilterTree path=/standards/{standardId}/filterTree method=GET
   * @memberof StandardApi
   */
  getFilterTree(standardId: UUID): Promise<{ [key: string]: StandardFilterTreeNode; }>;

  /**
   * Get standard filters
   * @summary Get standard filters
   * @param {StandardType} [standardType] 
   * @param {*} [options] Override http request option.
   * @throws {@link @zerobias-org/types-core-js#ParameterRequiredError} if any required parameter is not provided
   * @example
   * ```typescript
   * const result = await api.getFilters(null);
   * ```
   * @openapi operation=getStandardFilters path=/standardFilters method=GET
   * @memberof StandardApi
   */
  getFilters(standardType?: StandardTypeDef): Promise<StandardFilters>;

  /**
   * Returns search options for standard element compliance features by columnName and search
   * @summary Returns search options for standard element compliance features by columnName and search
   * @param {UUID} standardId 
   * @param {UUID} elementId 
   * @param {string} columnName 
   * @param {string} search 
   * @param {UUID} [standard] 
   * @param {*} [options] Override http request option.
   * @throws {@link @zerobias-org/types-core-js#ParameterRequiredError} if any required parameter is not provided
   * @example
   * ```typescript
   * const result = await api.searchElementComplianceFeatureColumnOptions('00000000-0000-0000-0000-000000000000', '00000000-0000-0000-0000-000000000000', 'columnName', 'search', '00000000-0000-0000-0000-000000000000');
   * ```
   * @openapi operation=searchElementComplianceFeatureColumnOptions path=/standards/{standardId}/elements/{elementId}/complianceFeatureSearch/searchOptions method=GET
   * @memberof StandardApi
   */
  searchElementComplianceFeatureColumnOptions(standardId: UUID, elementId: UUID, columnName: string, search: string, standard?: UUID): Promise<ResultsSearchOptionsWrapper>;

  /**
   * Returns options/filters for standard element compliance features
   * @summary Returns options/filters for standard element compliance features
   * @param {UUID} standardId 
   * @param {UUID} elementId 
   * @param {UUID} [standard] 
   * @param {*} [options] Override http request option.
   * @throws {@link @zerobias-org/types-core-js#ParameterRequiredError} if any required parameter is not provided
   * @example
   * ```typescript
   * const result = await api.searchElementComplianceFeatureOptions('00000000-0000-0000-0000-000000000000', '00000000-0000-0000-0000-000000000000', '00000000-0000-0000-0000-000000000000');
   * ```
   * @openapi operation=searchElementComplianceFeatureOptions path=/standards/{standardId}/elements/{elementId}/complianceFeatureSearch/options method=GET
   * @memberof StandardApi
   */
  searchElementComplianceFeatureOptions(standardId: UUID, elementId: UUID, standard?: UUID): Promise<ResultsColumnOptionsWrapper>;

  /**
   * Search element compliance features
   * @summary Search element compliance features
   * @param {UUID} standardId 
   * @param {UUID} elementId 
   * @param {SearchElementComplianceFeatureBody} searchElementComplianceFeatureBody 
   * @param {number} [pageNumber] The requested page. This value is 1-indexed.
   * @param {number} [pageSize] The number of items in each page of data.
   * @param {SortObject} [sort] Sort object
   * @param {*} [options] Override http request option.
   * @throws {@link @zerobias-org/types-core-js#ParameterRequiredError} if any required parameter is not provided
   * @example
   * ```typescript
   * const result = await api.searchElementComplianceFeatures('00000000-0000-0000-0000-000000000000', '00000000-0000-0000-0000-000000000000', null, 1, 1, null);
   * ```
   * @openapi operation=searchElementComplianceFeatures path=/standards/{standardId}/elements/{elementId}/complianceFeatureSearch method=POST
   * @memberof StandardApi
   */
  searchElementComplianceFeatures(standardId: UUID, elementId: UUID, searchElementComplianceFeatureBody: SearchElementComplianceFeatureBody, pageNumber?: number, pageSize?: number, sort?: SortObject): Promise<PagedResults<ComplianceFeatureExtended>>;

  /**
   * Returns options/filters for standard elements crosswalk elements
   * @summary Returns options/filters for standard elements crosswalk elements
   * @param {UUID} standardId 
   * @param {UUID} elementId 
   * @param {*} [options] Override http request option.
   * @throws {@link @zerobias-org/types-core-js#ParameterRequiredError} if any required parameter is not provided
   * @example
   * ```typescript
   * const result = await api.searchElementCrosswalkElementOptions('00000000-0000-0000-0000-000000000000', '00000000-0000-0000-0000-000000000000');
   * ```
   * @openapi operation=searchElementCrosswalkElementOptions path=/standards/{standardId}/elements/{elementId}/crosswalkSearch/options method=GET
   * @memberof StandardApi
   */
  searchElementCrosswalkElementOptions(standardId: UUID, elementId: UUID): Promise<ResultsColumnOptionsWrapper>;

  /**
   * Search element crosswalk elements
   * @summary Search element crosswalk elements
   * @param {UUID} standardId 
   * @param {UUID} elementId 
   * @param {SearchElementCrosswalkElementBody} searchElementCrosswalkElementBody 
   * @param {number} [pageNumber] The requested page. This value is 1-indexed.
   * @param {number} [pageSize] The number of items in each page of data.
   * @param {SortObject} [sort] Sort object
   * @param {*} [options] Override http request option.
   * @throws {@link @zerobias-org/types-core-js#ParameterRequiredError} if any required parameter is not provided
   * @example
   * ```typescript
   * const result = await api.searchElementCrosswalkElements('00000000-0000-0000-0000-000000000000', '00000000-0000-0000-0000-000000000000', null, 1, 1, null);
   * ```
   * @openapi operation=searchElementCrosswalkElements path=/standards/{standardId}/elements/{elementId}/crosswalkSearch method=POST
   * @memberof StandardApi
   */
  searchElementCrosswalkElements(standardId: UUID, elementId: UUID, searchElementCrosswalkElementBody: SearchElementCrosswalkElementBody, pageNumber?: number, pageSize?: number, sort?: SortObject): Promise<PagedResults<ElementCrosswalkElement>>;

  /**
   * Returns options/filters for standard elements
   * @summary Returns options/filters for standard elements
   * @param {UUID} standardId 
   * @param {*} [options] Override http request option.
   * @throws {@link @zerobias-org/types-core-js#ParameterRequiredError} if any required parameter is not provided
   * @example
   * ```typescript
   * const result = await api.searchElementOptions('00000000-0000-0000-0000-000000000000');
   * ```
   * @openapi operation=searchElementOptions path=/standards/{standardId}/elementSearch/options method=GET
   * @memberof StandardApi
   */
  searchElementOptions(standardId: UUID): Promise<ResultsColumnOptionsWrapper>;

  /**
   * search elements within a standard
   * @summary search elements within a standard
   * @param {UUID} standardId 
   * @param {SearchElementBody} searchElementBody 
   * @param {number} [pageNumber] The requested page. This value is 1-indexed.
   * @param {number} [pageSize] The number of items in each page of data.
   * @param {SortObject} [sort] Sort object
   * @param {*} [options] Override http request option.
   * @throws {@link @zerobias-org/types-core-js#ParameterRequiredError} if any required parameter is not provided
   * @example
   * ```typescript
   * const result = await api.searchElements('00000000-0000-0000-0000-000000000000', null, 1, 1, null);
   * ```
   * @openapi operation=searchElements path=/standards/{standardId}/elementSearch method=POST
   * @memberof StandardApi
   */
  searchElements(standardId: UUID, searchElementBody: SearchElementBody, pageNumber?: number, pageSize?: number, sort?: SortObject): Promise<PagedResults<ElementExtended>>;

  /**
   * search standards
   * @summary search standards
   * @param {SearchStandardBody} searchStandardBody 
   * @param {number} [pageNumber] The requested page. This value is 1-indexed.
   * @param {number} [pageSize] The number of items in each page of data.
   * @param {boolean} [hide] Whether to hide frameworks and benchmarks
   * @param {SortObject} [sort] Sort object
   * @param {*} [options] Override http request option.
   * @throws {@link @zerobias-org/types-core-js#ParameterRequiredError} if any required parameter is not provided
   * @example
   * ```typescript
   * const result = await api.search(null, 1, 1, true, null);
   * ```
   * @openapi operation=searchStandards path=/standardSearch method=POST
   * @memberof StandardApi
   */
  search(searchStandardBody: SearchStandardBody, pageNumber?: number, pageSize?: number, hide?: boolean, sort?: SortObject): Promise<PagedResults<StandardExtended>>;

  /**
   * search standards by type
   * @summary search standards by type
   * @param {StandardType} standardType 
   * @param {SearchStandardByTypeBody} searchStandardByTypeBody 
   * @param {number} [pageNumber] The requested page. This value is 1-indexed.
   * @param {number} [pageSize] The number of items in each page of data.
   * @param {SortObject} [sort] Sort object
   * @param {*} [options] Override http request option.
   * @throws {@link @zerobias-org/types-core-js#ParameterRequiredError} if any required parameter is not provided
   * @example
   * ```typescript
   * const result = await api.searchByType(null, null, 1, 1, null);
   * ```
   * @openapi operation=searchStandardsByType path=/standards/{standardType}/search method=POST
   * @memberof StandardApi
   */
  searchByType(standardType: StandardTypeDef, searchStandardByTypeBody: SearchStandardByTypeBody, pageNumber?: number, pageSize?: number, sort?: SortObject): Promise<PagedResults<StandardExtended>>;

  /**
   * Returns options/filters for standards by type
   * @summary Returns options/filters for standards by type
   * @param {StandardType} standardType 
   * @param {*} [options] Override http request option.
   * @throws {@link @zerobias-org/types-core-js#ParameterRequiredError} if any required parameter is not provided
   * @example
   * ```typescript
   * const result = await api.searchStandardsByTypeOptions(null);
   * ```
   * @openapi operation=searchStandardsByTypeOptions path=/standards/{standardType}/search/options method=GET
   * @memberof StandardApi
   */
  searchStandardsByTypeOptions(standardType: StandardTypeDef): Promise<ResultsColumnOptionsWrapper>;

  /**
   * Returns options/filters for standards
   * @summary Returns options/filters for standards
   * @param {boolean} [hide] Whether to hide frameworks and benchmarks
   * @param {*} [options] Override http request option.
   * @throws {@link @zerobias-org/types-core-js#ParameterRequiredError} if any required parameter is not provided
   * @example
   * ```typescript
   * const result = await api.searchStandardsOptions(true);
   * ```
   * @openapi operation=searchStandardsOptions path=/standardSearch/options method=GET
   * @memberof StandardApi
   */
  searchStandardsOptions(hide?: boolean): Promise<ResultsColumnOptionsWrapper>;

}

/**
 * StandardProducerApi - interface
 * Producer interface for Standard
 * @export
 * @interface StandardProducerApi
 */
export interface StandardProducerApi {
  /**
  * Returns standard elements crosswalk graph
  * @summary Returns standard elements crosswalk graph
  * @param {UUID} standardId 
  * @param {UUID} elementId 
  * @param {number} [depth] 
  * @param {*} [options] Override http request option.
  * @throws {@link @zerobias-org/types-core-js#ParameterRequiredError} if any required parameter is not provided
  * @openapi operation=elementCrosswalkGraph path=/standards/{standardId}/elements/{elementId}/crosswalkGraph method=GET
  * @memberof Standard
  */
  elementCrosswalkGraph(standardId: UUID, elementId: UUID, depth?: number): Promise<Array<ElementCrosswalkElement>>;
  /**
  * Get boundary standard baseline control tree
  * @summary Get boundary standard baseline control tree
  * @param {UUID} boundaryStandardBaselineId 
  * @param {*} [options] Override http request option.
  * @throws {@link @zerobias-org/types-core-js#ParameterRequiredError} if any required parameter is not provided
  * @openapi operation=getBoundaryStandardBaselineControlTree path=/boundaryStandardBaselines/{boundaryStandardBaselineId}/controlTree method=GET
  * @memberof Standard
  */
  getBoundaryStandardBaselineControlTree(boundaryStandardBaselineId: UUID): Promise<{ [key: string]: ControlTreeNode; }>;
  /**
  * Get standard filter tree
  * @summary Get standard filter tree
  * @param {UUID} boundaryStandardBaselineId 
  * @param {*} [options] Override http request option.
  * @throws {@link @zerobias-org/types-core-js#ParameterRequiredError} if any required parameter is not provided
  * @openapi operation=getBoundaryStandardBaselineFilterTree path=/boundaryStandardBaselines/{boundaryStandardBaselineId}/filterTree method=GET
  * @memberof Standard
  */
  getBoundaryStandardBaselineFilterTree(boundaryStandardBaselineId: UUID): Promise<{ [key: string]: StandardFilterTreeNode; }>;
  /**
  * List boundary standard baseline metrics
  * @summary List boundary standard baseline metrics
  * @param {UUID} boundaryStandardBaselineId 
  * @param {*} [options] Override http request option.
  * @throws {@link @zerobias-org/types-core-js#ParameterRequiredError} if any required parameter is not provided
  * @openapi operation=getBoundaryStandardBaselineMetrics path=/boundaryStandardBaselines/{boundaryStandardBaselineId}/metrics method=GET
  * @memberof Standard
  */
  getBoundaryStandardBaselineMetrics(boundaryStandardBaselineId: UUID): Promise<BoundaryStandardBaselineMetrics>;
  /**
  * Get element crosswalk chain
  * @summary Get element crosswalk chain
  * @param {UUID} standardId 
  * @param {UUID} elementId 
  * @param {UUID} mappedElementId 
  * @param {number} mappedElementRank 
  * @param {*} [options] Override http request option.
  * @throws {@link @zerobias-org/types-core-js#ParameterRequiredError} if any required parameter is not provided
  * @openapi operation=getElementCrosswalkChain path=/standards/{standardId}/elements/{elementId}/crosswalkChain method=GET
  * @memberof Standard
  */
  getElementCrosswalkChain(standardId: UUID, elementId: UUID, mappedElementId: UUID, mappedElementRank: number): Promise<Array<ElementCrosswalkElement>>;
  /**
  * Get standard by id
  * @summary Get standard by id
  * @param {UUID} standardId 
  * @param {*} [options] Override http request option.
  * @throws {@link @zerobias-org/types-core-js#ParameterRequiredError} if any required parameter is not provided
  * @openapi operation=getStandard path=/standards/{standardId} method=GET
  * @memberof Standard
  */
  get(standardId: UUID): Promise<StandardExtended>;
  /**
  * Get standard element by id
  * @summary Get standard element by id
  * @param {UUID} standardId 
  * @param {UUID} elementId 
  * @param {*} [options] Override http request option.
  * @throws {@link @zerobias-org/types-core-js#ParameterRequiredError} if any required parameter is not provided
  * @openapi operation=getStandardElement path=/standards/{standardId}/elements/{elementId} method=GET
  * @memberof Standard
  */
  getElement(standardId: UUID, elementId: UUID): Promise<ElementExtended>;
  /**
  * Get standard filter tree
  * @summary Get standard filter tree
  * @param {UUID} standardId 
  * @param {*} [options] Override http request option.
  * @throws {@link @zerobias-org/types-core-js#ParameterRequiredError} if any required parameter is not provided
  * @openapi operation=getStandardFilterTree path=/standards/{standardId}/filterTree method=GET
  * @memberof Standard
  */
  getFilterTree(standardId: UUID): Promise<{ [key: string]: StandardFilterTreeNode; }>;
  /**
  * Get standard filters
  * @summary Get standard filters
  * @param {StandardType} [standardType] 
  * @param {*} [options] Override http request option.
  * @throws {@link @zerobias-org/types-core-js#ParameterRequiredError} if any required parameter is not provided
  * @openapi operation=getStandardFilters path=/standardFilters method=GET
  * @memberof Standard
  */
  getFilters(standardType?: StandardTypeDef): Promise<StandardFilters>;
  /**
  * Returns search options for standard element compliance features by columnName and search
  * @summary Returns search options for standard element compliance features by columnName and search
  * @param {UUID} standardId 
  * @param {UUID} elementId 
  * @param {string} columnName 
  * @param {string} search 
  * @param {UUID} [standard] 
  * @param {*} [options] Override http request option.
  * @throws {@link @zerobias-org/types-core-js#ParameterRequiredError} if any required parameter is not provided
  * @openapi operation=searchElementComplianceFeatureColumnOptions path=/standards/{standardId}/elements/{elementId}/complianceFeatureSearch/searchOptions method=GET
  * @memberof Standard
  */
  searchElementComplianceFeatureColumnOptions(standardId: UUID, elementId: UUID, columnName: string, search: string, standard?: UUID): Promise<ResultsSearchOptionsWrapper>;
  /**
  * Returns options/filters for standard element compliance features
  * @summary Returns options/filters for standard element compliance features
  * @param {UUID} standardId 
  * @param {UUID} elementId 
  * @param {UUID} [standard] 
  * @param {*} [options] Override http request option.
  * @throws {@link @zerobias-org/types-core-js#ParameterRequiredError} if any required parameter is not provided
  * @openapi operation=searchElementComplianceFeatureOptions path=/standards/{standardId}/elements/{elementId}/complianceFeatureSearch/options method=GET
  * @memberof Standard
  */
  searchElementComplianceFeatureOptions(standardId: UUID, elementId: UUID, standard?: UUID): Promise<ResultsColumnOptionsWrapper>;
  /**
  * Search element compliance features
  * @summary Search element compliance features
  * @param {UUID} standardId 
  * @param {UUID} elementId 
  * @param {SearchElementComplianceFeatureBody} searchElementComplianceFeatureBody 
  * @param {SortObject} [sort] Sort object
  * @param {*} [options] Override http request option.
  * @throws {@link @zerobias-org/types-core-js#ParameterRequiredError} if any required parameter is not provided
  * @openapi operation=searchElementComplianceFeatures path=/standards/{standardId}/elements/{elementId}/complianceFeatureSearch method=POST
  * @memberof Standard
  */
  searchElementComplianceFeatures(results: PagedResults<ComplianceFeatureExtended>, standardId: UUID, elementId: UUID, searchElementComplianceFeatureBody: SearchElementComplianceFeatureBody, sort?: SortObject): Promise<void>;
  /**
  * Returns options/filters for standard elements crosswalk elements
  * @summary Returns options/filters for standard elements crosswalk elements
  * @param {UUID} standardId 
  * @param {UUID} elementId 
  * @param {*} [options] Override http request option.
  * @throws {@link @zerobias-org/types-core-js#ParameterRequiredError} if any required parameter is not provided
  * @openapi operation=searchElementCrosswalkElementOptions path=/standards/{standardId}/elements/{elementId}/crosswalkSearch/options method=GET
  * @memberof Standard
  */
  searchElementCrosswalkElementOptions(standardId: UUID, elementId: UUID): Promise<ResultsColumnOptionsWrapper>;
  /**
  * Search element crosswalk elements
  * @summary Search element crosswalk elements
  * @param {UUID} standardId 
  * @param {UUID} elementId 
  * @param {SearchElementCrosswalkElementBody} searchElementCrosswalkElementBody 
  * @param {SortObject} [sort] Sort object
  * @param {*} [options] Override http request option.
  * @throws {@link @zerobias-org/types-core-js#ParameterRequiredError} if any required parameter is not provided
  * @openapi operation=searchElementCrosswalkElements path=/standards/{standardId}/elements/{elementId}/crosswalkSearch method=POST
  * @memberof Standard
  */
  searchElementCrosswalkElements(results: PagedResults<ElementCrosswalkElement>, standardId: UUID, elementId: UUID, searchElementCrosswalkElementBody: SearchElementCrosswalkElementBody, sort?: SortObject): Promise<void>;
  /**
  * Returns options/filters for standard elements
  * @summary Returns options/filters for standard elements
  * @param {UUID} standardId 
  * @param {*} [options] Override http request option.
  * @throws {@link @zerobias-org/types-core-js#ParameterRequiredError} if any required parameter is not provided
  * @openapi operation=searchElementOptions path=/standards/{standardId}/elementSearch/options method=GET
  * @memberof Standard
  */
  searchElementOptions(standardId: UUID): Promise<ResultsColumnOptionsWrapper>;
  /**
  * search elements within a standard
  * @summary search elements within a standard
  * @param {UUID} standardId 
  * @param {SearchElementBody} searchElementBody 
  * @param {SortObject} [sort] Sort object
  * @param {*} [options] Override http request option.
  * @throws {@link @zerobias-org/types-core-js#ParameterRequiredError} if any required parameter is not provided
  * @openapi operation=searchElements path=/standards/{standardId}/elementSearch method=POST
  * @memberof Standard
  */
  searchElements(results: PagedResults<ElementExtended>, standardId: UUID, searchElementBody: SearchElementBody, sort?: SortObject): Promise<void>;
  /**
  * search standards
  * @summary search standards
  * @param {SearchStandardBody} searchStandardBody 
  * @param {boolean} [hide] Whether to hide frameworks and benchmarks
  * @param {SortObject} [sort] Sort object
  * @param {*} [options] Override http request option.
  * @throws {@link @zerobias-org/types-core-js#ParameterRequiredError} if any required parameter is not provided
  * @openapi operation=searchStandards path=/standardSearch method=POST
  * @memberof Standard
  */
  search(results: PagedResults<StandardExtended>, searchStandardBody: SearchStandardBody, hide?: boolean, sort?: SortObject): Promise<void>;
  /**
  * search standards by type
  * @summary search standards by type
  * @param {StandardType} standardType 
  * @param {SearchStandardByTypeBody} searchStandardByTypeBody 
  * @param {SortObject} [sort] Sort object
  * @param {*} [options] Override http request option.
  * @throws {@link @zerobias-org/types-core-js#ParameterRequiredError} if any required parameter is not provided
  * @openapi operation=searchStandardsByType path=/standards/{standardType}/search method=POST
  * @memberof Standard
  */
  searchByType(results: PagedResults<StandardExtended>, standardType: StandardTypeDef, searchStandardByTypeBody: SearchStandardByTypeBody, sort?: SortObject): Promise<void>;
  /**
  * Returns options/filters for standards by type
  * @summary Returns options/filters for standards by type
  * @param {StandardType} standardType 
  * @param {*} [options] Override http request option.
  * @throws {@link @zerobias-org/types-core-js#ParameterRequiredError} if any required parameter is not provided
  * @openapi operation=searchStandardsByTypeOptions path=/standards/{standardType}/search/options method=GET
  * @memberof Standard
  */
  searchStandardsByTypeOptions(standardType: StandardTypeDef): Promise<ResultsColumnOptionsWrapper>;
  /**
  * Returns options/filters for standards
  * @summary Returns options/filters for standards
  * @param {boolean} [hide] Whether to hide frameworks and benchmarks
  * @param {*} [options] Override http request option.
  * @throws {@link @zerobias-org/types-core-js#ParameterRequiredError} if any required parameter is not provided
  * @openapi operation=searchStandardsOptions path=/standardSearch/options method=GET
  * @memberof Standard
  */
  searchStandardsOptions(hide?: boolean): Promise<ResultsColumnOptionsWrapper>;
}

export class StandardApiMappingImpl implements StandardApi {
  private producer: StandardProducerApi;
  constructor(producer: StandardProducerApi) {
    this.producer = producer;
  }

  /**
   * Returns standard elements crosswalk graph
   * @summary Returns standard elements crosswalk graph
   * @param standardId 
   * @param elementId 
   * @param depth 
   * @openapi operation=elementCrosswalkGraph path=/standards/{standardId}/elements/{elementId}/crosswalkGraph method=GET
   */
  public async elementCrosswalkGraph(standardId: UUID, elementId: UUID, depth?: number): Promise<Array<ElementCrosswalkElement>> {
    // verify required parameter 'standardId' is not null or undefined
    if (standardId === null || standardId === undefined) {
      throw new ParameterRequiredError('standardId');
    }
    // verify required parameter 'elementId' is not null or undefined
    if (elementId === null || elementId === undefined) {
      throw new ParameterRequiredError('elementId');
    }
    if (depth) {
      await Int32.parse(depth);
    }
    return this.producer.elementCrosswalkGraph(standardId, elementId, depth);
  }
  /**
   * Get boundary standard baseline control tree
   * @summary Get boundary standard baseline control tree
   * @param boundaryStandardBaselineId 
   * @openapi operation=getBoundaryStandardBaselineControlTree path=/boundaryStandardBaselines/{boundaryStandardBaselineId}/controlTree method=GET
   */
  public async getBoundaryStandardBaselineControlTree(boundaryStandardBaselineId: UUID): Promise<{ [key: string]: ControlTreeNode; }> {
    // verify required parameter 'boundaryStandardBaselineId' is not null or undefined
    if (boundaryStandardBaselineId === null || boundaryStandardBaselineId === undefined) {
      throw new ParameterRequiredError('boundaryStandardBaselineId');
    }
    return this.producer.getBoundaryStandardBaselineControlTree(boundaryStandardBaselineId);
  }
  /**
   * Get standard filter tree
   * @summary Get standard filter tree
   * @param boundaryStandardBaselineId 
   * @openapi operation=getBoundaryStandardBaselineFilterTree path=/boundaryStandardBaselines/{boundaryStandardBaselineId}/filterTree method=GET
   */
  public async getBoundaryStandardBaselineFilterTree(boundaryStandardBaselineId: UUID): Promise<{ [key: string]: StandardFilterTreeNode; }> {
    // verify required parameter 'boundaryStandardBaselineId' is not null or undefined
    if (boundaryStandardBaselineId === null || boundaryStandardBaselineId === undefined) {
      throw new ParameterRequiredError('boundaryStandardBaselineId');
    }
    return this.producer.getBoundaryStandardBaselineFilterTree(boundaryStandardBaselineId);
  }
  /**
   * List boundary standard baseline metrics
   * @summary List boundary standard baseline metrics
   * @param boundaryStandardBaselineId 
   * @openapi operation=getBoundaryStandardBaselineMetrics path=/boundaryStandardBaselines/{boundaryStandardBaselineId}/metrics method=GET
   */
  public async getBoundaryStandardBaselineMetrics(boundaryStandardBaselineId: UUID): Promise<BoundaryStandardBaselineMetrics> {
    // verify required parameter 'boundaryStandardBaselineId' is not null or undefined
    if (boundaryStandardBaselineId === null || boundaryStandardBaselineId === undefined) {
      throw new ParameterRequiredError('boundaryStandardBaselineId');
    }
    return this.producer.getBoundaryStandardBaselineMetrics(boundaryStandardBaselineId);
  }
  /**
   * Get element crosswalk chain
   * @summary Get element crosswalk chain
   * @param standardId 
   * @param elementId 
   * @param mappedElementId 
   * @param mappedElementRank 
   * @openapi operation=getElementCrosswalkChain path=/standards/{standardId}/elements/{elementId}/crosswalkChain method=GET
   */
  public async getElementCrosswalkChain(standardId: UUID, elementId: UUID, mappedElementId: UUID, mappedElementRank: number): Promise<Array<ElementCrosswalkElement>> {
    // verify required parameter 'standardId' is not null or undefined
    if (standardId === null || standardId === undefined) {
      throw new ParameterRequiredError('standardId');
    }
    // verify required parameter 'elementId' is not null or undefined
    if (elementId === null || elementId === undefined) {
      throw new ParameterRequiredError('elementId');
    }
    // verify required parameter 'mappedElementId' is not null or undefined
    if (mappedElementId === null || mappedElementId === undefined) {
      throw new ParameterRequiredError('mappedElementId');
    }
    // verify required parameter 'mappedElementRank' is not null or undefined
    if (mappedElementRank === null || mappedElementRank === undefined) {
      throw new ParameterRequiredError('mappedElementRank');
    }
    if (mappedElementRank) {
      await Int32.parse(mappedElementRank);
    }
    return this.producer.getElementCrosswalkChain(standardId, elementId, mappedElementId, mappedElementRank);
  }
  /**
   * Get standard by id
   * @summary Get standard by id
   * @param standardId 
   * @openapi operation=getStandard path=/standards/{standardId} method=GET
   */
  public async get(standardId: UUID): Promise<StandardExtended> {
    // verify required parameter 'standardId' is not null or undefined
    if (standardId === null || standardId === undefined) {
      throw new ParameterRequiredError('standardId');
    }
    return this.producer.get(standardId);
  }
  /**
   * Get standard element by id
   * @summary Get standard element by id
   * @param standardId 
   * @param elementId 
   * @openapi operation=getStandardElement path=/standards/{standardId}/elements/{elementId} method=GET
   */
  public async getElement(standardId: UUID, elementId: UUID): Promise<ElementExtended> {
    // verify required parameter 'standardId' is not null or undefined
    if (standardId === null || standardId === undefined) {
      throw new ParameterRequiredError('standardId');
    }
    // verify required parameter 'elementId' is not null or undefined
    if (elementId === null || elementId === undefined) {
      throw new ParameterRequiredError('elementId');
    }
    return this.producer.getElement(standardId, elementId);
  }
  /**
   * Get standard filter tree
   * @summary Get standard filter tree
   * @param standardId 
   * @openapi operation=getStandardFilterTree path=/standards/{standardId}/filterTree method=GET
   */
  public async getFilterTree(standardId: UUID): Promise<{ [key: string]: StandardFilterTreeNode; }> {
    // verify required parameter 'standardId' is not null or undefined
    if (standardId === null || standardId === undefined) {
      throw new ParameterRequiredError('standardId');
    }
    return this.producer.getFilterTree(standardId);
  }
  /**
   * Get standard filters
   * @summary Get standard filters
   * @param standardType 
   * @openapi operation=getStandardFilters path=/standardFilters method=GET
   */
  public async getFilters(standardType?: StandardTypeDef): Promise<StandardFilters> {
    return this.producer.getFilters(standardType);
  }
  /**
   * Returns search options for standard element compliance features by columnName and search
   * @summary Returns search options for standard element compliance features by columnName and search
   * @param standardId 
   * @param elementId 
   * @param columnName 
   * @param search 
   * @param standard 
   * @openapi operation=searchElementComplianceFeatureColumnOptions path=/standards/{standardId}/elements/{elementId}/complianceFeatureSearch/searchOptions method=GET
   */
  public async searchElementComplianceFeatureColumnOptions(standardId: UUID, elementId: UUID, columnName: string, search: string, standard?: UUID): Promise<ResultsSearchOptionsWrapper> {
    // verify required parameter 'standardId' is not null or undefined
    if (standardId === null || standardId === undefined) {
      throw new ParameterRequiredError('standardId');
    }
    // verify required parameter 'elementId' is not null or undefined
    if (elementId === null || elementId === undefined) {
      throw new ParameterRequiredError('elementId');
    }
    // verify required parameter 'columnName' is not null or undefined
    if (columnName === null || columnName === undefined || columnName === '') {
      throw new ParameterRequiredError('columnName');
    }
    // verify required parameter 'search' is not null or undefined
    if (search === null || search === undefined || search === '') {
      throw new ParameterRequiredError('search');
    }
    return this.producer.searchElementComplianceFeatureColumnOptions(standardId, elementId, columnName, search, standard);
  }
  /**
   * Returns options/filters for standard element compliance features
   * @summary Returns options/filters for standard element compliance features
   * @param standardId 
   * @param elementId 
   * @param standard 
   * @openapi operation=searchElementComplianceFeatureOptions path=/standards/{standardId}/elements/{elementId}/complianceFeatureSearch/options method=GET
   */
  public async searchElementComplianceFeatureOptions(standardId: UUID, elementId: UUID, standard?: UUID): Promise<ResultsColumnOptionsWrapper> {
    // verify required parameter 'standardId' is not null or undefined
    if (standardId === null || standardId === undefined) {
      throw new ParameterRequiredError('standardId');
    }
    // verify required parameter 'elementId' is not null or undefined
    if (elementId === null || elementId === undefined) {
      throw new ParameterRequiredError('elementId');
    }
    return this.producer.searchElementComplianceFeatureOptions(standardId, elementId, standard);
  }
  /**
   * Search element compliance features
   * @summary Search element compliance features
   * @param standardId 
   * @param elementId 
   * @param searchElementComplianceFeatureBody 
   * @param pageNumber The requested page. This value is 1-indexed.
   * @param pageSize The number of items in each page of data.
   * @param sort Sort object
   * @openapi operation=searchElementComplianceFeatures path=/standards/{standardId}/elements/{elementId}/complianceFeatureSearch method=POST
   */
  public async searchElementComplianceFeatures(standardId: UUID, elementId: UUID, searchElementComplianceFeatureBody: SearchElementComplianceFeatureBody, pageNumber: number = 1, pageSize: number = 50, sort?: SortObject): Promise<PagedResults<ComplianceFeatureExtended>> {
    // verify required parameter 'standardId' is not null or undefined
    if (standardId === null || standardId === undefined) {
      throw new ParameterRequiredError('standardId');
    }
    // verify required parameter 'elementId' is not null or undefined
    if (elementId === null || elementId === undefined) {
      throw new ParameterRequiredError('elementId');
    }
    // verify required parameter 'searchElementComplianceFeatureBody' is not null or undefined
    if (searchElementComplianceFeatureBody === null || searchElementComplianceFeatureBody === undefined) {
      throw new ParameterRequiredError('searchElementComplianceFeatureBody');
    }
    if (pageNumber) {
      await Int32.parse(pageNumber);
    }
    if (pageSize) {
      await Int32.parse(pageSize);
    }
    const bag = new PagedResults<ComplianceFeatureExtended>();
    bag.pageNumber = pageNumber;
    bag.pageSize = pageSize;
    await this.producer.searchElementComplianceFeatures(bag, standardId, elementId, searchElementComplianceFeatureBody, sort);
    if (bag.items === null || bag.items === undefined) {
      throw new UnexpectedError("Producers must return 'items' for PagedResults queries");
    }
    return bag;
  }
  /**
   * Returns options/filters for standard elements crosswalk elements
   * @summary Returns options/filters for standard elements crosswalk elements
   * @param standardId 
   * @param elementId 
   * @openapi operation=searchElementCrosswalkElementOptions path=/standards/{standardId}/elements/{elementId}/crosswalkSearch/options method=GET
   */
  public async searchElementCrosswalkElementOptions(standardId: UUID, elementId: UUID): Promise<ResultsColumnOptionsWrapper> {
    // verify required parameter 'standardId' is not null or undefined
    if (standardId === null || standardId === undefined) {
      throw new ParameterRequiredError('standardId');
    }
    // verify required parameter 'elementId' is not null or undefined
    if (elementId === null || elementId === undefined) {
      throw new ParameterRequiredError('elementId');
    }
    return this.producer.searchElementCrosswalkElementOptions(standardId, elementId);
  }
  /**
   * Search element crosswalk elements
   * @summary Search element crosswalk elements
   * @param standardId 
   * @param elementId 
   * @param searchElementCrosswalkElementBody 
   * @param pageNumber The requested page. This value is 1-indexed.
   * @param pageSize The number of items in each page of data.
   * @param sort Sort object
   * @openapi operation=searchElementCrosswalkElements path=/standards/{standardId}/elements/{elementId}/crosswalkSearch method=POST
   */
  public async searchElementCrosswalkElements(standardId: UUID, elementId: UUID, searchElementCrosswalkElementBody: SearchElementCrosswalkElementBody, pageNumber: number = 1, pageSize: number = 50, sort?: SortObject): Promise<PagedResults<ElementCrosswalkElement>> {
    // verify required parameter 'standardId' is not null or undefined
    if (standardId === null || standardId === undefined) {
      throw new ParameterRequiredError('standardId');
    }
    // verify required parameter 'elementId' is not null or undefined
    if (elementId === null || elementId === undefined) {
      throw new ParameterRequiredError('elementId');
    }
    // verify required parameter 'searchElementCrosswalkElementBody' is not null or undefined
    if (searchElementCrosswalkElementBody === null || searchElementCrosswalkElementBody === undefined) {
      throw new ParameterRequiredError('searchElementCrosswalkElementBody');
    }
    if (pageNumber) {
      await Int32.parse(pageNumber);
    }
    if (pageSize) {
      await Int32.parse(pageSize);
    }
    const bag = new PagedResults<ElementCrosswalkElement>();
    bag.pageNumber = pageNumber;
    bag.pageSize = pageSize;
    await this.producer.searchElementCrosswalkElements(bag, standardId, elementId, searchElementCrosswalkElementBody, sort);
    if (bag.items === null || bag.items === undefined) {
      throw new UnexpectedError("Producers must return 'items' for PagedResults queries");
    }
    return bag;
  }
  /**
   * Returns options/filters for standard elements
   * @summary Returns options/filters for standard elements
   * @param standardId 
   * @openapi operation=searchElementOptions path=/standards/{standardId}/elementSearch/options method=GET
   */
  public async searchElementOptions(standardId: UUID): Promise<ResultsColumnOptionsWrapper> {
    // verify required parameter 'standardId' is not null or undefined
    if (standardId === null || standardId === undefined) {
      throw new ParameterRequiredError('standardId');
    }
    return this.producer.searchElementOptions(standardId);
  }
  /**
   * search elements within a standard
   * @summary search elements within a standard
   * @param standardId 
   * @param searchElementBody 
   * @param pageNumber The requested page. This value is 1-indexed.
   * @param pageSize The number of items in each page of data.
   * @param sort Sort object
   * @openapi operation=searchElements path=/standards/{standardId}/elementSearch method=POST
   */
  public async searchElements(standardId: UUID, searchElementBody: SearchElementBody, pageNumber: number = 1, pageSize: number = 50, sort?: SortObject): Promise<PagedResults<ElementExtended>> {
    // verify required parameter 'standardId' is not null or undefined
    if (standardId === null || standardId === undefined) {
      throw new ParameterRequiredError('standardId');
    }
    // verify required parameter 'searchElementBody' is not null or undefined
    if (searchElementBody === null || searchElementBody === undefined) {
      throw new ParameterRequiredError('searchElementBody');
    }
    if (pageNumber) {
      await Int32.parse(pageNumber);
    }
    if (pageSize) {
      await Int32.parse(pageSize);
    }
    const bag = new PagedResults<ElementExtended>();
    bag.pageNumber = pageNumber;
    bag.pageSize = pageSize;
    await this.producer.searchElements(bag, standardId, searchElementBody, sort);
    if (bag.items === null || bag.items === undefined) {
      throw new UnexpectedError("Producers must return 'items' for PagedResults queries");
    }
    return bag;
  }
  /**
   * search standards
   * @summary search standards
   * @param searchStandardBody 
   * @param pageNumber The requested page. This value is 1-indexed.
   * @param pageSize The number of items in each page of data.
   * @param hide Whether to hide frameworks and benchmarks
   * @param sort Sort object
   * @openapi operation=searchStandards path=/standardSearch method=POST
   */
  public async search(searchStandardBody: SearchStandardBody, pageNumber: number = 1, pageSize: number = 50, hide?: boolean, sort?: SortObject): Promise<PagedResults<StandardExtended>> {
    // verify required parameter 'searchStandardBody' is not null or undefined
    if (searchStandardBody === null || searchStandardBody === undefined) {
      throw new ParameterRequiredError('searchStandardBody');
    }
    if (pageNumber) {
      await Int32.parse(pageNumber);
    }
    if (pageSize) {
      await Int32.parse(pageSize);
    }
    const bag = new PagedResults<StandardExtended>();
    bag.pageNumber = pageNumber;
    bag.pageSize = pageSize;
    await this.producer.search(bag, searchStandardBody, hide, sort);
    if (bag.items === null || bag.items === undefined) {
      throw new UnexpectedError("Producers must return 'items' for PagedResults queries");
    }
    return bag;
  }
  /**
   * search standards by type
   * @summary search standards by type
   * @param standardType 
   * @param searchStandardByTypeBody 
   * @param pageNumber The requested page. This value is 1-indexed.
   * @param pageSize The number of items in each page of data.
   * @param sort Sort object
   * @openapi operation=searchStandardsByType path=/standards/{standardType}/search method=POST
   */
  public async searchByType(standardType: StandardTypeDef, searchStandardByTypeBody: SearchStandardByTypeBody, pageNumber: number = 1, pageSize: number = 50, sort?: SortObject): Promise<PagedResults<StandardExtended>> {
    // verify required parameter 'standardType' is not null or undefined
    if (standardType === null || standardType === undefined) {
      throw new ParameterRequiredError('standardType');
    }
    // verify required parameter 'searchStandardByTypeBody' is not null or undefined
    if (searchStandardByTypeBody === null || searchStandardByTypeBody === undefined) {
      throw new ParameterRequiredError('searchStandardByTypeBody');
    }
    if (pageNumber) {
      await Int32.parse(pageNumber);
    }
    if (pageSize) {
      await Int32.parse(pageSize);
    }
    const bag = new PagedResults<StandardExtended>();
    bag.pageNumber = pageNumber;
    bag.pageSize = pageSize;
    await this.producer.searchByType(bag, standardType, searchStandardByTypeBody, sort);
    if (bag.items === null || bag.items === undefined) {
      throw new UnexpectedError("Producers must return 'items' for PagedResults queries");
    }
    return bag;
  }
  /**
   * Returns options/filters for standards by type
   * @summary Returns options/filters for standards by type
   * @param standardType 
   * @openapi operation=searchStandardsByTypeOptions path=/standards/{standardType}/search/options method=GET
   */
  public async searchStandardsByTypeOptions(standardType: StandardTypeDef): Promise<ResultsColumnOptionsWrapper> {
    // verify required parameter 'standardType' is not null or undefined
    if (standardType === null || standardType === undefined) {
      throw new ParameterRequiredError('standardType');
    }
    return this.producer.searchStandardsByTypeOptions(standardType);
  }
  /**
   * Returns options/filters for standards
   * @summary Returns options/filters for standards
   * @param hide Whether to hide frameworks and benchmarks
   * @openapi operation=searchStandardsOptions path=/standardSearch/options method=GET
   */
  public async searchStandardsOptions(hide?: boolean): Promise<ResultsColumnOptionsWrapper> {
    return this.producer.searchStandardsOptions(hide);
  }
}

/**
 * Wrap producer with mapping implementation
 */
export function wrapStandardProducer(producer: StandardProducerApi): StandardApi {
  return new StandardApiMappingImpl(producer);
}

/**
 * StandardApiHttpImpl - Direct HTTP implementation
 *
 * Makes direct HTTP calls to the API using Axios.
 * Used by SDK clients for platform service access.
 */
export class StandardApiHttpImpl implements StandardProducerApi {
  private client: AxiosInstance;
  private headers: Record<string, string>;

  constructor(client: AxiosInstance, headers: Record<string, string> = {}) {
    this.client = client;
    this.headers = headers;
  }

  async elementCrosswalkGraph(standardId: UUID, elementId: UUID, depth?: number): Promise<Array<ElementCrosswalkElement>> {
  const _queryParams = {
      depth,
  };
  const _bodyParams = {
      
  };
  let _path = '/standards/{standardId}/elements/{elementId}/crosswalkGraph';
  _path = _path.replace('{standardId}', encodeURIComponent(String(standardId)));
  _path = _path.replace('{elementId}', encodeURIComponent(String(elementId)));
  return this.client.get(
    _path,
    { params: _queryParams })
    .then((response) => {
      // BaseApiClient uses validateStatus: () => true, so we must check status manually
      if (response.status >= 400) {
        throw CoreError.deserialize(response.data);
      }
      return ObjectSerializer.deserialize(response.data, 'Array<ElementCrosswalkElement>')
    })
    .catch((error) => {
      if (error.data) {
        throw CoreError.deserialize(error.data);
      } else {
        throw error;
      }
    });
  }
  async getBoundaryStandardBaselineControlTree(boundaryStandardBaselineId: UUID): Promise<{ [key: string]: ControlTreeNode; }> {
  const _queryParams = {
      
  };
  const _bodyParams = {
      
  };
  let _path = '/boundaryStandardBaselines/{boundaryStandardBaselineId}/controlTree';
  _path = _path.replace('{boundaryStandardBaselineId}', encodeURIComponent(String(boundaryStandardBaselineId)));
  return this.client.get(
    _path,
    { params: _queryParams })
    .then((response) => {
      // BaseApiClient uses validateStatus: () => true, so we must check status manually
      if (response.status >= 400) {
        throw CoreError.deserialize(response.data);
      }
      return ObjectSerializer.deserialize(response.data, '{ [key: string]: ControlTreeNode; }')
    })
    .catch((error) => {
      if (error.data) {
        throw CoreError.deserialize(error.data);
      } else {
        throw error;
      }
    });
  }
  async getBoundaryStandardBaselineFilterTree(boundaryStandardBaselineId: UUID): Promise<{ [key: string]: StandardFilterTreeNode; }> {
  const _queryParams = {
      
  };
  const _bodyParams = {
      
  };
  let _path = '/boundaryStandardBaselines/{boundaryStandardBaselineId}/filterTree';
  _path = _path.replace('{boundaryStandardBaselineId}', encodeURIComponent(String(boundaryStandardBaselineId)));
  return this.client.get(
    _path,
    { params: _queryParams })
    .then((response) => {
      // BaseApiClient uses validateStatus: () => true, so we must check status manually
      if (response.status >= 400) {
        throw CoreError.deserialize(response.data);
      }
      return ObjectSerializer.deserialize(response.data, '{ [key: string]: StandardFilterTreeNode; }')
    })
    .catch((error) => {
      if (error.data) {
        throw CoreError.deserialize(error.data);
      } else {
        throw error;
      }
    });
  }
  async getBoundaryStandardBaselineMetrics(boundaryStandardBaselineId: UUID): Promise<BoundaryStandardBaselineMetrics> {
  const _queryParams = {
      
  };
  const _bodyParams = {
      
  };
  let _path = '/boundaryStandardBaselines/{boundaryStandardBaselineId}/metrics';
  _path = _path.replace('{boundaryStandardBaselineId}', encodeURIComponent(String(boundaryStandardBaselineId)));
  return this.client.get(
    _path,
    { params: _queryParams })
    .then((response) => {
      // BaseApiClient uses validateStatus: () => true, so we must check status manually
      if (response.status >= 400) {
        throw CoreError.deserialize(response.data);
      }
      return ObjectSerializer.deserialize(response.data, 'BoundaryStandardBaselineMetrics')
    })
    .catch((error) => {
      if (error.data) {
        throw CoreError.deserialize(error.data);
      } else {
        throw error;
      }
    });
  }
  async getElementCrosswalkChain(standardId: UUID, elementId: UUID, mappedElementId: UUID, mappedElementRank: number): Promise<Array<ElementCrosswalkElement>> {
  const _queryParams = {
      mappedElementId,mappedElementRank,
  };
  const _bodyParams = {
      
  };
  let _path = '/standards/{standardId}/elements/{elementId}/crosswalkChain';
  _path = _path.replace('{standardId}', encodeURIComponent(String(standardId)));
  _path = _path.replace('{elementId}', encodeURIComponent(String(elementId)));
  return this.client.get(
    _path,
    { params: _queryParams })
    .then((response) => {
      // BaseApiClient uses validateStatus: () => true, so we must check status manually
      if (response.status >= 400) {
        throw CoreError.deserialize(response.data);
      }
      return ObjectSerializer.deserialize(response.data, 'Array<ElementCrosswalkElement>')
    })
    .catch((error) => {
      if (error.data) {
        throw CoreError.deserialize(error.data);
      } else {
        throw error;
      }
    });
  }
  async get(standardId: UUID): Promise<StandardExtended> {
  const _queryParams = {
      
  };
  const _bodyParams = {
      
  };
  let _path = '/standards/{standardId}';
  _path = _path.replace('{standardId}', encodeURIComponent(String(standardId)));
  return this.client.get(
    _path,
    { params: _queryParams })
    .then((response) => {
      // BaseApiClient uses validateStatus: () => true, so we must check status manually
      if (response.status >= 400) {
        throw CoreError.deserialize(response.data);
      }
      return ObjectSerializer.deserialize(response.data, 'StandardExtended')
    })
    .catch((error) => {
      if (error.data) {
        throw CoreError.deserialize(error.data);
      } else {
        throw error;
      }
    });
  }
  async getElement(standardId: UUID, elementId: UUID): Promise<ElementExtended> {
  const _queryParams = {
      
  };
  const _bodyParams = {
      
  };
  let _path = '/standards/{standardId}/elements/{elementId}';
  _path = _path.replace('{standardId}', encodeURIComponent(String(standardId)));
  _path = _path.replace('{elementId}', encodeURIComponent(String(elementId)));
  return this.client.get(
    _path,
    { params: _queryParams })
    .then((response) => {
      // BaseApiClient uses validateStatus: () => true, so we must check status manually
      if (response.status >= 400) {
        throw CoreError.deserialize(response.data);
      }
      return ObjectSerializer.deserialize(response.data, 'ElementExtended')
    })
    .catch((error) => {
      if (error.data) {
        throw CoreError.deserialize(error.data);
      } else {
        throw error;
      }
    });
  }
  async getFilterTree(standardId: UUID): Promise<{ [key: string]: StandardFilterTreeNode; }> {
  const _queryParams = {
      
  };
  const _bodyParams = {
      
  };
  let _path = '/standards/{standardId}/filterTree';
  _path = _path.replace('{standardId}', encodeURIComponent(String(standardId)));
  return this.client.get(
    _path,
    { params: _queryParams })
    .then((response) => {
      // BaseApiClient uses validateStatus: () => true, so we must check status manually
      if (response.status >= 400) {
        throw CoreError.deserialize(response.data);
      }
      return ObjectSerializer.deserialize(response.data, '{ [key: string]: StandardFilterTreeNode; }')
    })
    .catch((error) => {
      if (error.data) {
        throw CoreError.deserialize(error.data);
      } else {
        throw error;
      }
    });
  }
  async getFilters(standardType?: StandardTypeDef): Promise<StandardFilters> {
  const _queryParams = {
      standardType,
  };
  const _bodyParams = {
      
  };
  let _path = '/standardFilters';
  return this.client.get(
    _path,
    { params: _queryParams })
    .then((response) => {
      // BaseApiClient uses validateStatus: () => true, so we must check status manually
      if (response.status >= 400) {
        throw CoreError.deserialize(response.data);
      }
      return ObjectSerializer.deserialize(response.data, 'StandardFilters')
    })
    .catch((error) => {
      if (error.data) {
        throw CoreError.deserialize(error.data);
      } else {
        throw error;
      }
    });
  }
  async searchElementComplianceFeatureColumnOptions(standardId: UUID, elementId: UUID, columnName: string, search: string, standard?: UUID): Promise<ResultsSearchOptionsWrapper> {
  const _queryParams = {
      standard,columnName,search,
  };
  const _bodyParams = {
      
  };
  let _path = '/standards/{standardId}/elements/{elementId}/complianceFeatureSearch/searchOptions';
  _path = _path.replace('{standardId}', encodeURIComponent(String(standardId)));
  _path = _path.replace('{elementId}', encodeURIComponent(String(elementId)));
  return this.client.get(
    _path,
    { params: _queryParams })
    .then((response) => {
      // BaseApiClient uses validateStatus: () => true, so we must check status manually
      if (response.status >= 400) {
        throw CoreError.deserialize(response.data);
      }
      return ObjectSerializer.deserialize(response.data, 'ResultsSearchOptionsWrapper')
    })
    .catch((error) => {
      if (error.data) {
        throw CoreError.deserialize(error.data);
      } else {
        throw error;
      }
    });
  }
  async searchElementComplianceFeatureOptions(standardId: UUID, elementId: UUID, standard?: UUID): Promise<ResultsColumnOptionsWrapper> {
  const _queryParams = {
      standard,
  };
  const _bodyParams = {
      
  };
  let _path = '/standards/{standardId}/elements/{elementId}/complianceFeatureSearch/options';
  _path = _path.replace('{standardId}', encodeURIComponent(String(standardId)));
  _path = _path.replace('{elementId}', encodeURIComponent(String(elementId)));
  return this.client.get(
    _path,
    { params: _queryParams })
    .then((response) => {
      // BaseApiClient uses validateStatus: () => true, so we must check status manually
      if (response.status >= 400) {
        throw CoreError.deserialize(response.data);
      }
      return ObjectSerializer.deserialize(response.data, 'ResultsColumnOptionsWrapper')
    })
    .catch((error) => {
      if (error.data) {
        throw CoreError.deserialize(error.data);
      } else {
        throw error;
      }
    });
  }
  async searchElementComplianceFeatures(results: PagedResults<ComplianceFeatureExtended>, standardId: UUID, elementId: UUID, searchElementComplianceFeatureBody: SearchElementComplianceFeatureBody, sort?: SortObject): Promise<void> {
  const _body = {
      standardId,elementId,searchElementComplianceFeatureBody,sort,
  };
  let _path = '/standards/{standardId}/elements/{elementId}/complianceFeatureSearch';
  _path = _path.replace('{standardId}', encodeURIComponent(String(standardId)));
  _path = _path.replace('{elementId}', encodeURIComponent(String(elementId)));
  return this.client.post(
    _path,
    {
      ..._body,
      pageNumber: results.pageNumber,
      pageSize: results.pageSize,
    })
    .then((response) => {
      // BaseApiClient uses validateStatus: () => true, so we must check status manually
      if (response.status >= 400) {
        throw CoreError.deserialize(response.data);
      }
      results.items = ObjectSerializer.deserialize(response.data, 'Array<ComplianceFeatureExtended>');
      results.count = response.headers.count ? Number(response.headers.count) : -1;
      results.pageToken = response.headers.pagetoken ?? response.headers.pageToken;
      results.headers = this.headers;
      results.baseUrl = new URL(`${this.client.getUri()}/standards/{standardId}/elements/{elementId}/complianceFeatureSearch`);
      results.httpMethod = HttpMethod.Post;
      results.body = _body;
      results.mapper = (obj) => ObjectSerializer.deserialize(obj, 'ComplianceFeatureExtended');
    })
    .catch((error) => {
      if (error.data) {
        throw CoreError.deserialize(error.data);
      } else {
        throw error;
      }
    });
  }
  async searchElementCrosswalkElementOptions(standardId: UUID, elementId: UUID): Promise<ResultsColumnOptionsWrapper> {
  const _queryParams = {
      
  };
  const _bodyParams = {
      
  };
  let _path = '/standards/{standardId}/elements/{elementId}/crosswalkSearch/options';
  _path = _path.replace('{standardId}', encodeURIComponent(String(standardId)));
  _path = _path.replace('{elementId}', encodeURIComponent(String(elementId)));
  return this.client.get(
    _path,
    { params: _queryParams })
    .then((response) => {
      // BaseApiClient uses validateStatus: () => true, so we must check status manually
      if (response.status >= 400) {
        throw CoreError.deserialize(response.data);
      }
      return ObjectSerializer.deserialize(response.data, 'ResultsColumnOptionsWrapper')
    })
    .catch((error) => {
      if (error.data) {
        throw CoreError.deserialize(error.data);
      } else {
        throw error;
      }
    });
  }
  async searchElementCrosswalkElements(results: PagedResults<ElementCrosswalkElement>, standardId: UUID, elementId: UUID, searchElementCrosswalkElementBody: SearchElementCrosswalkElementBody, sort?: SortObject): Promise<void> {
  const _body = {
      standardId,elementId,searchElementCrosswalkElementBody,sort,
  };
  let _path = '/standards/{standardId}/elements/{elementId}/crosswalkSearch';
  _path = _path.replace('{standardId}', encodeURIComponent(String(standardId)));
  _path = _path.replace('{elementId}', encodeURIComponent(String(elementId)));
  return this.client.post(
    _path,
    {
      ..._body,
      pageNumber: results.pageNumber,
      pageSize: results.pageSize,
    })
    .then((response) => {
      // BaseApiClient uses validateStatus: () => true, so we must check status manually
      if (response.status >= 400) {
        throw CoreError.deserialize(response.data);
      }
      results.items = ObjectSerializer.deserialize(response.data, 'Array<ElementCrosswalkElement>');
      results.count = response.headers.count ? Number(response.headers.count) : -1;
      results.pageToken = response.headers.pagetoken ?? response.headers.pageToken;
      results.headers = this.headers;
      results.baseUrl = new URL(`${this.client.getUri()}/standards/{standardId}/elements/{elementId}/crosswalkSearch`);
      results.httpMethod = HttpMethod.Post;
      results.body = _body;
      results.mapper = (obj) => ObjectSerializer.deserialize(obj, 'ElementCrosswalkElement');
    })
    .catch((error) => {
      if (error.data) {
        throw CoreError.deserialize(error.data);
      } else {
        throw error;
      }
    });
  }
  async searchElementOptions(standardId: UUID): Promise<ResultsColumnOptionsWrapper> {
  const _queryParams = {
      
  };
  const _bodyParams = {
      
  };
  let _path = '/standards/{standardId}/elementSearch/options';
  _path = _path.replace('{standardId}', encodeURIComponent(String(standardId)));
  return this.client.get(
    _path,
    { params: _queryParams })
    .then((response) => {
      // BaseApiClient uses validateStatus: () => true, so we must check status manually
      if (response.status >= 400) {
        throw CoreError.deserialize(response.data);
      }
      return ObjectSerializer.deserialize(response.data, 'ResultsColumnOptionsWrapper')
    })
    .catch((error) => {
      if (error.data) {
        throw CoreError.deserialize(error.data);
      } else {
        throw error;
      }
    });
  }
  async searchElements(results: PagedResults<ElementExtended>, standardId: UUID, searchElementBody: SearchElementBody, sort?: SortObject): Promise<void> {
  const _body = {
      standardId,searchElementBody,sort,
  };
  let _path = '/standards/{standardId}/elementSearch';
  _path = _path.replace('{standardId}', encodeURIComponent(String(standardId)));
  return this.client.post(
    _path,
    {
      ..._body,
      pageNumber: results.pageNumber,
      pageSize: results.pageSize,
    })
    .then((response) => {
      // BaseApiClient uses validateStatus: () => true, so we must check status manually
      if (response.status >= 400) {
        throw CoreError.deserialize(response.data);
      }
      results.items = ObjectSerializer.deserialize(response.data, 'Array<ElementExtended>');
      results.count = response.headers.count ? Number(response.headers.count) : -1;
      results.pageToken = response.headers.pagetoken ?? response.headers.pageToken;
      results.headers = this.headers;
      results.baseUrl = new URL(`${this.client.getUri()}/standards/{standardId}/elementSearch`);
      results.httpMethod = HttpMethod.Post;
      results.body = _body;
      results.mapper = (obj) => ObjectSerializer.deserialize(obj, 'ElementExtended');
    })
    .catch((error) => {
      if (error.data) {
        throw CoreError.deserialize(error.data);
      } else {
        throw error;
      }
    });
  }
  async search(results: PagedResults<StandardExtended>, searchStandardBody: SearchStandardBody, hide?: boolean, sort?: SortObject): Promise<void> {
  const _body = {
      searchStandardBody,hide,sort,
  };
  let _path = '/standardSearch';
  return this.client.post(
    _path,
    {
      ..._body,
      pageNumber: results.pageNumber,
      pageSize: results.pageSize,
    })
    .then((response) => {
      // BaseApiClient uses validateStatus: () => true, so we must check status manually
      if (response.status >= 400) {
        throw CoreError.deserialize(response.data);
      }
      results.items = ObjectSerializer.deserialize(response.data, 'Array<StandardExtended>');
      results.count = response.headers.count ? Number(response.headers.count) : -1;
      results.pageToken = response.headers.pagetoken ?? response.headers.pageToken;
      results.headers = this.headers;
      results.baseUrl = new URL(`${this.client.getUri()}/standardSearch`);
      results.httpMethod = HttpMethod.Post;
      results.body = _body;
      results.mapper = (obj) => ObjectSerializer.deserialize(obj, 'StandardExtended');
    })
    .catch((error) => {
      if (error.data) {
        throw CoreError.deserialize(error.data);
      } else {
        throw error;
      }
    });
  }
  async searchByType(results: PagedResults<StandardExtended>, standardType: StandardTypeDef, searchStandardByTypeBody: SearchStandardByTypeBody, sort?: SortObject): Promise<void> {
  const _body = {
      standardType,searchStandardByTypeBody,sort,
  };
  let _path = '/standards/{standardType}/search';
  _path = _path.replace('{standardType}', encodeURIComponent(String(standardType)));
  return this.client.post(
    _path,
    {
      ..._body,
      pageNumber: results.pageNumber,
      pageSize: results.pageSize,
    })
    .then((response) => {
      // BaseApiClient uses validateStatus: () => true, so we must check status manually
      if (response.status >= 400) {
        throw CoreError.deserialize(response.data);
      }
      results.items = ObjectSerializer.deserialize(response.data, 'Array<StandardExtended>');
      results.count = response.headers.count ? Number(response.headers.count) : -1;
      results.pageToken = response.headers.pagetoken ?? response.headers.pageToken;
      results.headers = this.headers;
      results.baseUrl = new URL(`${this.client.getUri()}/standards/{standardType}/search`);
      results.httpMethod = HttpMethod.Post;
      results.body = _body;
      results.mapper = (obj) => ObjectSerializer.deserialize(obj, 'StandardExtended');
    })
    .catch((error) => {
      if (error.data) {
        throw CoreError.deserialize(error.data);
      } else {
        throw error;
      }
    });
  }
  async searchStandardsByTypeOptions(standardType: StandardTypeDef): Promise<ResultsColumnOptionsWrapper> {
  const _queryParams = {
      
  };
  const _bodyParams = {
      
  };
  let _path = '/standards/{standardType}/search/options';
  _path = _path.replace('{standardType}', encodeURIComponent(String(standardType)));
  return this.client.get(
    _path,
    { params: _queryParams })
    .then((response) => {
      // BaseApiClient uses validateStatus: () => true, so we must check status manually
      if (response.status >= 400) {
        throw CoreError.deserialize(response.data);
      }
      return ObjectSerializer.deserialize(response.data, 'ResultsColumnOptionsWrapper')
    })
    .catch((error) => {
      if (error.data) {
        throw CoreError.deserialize(error.data);
      } else {
        throw error;
      }
    });
  }
  async searchStandardsOptions(hide?: boolean): Promise<ResultsColumnOptionsWrapper> {
  const _queryParams = {
      hide,
  };
  const _bodyParams = {
      
  };
  let _path = '/standardSearch/options';
  return this.client.get(
    _path,
    { params: _queryParams })
    .then((response) => {
      // BaseApiClient uses validateStatus: () => true, so we must check status manually
      if (response.status >= 400) {
        throw CoreError.deserialize(response.data);
      }
      return ObjectSerializer.deserialize(response.data, 'ResultsColumnOptionsWrapper')
    })
    .catch((error) => {
      if (error.data) {
        throw CoreError.deserialize(error.data);
      } else {
        throw error;
      }
    });
  }
}
