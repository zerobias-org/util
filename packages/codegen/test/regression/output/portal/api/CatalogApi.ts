/* eslint-disable */
// ===============================================
// This file is autogenerated - Please do not edit
// ===============================================
import { AxiosInstance } from 'axios';
import { CatalogClass, CatalogOverview, CatalogRequestArtifactTypeDef, CatalogRequestCommentExtended, CatalogRequestExtended, CatalogSchema, CreateCatalogRequest, CreateCatalogRequestComment, ObjectSearchColumns, ObjectSearchFilterForClass, ObjectSearchResultForClass, ObjectSearchResultsMetadata, ResultsColumnOptionsWrapper, SearchCatalogSchemaBody, SearchClassBody, SearchRequestBody, SortObject } from '../model/index.js';
import { URL, EnumValue, IllegalArgumentError, PagedResults, Int32, UUID, CoreError, ParameterRequiredError, UnexpectedError, HttpMethod } from '@zerobias-org/types-core-js';
import { RequestFile, ObjectSerializer } from '../model/index.js';

export namespace CatalogApi {
}

/**
 * CatalogApi - interface
 * @export
 * @interface CatalogApi
 */
export interface CatalogApi {
  /**
   * Search all catalog classes
   * @summary Search all catalog classes
   * @param {SearchClassBody} searchClassBody 
   * @param {number} [pageNumber] The requested page. This value is 1-indexed.
   * @param {number} [pageSize] The number of items in each page of data.
   * @param {SortObject} [sort] 
   * @param {*} [options] Override http request option.
   * @throws {@link @zerobias-org/types-core-js#ParameterRequiredError} if any required parameter is not provided
   * @example
   * ```typescript
   * const result = await api.searchClasses(null, 1, 1, null);
   * ```
   * @openapi operation=catalogSearchClasses path=/catalog/classes method=POST
   * @memberof CatalogApi
   */
  searchClasses(searchClassBody: SearchClassBody, pageNumber?: number, pageSize?: number, sort?: SortObject): Promise<PagedResults<CatalogClass>>;

  /**
   * Search all catalog schemas
   * @summary Search all catalog schemas
   * @param {SearchCatalogSchemaBody} searchCatalogSchemaBody 
   * @param {number} [pageNumber] The requested page. This value is 1-indexed.
   * @param {number} [pageSize] The number of items in each page of data.
   * @param {SortObject} [sort] 
   * @param {*} [options] Override http request option.
   * @throws {@link @zerobias-org/types-core-js#ParameterRequiredError} if any required parameter is not provided
   * @example
   * ```typescript
   * const result = await api.searchSchemas(null, 1, 1, null);
   * ```
   * @openapi operation=catalogSearchSchemas path=/catalog/schemas method=POST
   * @memberof CatalogApi
   */
  searchSchemas(searchCatalogSchemaBody: SearchCatalogSchemaBody, pageNumber?: number, pageSize?: number, sort?: SortObject): Promise<PagedResults<CatalogSchema>>;

  /**
   * Create a new catalog request
   * @summary Create a new catalog request
   * @param {CreateCatalogRequest} createCatalogRequest 
   * @param {*} [options] Override http request option.
   * @throws {@link @zerobias-org/types-core-js#ParameterRequiredError} if any required parameter is not provided
   * @example
   * ```typescript
   * const result = await api.createRequest(null);
   * ```
   * @openapi operation=createCatalogRequest path=/catalog/requests method=POST
   * @memberof CatalogApi
   */
  createRequest(createCatalogRequest: CreateCatalogRequest): Promise<CatalogRequestExtended>;

  /**
   * Create a comment on a catalog request
   * @summary Create a comment on a catalog request
   * @param {UUID} catalogRequestId 
   * @param {CreateCatalogRequestComment} createCatalogRequestComment 
   * @param {*} [options] Override http request option.
   * @throws {@link @zerobias-org/types-core-js#ParameterRequiredError} if any required parameter is not provided
   * @example
   * ```typescript
   * const result = await api.createRequestComment('00000000-0000-0000-0000-000000000000', null);
   * ```
   * @openapi operation=createCatalogRequestComment path=/catalog/requests/{catalogRequestId}/comments method=POST
   * @memberof CatalogApi
   */
  createRequestComment(catalogRequestId: UUID, createCatalogRequestComment: CreateCatalogRequestComment): Promise<CatalogRequestCommentExtended>;

  /**
   * Delete a comment on a catalog request
   * @summary Delete a comment on a catalog request
   * @param {UUID} catalogRequestId 
   * @param {UUID} commentId 
   * @param {*} [options] Override http request option.
   * @throws {@link @zerobias-org/types-core-js#ParameterRequiredError} if any required parameter is not provided
   * @example
   * ```typescript
   * const result = await api.deleteRequestComment('00000000-0000-0000-0000-000000000000', '00000000-0000-0000-0000-000000000000');
   * ```
   * @openapi operation=deleteCatalogRequestComment path=/catalog/requests/{catalogRequestId}/comments/{commentId} method=DELETE
   * @memberof CatalogApi
   */
  deleteRequestComment(catalogRequestId: UUID, commentId: UUID): Promise<void>;

  /**
   * Returns overview counts info for auditlogic catalog
   * @summary Returns overview counts info for auditlogic catalog
   * @param {*} [options] Override http request option.
   * @throws {@link @zerobias-org/types-core-js#ParameterRequiredError} if any required parameter is not provided
   * @openapi operation=getCatalogOverviewCounts path=/catalog/overviewCounts method=GET
   * @memberof CatalogApi
   */
  getOverviewCounts(): Promise<CatalogOverview>;

  /**
   * Returns overview skeleton info for auditlogic catalog
   * @summary Returns overview skeleton info for auditlogic catalog
   * @param {*} [options] Override http request option.
   * @throws {@link @zerobias-org/types-core-js#ParameterRequiredError} if any required parameter is not provided
   * @openapi operation=getCatalogOverviewSkeleton path=/catalog/overviewSkeleton method=GET
   * @memberof CatalogApi
   */
  getOverviewSkeleton(): Promise<CatalogOverview>;

  /**
   * Get a catalog request
   * @summary Get a catalog request
   * @param {UUID} catalogRequestId 
   * @param {*} [options] Override http request option.
   * @throws {@link @zerobias-org/types-core-js#ParameterRequiredError} if any required parameter is not provided
   * @example
   * ```typescript
   * const result = await api.getRequest('00000000-0000-0000-0000-000000000000');
   * ```
   * @openapi operation=getCatalogRequest path=/catalog/requests/{catalogRequestId} method=GET
   * @memberof CatalogApi
   */
  getRequest(catalogRequestId: UUID): Promise<CatalogRequestExtended>;

  /**
   * Returns overview info for auditlogic catalog
   * @summary Returns overview info for auditlogic catalog
   * @param {UUID} artifactOrVersionId 
   * @param {*} [options] Override http request option.
   * @throws {@link @zerobias-org/types-core-js#ParameterRequiredError} if any required parameter is not provided
   * @example
   * ```typescript
   * const result = await api.getSchema('00000000-0000-0000-0000-000000000000');
   * ```
   * @openapi operation=getCatalogSchema path=/catalog/schemas/{artifactOrVersionId} method=GET
   * @memberof CatalogApi
   */
  getSchema(artifactOrVersionId: UUID): Promise<CatalogSchema>;

  /**
   * List a catalog request's comments
   * @summary List a catalog request's comments
   * @param {UUID} catalogRequestId 
   * @param {number} [pageNumber] The requested page. This value is 1-indexed.
   * @param {number} [pageSize] The number of items in each page of data.
   * @param {*} [options] Override http request option.
   * @throws {@link @zerobias-org/types-core-js#ParameterRequiredError} if any required parameter is not provided
   * @example
   * ```typescript
   * const result = await api.listRequestComments('00000000-0000-0000-0000-000000000000', 1, 1);
   * ```
   * @openapi operation=listCatalogRequestComments path=/catalog/requests/{catalogRequestId}/comments method=GET
   * @memberof CatalogApi
   */
  listRequestComments(catalogRequestId: UUID, pageNumber?: number, pageSize?: number): Promise<PagedResults<CatalogRequestCommentExtended>>;

  /**
   * List catalog requests
   * @summary List catalog requests
   * @param {number} [pageNumber] The requested page. This value is 1-indexed.
   * @param {number} [pageSize] The number of items in each page of data.
   * @param {CatalogRequestArtifactType} [artifactType] 
   * @param {string} [search] 
   * @param {SortObject} [sort] 
   * @param {*} [options] Override http request option.
   * @throws {@link @zerobias-org/types-core-js#ParameterRequiredError} if any required parameter is not provided
   * @example
   * ```typescript
   * const result = await api.listRequests(1, 1, null, 'search', null);
   * ```
   * @openapi operation=listCatalogRequests path=/catalog/requests method=GET
   * @memberof CatalogApi
   */
  listRequests(pageNumber?: number, pageSize?: number, artifactType?: CatalogRequestArtifactTypeDef, search?: string, sort?: SortObject): Promise<PagedResults<CatalogRequestExtended>>;

  /**
   * Get column information for object search for a class
   * @summary Get column information for object search for a class
   * @param {UUID} classId 
   * @param {*} [options] Override http request option.
   * @throws {@link @zerobias-org/types-core-js#ParameterRequiredError} if any required parameter is not provided
   * @example
   * ```typescript
   * const result = await api.objectSearchByClassColumns('00000000-0000-0000-0000-000000000000');
   * ```
   * @openapi operation=objectSearchByClassColumns path=/catalog/objectSearch/{classId}/columns method=GET
   * @memberof CatalogApi
   */
  objectSearchByClassColumns(classId: UUID): Promise<ObjectSearchColumns>;

  /**
   * Search through objects within the catalog for a specific class
   * @summary Search through objects within the catalog for a specific class
   * @param {UUID} classId 
   * @param {ObjectSearchFilterForClass} objectSearchFilterForClass Filters to apply to the search.
   * @param {number} [pageNumber] The requested page. This value is 1-indexed.
   * @param {number} [pageSize] The number of items in each page of data.
   * @param {SortObject} [sort] Sort object
   * @param {*} [options] Override http request option.
   * @throws {@link @zerobias-org/types-core-js#ParameterRequiredError} if any required parameter is not provided
   * @example
   * ```typescript
   * const result = await api.objectSearchByClass('00000000-0000-0000-0000-000000000000', null, 1, 1, null);
   * ```
   * @openapi operation=objectSearchClass path=/catalog/objectSearch/{classId} method=POST
   * @memberof CatalogApi
   */
  objectSearchByClass(classId: UUID, objectSearchFilterForClass: ObjectSearchFilterForClass, pageNumber?: number, pageSize?: number, sort?: SortObject): Promise<PagedResults<ObjectSearchResultForClass>>;

  /**
   * 
   * @summary Search through objects within the catalog for a class and returns metadata about results that would be returned by objectSearch
   * @param {UUID} classId 
   * @param {ObjectSearchFilterForClass} objectSearchFilterForClass Filters to apply to the search.
   * @param {*} [options] Override http request option.
   * @throws {@link @zerobias-org/types-core-js#ParameterRequiredError} if any required parameter is not provided
   * @example
   * ```typescript
   * const result = await api.objectSearchMetadataByClass('00000000-0000-0000-0000-000000000000', null);
   * ```
   * @openapi operation=objectSearchMetadataByClass path=/catalog/objectSearchMetadata/{classId} method=POST
   * @memberof CatalogApi
   */
  objectSearchMetadataByClass(classId: UUID, objectSearchFilterForClass: ObjectSearchFilterForClass): Promise<ObjectSearchResultsMetadata>;

  /**
   * Remove a catalog request upvote
   * @summary Remove a catalog request upvote
   * @param {UUID} catalogRequestId 
   * @param {*} [options] Override http request option.
   * @throws {@link @zerobias-org/types-core-js#ParameterRequiredError} if any required parameter is not provided
   * @example
   * ```typescript
   * const result = await api.removeRequestUpvote('00000000-0000-0000-0000-000000000000');
   * ```
   * @openapi operation=removeCatalogRequestUpvote path=/catalog/requests/{catalogRequestId}/upvotes method=DELETE
   * @memberof CatalogApi
   */
  removeRequestUpvote(catalogRequestId: UUID): Promise<void>;

  /**
   * Search catalog requests
   * @summary Search catalog requests
   * @param {SearchRequestBody} searchRequestBody 
   * @param {number} [pageNumber] The requested page. This value is 1-indexed.
   * @param {number} [pageSize] The number of items in each page of data.
   * @param {SortObject} [sort] 
   * @param {*} [options] Override http request option.
   * @throws {@link @zerobias-org/types-core-js#ParameterRequiredError} if any required parameter is not provided
   * @example
   * ```typescript
   * const result = await api.searchRequests(null, 1, 1, null);
   * ```
   * @openapi operation=searchCatalogRequests path=/catalog/requestSearch method=POST
   * @memberof CatalogApi
   */
  searchRequests(searchRequestBody: SearchRequestBody, pageNumber?: number, pageSize?: number, sort?: SortObject): Promise<PagedResults<CatalogRequestExtended>>;

  /**
   * Returns options/filters for catalog requests
   * @summary Returns options/filters for catalog requests
   * @param {*} [options] Override http request option.
   * @throws {@link @zerobias-org/types-core-js#ParameterRequiredError} if any required parameter is not provided
   * @openapi operation=searchCatalogRequestsOptions path=/catalog/requestSearch/options method=GET
   * @memberof CatalogApi
   */
  searchRequestsOptions(): Promise<ResultsColumnOptionsWrapper>;

  /**
   * Update a comment on a catalog request
   * @summary Update a comment on a catalog request
   * @param {UUID} catalogRequestId 
   * @param {UUID} commentId 
   * @param {CreateCatalogRequestComment} createCatalogRequestComment 
   * @param {*} [options] Override http request option.
   * @throws {@link @zerobias-org/types-core-js#ParameterRequiredError} if any required parameter is not provided
   * @example
   * ```typescript
   * const result = await api.updateRequestComment('00000000-0000-0000-0000-000000000000', '00000000-0000-0000-0000-000000000000', null);
   * ```
   * @openapi operation=updateCatalogRequestComment path=/catalog/requests/{catalogRequestId}/comments/{commentId} method=PUT
   * @memberof CatalogApi
   */
  updateRequestComment(catalogRequestId: UUID, commentId: UUID, createCatalogRequestComment: CreateCatalogRequestComment): Promise<CatalogRequestCommentExtended>;

  /**
   * Upvote a catalog request
   * @summary Upvote a catalog request
   * @param {UUID} catalogRequestId 
   * @param {*} [options] Override http request option.
   * @throws {@link @zerobias-org/types-core-js#ParameterRequiredError} if any required parameter is not provided
   * @example
   * ```typescript
   * const result = await api.upvoteRequest('00000000-0000-0000-0000-000000000000');
   * ```
   * @openapi operation=upvoteCatalogRequest path=/catalog/requests/{catalogRequestId}/upvotes method=PUT
   * @memberof CatalogApi
   */
  upvoteRequest(catalogRequestId: UUID): Promise<void>;

}

/**
 * CatalogProducerApi - interface
 * Producer interface for Catalog
 * @export
 * @interface CatalogProducerApi
 */
export interface CatalogProducerApi {
  /**
  * Search all catalog classes
  * @summary Search all catalog classes
  * @param {SearchClassBody} searchClassBody 
  * @param {SortObject} [sort] 
  * @param {*} [options] Override http request option.
  * @throws {@link @zerobias-org/types-core-js#ParameterRequiredError} if any required parameter is not provided
  * @openapi operation=catalogSearchClasses path=/catalog/classes method=POST
  * @memberof Catalog
  */
  searchClasses(results: PagedResults<CatalogClass>, searchClassBody: SearchClassBody, sort?: SortObject): Promise<void>;
  /**
  * Search all catalog schemas
  * @summary Search all catalog schemas
  * @param {SearchCatalogSchemaBody} searchCatalogSchemaBody 
  * @param {SortObject} [sort] 
  * @param {*} [options] Override http request option.
  * @throws {@link @zerobias-org/types-core-js#ParameterRequiredError} if any required parameter is not provided
  * @openapi operation=catalogSearchSchemas path=/catalog/schemas method=POST
  * @memberof Catalog
  */
  searchSchemas(results: PagedResults<CatalogSchema>, searchCatalogSchemaBody: SearchCatalogSchemaBody, sort?: SortObject): Promise<void>;
  /**
  * Create a new catalog request
  * @summary Create a new catalog request
  * @param {CreateCatalogRequest} createCatalogRequest 
  * @param {*} [options] Override http request option.
  * @throws {@link @zerobias-org/types-core-js#ParameterRequiredError} if any required parameter is not provided
  * @openapi operation=createCatalogRequest path=/catalog/requests method=POST
  * @memberof Catalog
  */
  createRequest(createCatalogRequest: CreateCatalogRequest): Promise<CatalogRequestExtended>;
  /**
  * Create a comment on a catalog request
  * @summary Create a comment on a catalog request
  * @param {UUID} catalogRequestId 
  * @param {CreateCatalogRequestComment} createCatalogRequestComment 
  * @param {*} [options] Override http request option.
  * @throws {@link @zerobias-org/types-core-js#ParameterRequiredError} if any required parameter is not provided
  * @openapi operation=createCatalogRequestComment path=/catalog/requests/{catalogRequestId}/comments method=POST
  * @memberof Catalog
  */
  createRequestComment(catalogRequestId: UUID, createCatalogRequestComment: CreateCatalogRequestComment): Promise<CatalogRequestCommentExtended>;
  /**
  * Delete a comment on a catalog request
  * @summary Delete a comment on a catalog request
  * @param {UUID} catalogRequestId 
  * @param {UUID} commentId 
  * @param {*} [options] Override http request option.
  * @throws {@link @zerobias-org/types-core-js#ParameterRequiredError} if any required parameter is not provided
  * @openapi operation=deleteCatalogRequestComment path=/catalog/requests/{catalogRequestId}/comments/{commentId} method=DELETE
  * @memberof Catalog
  */
  deleteRequestComment(catalogRequestId: UUID, commentId: UUID): Promise<void>;
  /**
  * Returns overview counts info for auditlogic catalog
  * @summary Returns overview counts info for auditlogic catalog
  * @param {*} [options] Override http request option.
  * @throws {@link @zerobias-org/types-core-js#ParameterRequiredError} if any required parameter is not provided
  * @openapi operation=getCatalogOverviewCounts path=/catalog/overviewCounts method=GET
  * @memberof Catalog
  */
  getOverviewCounts(): Promise<CatalogOverview>;
  /**
  * Returns overview skeleton info for auditlogic catalog
  * @summary Returns overview skeleton info for auditlogic catalog
  * @param {*} [options] Override http request option.
  * @throws {@link @zerobias-org/types-core-js#ParameterRequiredError} if any required parameter is not provided
  * @openapi operation=getCatalogOverviewSkeleton path=/catalog/overviewSkeleton method=GET
  * @memberof Catalog
  */
  getOverviewSkeleton(): Promise<CatalogOverview>;
  /**
  * Get a catalog request
  * @summary Get a catalog request
  * @param {UUID} catalogRequestId 
  * @param {*} [options] Override http request option.
  * @throws {@link @zerobias-org/types-core-js#ParameterRequiredError} if any required parameter is not provided
  * @openapi operation=getCatalogRequest path=/catalog/requests/{catalogRequestId} method=GET
  * @memberof Catalog
  */
  getRequest(catalogRequestId: UUID): Promise<CatalogRequestExtended>;
  /**
  * Returns overview info for auditlogic catalog
  * @summary Returns overview info for auditlogic catalog
  * @param {UUID} artifactOrVersionId 
  * @param {*} [options] Override http request option.
  * @throws {@link @zerobias-org/types-core-js#ParameterRequiredError} if any required parameter is not provided
  * @openapi operation=getCatalogSchema path=/catalog/schemas/{artifactOrVersionId} method=GET
  * @memberof Catalog
  */
  getSchema(artifactOrVersionId: UUID): Promise<CatalogSchema>;
  /**
  * List a catalog request's comments
  * @summary List a catalog request's comments
  * @param {UUID} catalogRequestId 
  * @param {*} [options] Override http request option.
  * @throws {@link @zerobias-org/types-core-js#ParameterRequiredError} if any required parameter is not provided
  * @openapi operation=listCatalogRequestComments path=/catalog/requests/{catalogRequestId}/comments method=GET
  * @memberof Catalog
  */
  listRequestComments(results: PagedResults<CatalogRequestCommentExtended>, catalogRequestId: UUID): Promise<void>;
  /**
  * List catalog requests
  * @summary List catalog requests
  * @param {CatalogRequestArtifactType} [artifactType] 
  * @param {string} [search] 
  * @param {SortObject} [sort] 
  * @param {*} [options] Override http request option.
  * @throws {@link @zerobias-org/types-core-js#ParameterRequiredError} if any required parameter is not provided
  * @openapi operation=listCatalogRequests path=/catalog/requests method=GET
  * @memberof Catalog
  */
  listRequests(results: PagedResults<CatalogRequestExtended>, artifactType?: CatalogRequestArtifactTypeDef, search?: string, sort?: SortObject): Promise<void>;
  /**
  * Get column information for object search for a class
  * @summary Get column information for object search for a class
  * @param {UUID} classId 
  * @param {*} [options] Override http request option.
  * @throws {@link @zerobias-org/types-core-js#ParameterRequiredError} if any required parameter is not provided
  * @openapi operation=objectSearchByClassColumns path=/catalog/objectSearch/{classId}/columns method=GET
  * @memberof Catalog
  */
  objectSearchByClassColumns(classId: UUID): Promise<ObjectSearchColumns>;
  /**
  * Search through objects within the catalog for a specific class
  * @summary Search through objects within the catalog for a specific class
  * @param {UUID} classId 
  * @param {ObjectSearchFilterForClass} objectSearchFilterForClass Filters to apply to the search.
  * @param {SortObject} [sort] Sort object
  * @param {*} [options] Override http request option.
  * @throws {@link @zerobias-org/types-core-js#ParameterRequiredError} if any required parameter is not provided
  * @openapi operation=objectSearchClass path=/catalog/objectSearch/{classId} method=POST
  * @memberof Catalog
  */
  objectSearchByClass(results: PagedResults<ObjectSearchResultForClass>, classId: UUID, objectSearchFilterForClass: ObjectSearchFilterForClass, sort?: SortObject): Promise<void>;
  /**
  * 
  * @summary Search through objects within the catalog for a class and returns metadata about results that would be returned by objectSearch
  * @param {UUID} classId 
  * @param {ObjectSearchFilterForClass} objectSearchFilterForClass Filters to apply to the search.
  * @param {*} [options] Override http request option.
  * @throws {@link @zerobias-org/types-core-js#ParameterRequiredError} if any required parameter is not provided
  * @openapi operation=objectSearchMetadataByClass path=/catalog/objectSearchMetadata/{classId} method=POST
  * @memberof Catalog
  */
  objectSearchMetadataByClass(classId: UUID, objectSearchFilterForClass: ObjectSearchFilterForClass): Promise<ObjectSearchResultsMetadata>;
  /**
  * Remove a catalog request upvote
  * @summary Remove a catalog request upvote
  * @param {UUID} catalogRequestId 
  * @param {*} [options] Override http request option.
  * @throws {@link @zerobias-org/types-core-js#ParameterRequiredError} if any required parameter is not provided
  * @openapi operation=removeCatalogRequestUpvote path=/catalog/requests/{catalogRequestId}/upvotes method=DELETE
  * @memberof Catalog
  */
  removeRequestUpvote(catalogRequestId: UUID): Promise<void>;
  /**
  * Search catalog requests
  * @summary Search catalog requests
  * @param {SearchRequestBody} searchRequestBody 
  * @param {SortObject} [sort] 
  * @param {*} [options] Override http request option.
  * @throws {@link @zerobias-org/types-core-js#ParameterRequiredError} if any required parameter is not provided
  * @openapi operation=searchCatalogRequests path=/catalog/requestSearch method=POST
  * @memberof Catalog
  */
  searchRequests(results: PagedResults<CatalogRequestExtended>, searchRequestBody: SearchRequestBody, sort?: SortObject): Promise<void>;
  /**
  * Returns options/filters for catalog requests
  * @summary Returns options/filters for catalog requests
  * @param {*} [options] Override http request option.
  * @throws {@link @zerobias-org/types-core-js#ParameterRequiredError} if any required parameter is not provided
  * @openapi operation=searchCatalogRequestsOptions path=/catalog/requestSearch/options method=GET
  * @memberof Catalog
  */
  searchRequestsOptions(): Promise<ResultsColumnOptionsWrapper>;
  /**
  * Update a comment on a catalog request
  * @summary Update a comment on a catalog request
  * @param {UUID} catalogRequestId 
  * @param {UUID} commentId 
  * @param {CreateCatalogRequestComment} createCatalogRequestComment 
  * @param {*} [options] Override http request option.
  * @throws {@link @zerobias-org/types-core-js#ParameterRequiredError} if any required parameter is not provided
  * @openapi operation=updateCatalogRequestComment path=/catalog/requests/{catalogRequestId}/comments/{commentId} method=PUT
  * @memberof Catalog
  */
  updateRequestComment(catalogRequestId: UUID, commentId: UUID, createCatalogRequestComment: CreateCatalogRequestComment): Promise<CatalogRequestCommentExtended>;
  /**
  * Upvote a catalog request
  * @summary Upvote a catalog request
  * @param {UUID} catalogRequestId 
  * @param {*} [options] Override http request option.
  * @throws {@link @zerobias-org/types-core-js#ParameterRequiredError} if any required parameter is not provided
  * @openapi operation=upvoteCatalogRequest path=/catalog/requests/{catalogRequestId}/upvotes method=PUT
  * @memberof Catalog
  */
  upvoteRequest(catalogRequestId: UUID): Promise<void>;
}

export class CatalogApiMappingImpl implements CatalogApi {
  private producer: CatalogProducerApi;
  constructor(producer: CatalogProducerApi) {
    this.producer = producer;
  }

  /**
   * Search all catalog classes
   * @summary Search all catalog classes
   * @param searchClassBody 
   * @param pageNumber The requested page. This value is 1-indexed.
   * @param pageSize The number of items in each page of data.
   * @param sort 
   * @openapi operation=catalogSearchClasses path=/catalog/classes method=POST
   */
  public async searchClasses(searchClassBody: SearchClassBody, pageNumber: number = 1, pageSize: number = 50, sort?: SortObject): Promise<PagedResults<CatalogClass>> {
    // verify required parameter 'searchClassBody' is not null or undefined
    if (searchClassBody === null || searchClassBody === undefined) {
      throw new ParameterRequiredError('searchClassBody');
    }
    if (pageNumber) {
      await Int32.parse(pageNumber);
    }
    if (pageSize) {
      await Int32.parse(pageSize);
    }
    const bag = new PagedResults<CatalogClass>();
    bag.pageNumber = pageNumber;
    bag.pageSize = pageSize;
    await this.producer.searchClasses(bag, searchClassBody, sort);
    if (bag.items === null || bag.items === undefined) {
      throw new UnexpectedError("Producers must return 'items' for PagedResults queries");
    }
    return bag;
  }
  /**
   * Search all catalog schemas
   * @summary Search all catalog schemas
   * @param searchCatalogSchemaBody 
   * @param pageNumber The requested page. This value is 1-indexed.
   * @param pageSize The number of items in each page of data.
   * @param sort 
   * @openapi operation=catalogSearchSchemas path=/catalog/schemas method=POST
   */
  public async searchSchemas(searchCatalogSchemaBody: SearchCatalogSchemaBody, pageNumber: number = 1, pageSize: number = 50, sort?: SortObject): Promise<PagedResults<CatalogSchema>> {
    // verify required parameter 'searchCatalogSchemaBody' is not null or undefined
    if (searchCatalogSchemaBody === null || searchCatalogSchemaBody === undefined) {
      throw new ParameterRequiredError('searchCatalogSchemaBody');
    }
    if (pageNumber) {
      await Int32.parse(pageNumber);
    }
    if (pageSize) {
      await Int32.parse(pageSize);
    }
    const bag = new PagedResults<CatalogSchema>();
    bag.pageNumber = pageNumber;
    bag.pageSize = pageSize;
    await this.producer.searchSchemas(bag, searchCatalogSchemaBody, sort);
    if (bag.items === null || bag.items === undefined) {
      throw new UnexpectedError("Producers must return 'items' for PagedResults queries");
    }
    return bag;
  }
  /**
   * Create a new catalog request
   * @summary Create a new catalog request
   * @param createCatalogRequest 
   * @openapi operation=createCatalogRequest path=/catalog/requests method=POST
   */
  public async createRequest(createCatalogRequest: CreateCatalogRequest): Promise<CatalogRequestExtended> {
    // verify required parameter 'createCatalogRequest' is not null or undefined
    if (createCatalogRequest === null || createCatalogRequest === undefined) {
      throw new ParameterRequiredError('createCatalogRequest');
    }
    return this.producer.createRequest(createCatalogRequest);
  }
  /**
   * Create a comment on a catalog request
   * @summary Create a comment on a catalog request
   * @param catalogRequestId 
   * @param createCatalogRequestComment 
   * @openapi operation=createCatalogRequestComment path=/catalog/requests/{catalogRequestId}/comments method=POST
   */
  public async createRequestComment(catalogRequestId: UUID, createCatalogRequestComment: CreateCatalogRequestComment): Promise<CatalogRequestCommentExtended> {
    // verify required parameter 'catalogRequestId' is not null or undefined
    if (catalogRequestId === null || catalogRequestId === undefined) {
      throw new ParameterRequiredError('catalogRequestId');
    }
    // verify required parameter 'createCatalogRequestComment' is not null or undefined
    if (createCatalogRequestComment === null || createCatalogRequestComment === undefined) {
      throw new ParameterRequiredError('createCatalogRequestComment');
    }
    return this.producer.createRequestComment(catalogRequestId, createCatalogRequestComment);
  }
  /**
   * Delete a comment on a catalog request
   * @summary Delete a comment on a catalog request
   * @param catalogRequestId 
   * @param commentId 
   * @openapi operation=deleteCatalogRequestComment path=/catalog/requests/{catalogRequestId}/comments/{commentId} method=DELETE
   */
  public async deleteRequestComment(catalogRequestId: UUID, commentId: UUID): Promise<void> {
    // verify required parameter 'catalogRequestId' is not null or undefined
    if (catalogRequestId === null || catalogRequestId === undefined) {
      throw new ParameterRequiredError('catalogRequestId');
    }
    // verify required parameter 'commentId' is not null or undefined
    if (commentId === null || commentId === undefined) {
      throw new ParameterRequiredError('commentId');
    }
    return this.producer.deleteRequestComment(catalogRequestId, commentId);
  }
  /**
   * Returns overview counts info for auditlogic catalog
   * @summary Returns overview counts info for auditlogic catalog
   * @openapi operation=getCatalogOverviewCounts path=/catalog/overviewCounts method=GET
   */
  public async getOverviewCounts(): Promise<CatalogOverview> {
    return this.producer.getOverviewCounts();
  }
  /**
   * Returns overview skeleton info for auditlogic catalog
   * @summary Returns overview skeleton info for auditlogic catalog
   * @openapi operation=getCatalogOverviewSkeleton path=/catalog/overviewSkeleton method=GET
   */
  public async getOverviewSkeleton(): Promise<CatalogOverview> {
    return this.producer.getOverviewSkeleton();
  }
  /**
   * Get a catalog request
   * @summary Get a catalog request
   * @param catalogRequestId 
   * @openapi operation=getCatalogRequest path=/catalog/requests/{catalogRequestId} method=GET
   */
  public async getRequest(catalogRequestId: UUID): Promise<CatalogRequestExtended> {
    // verify required parameter 'catalogRequestId' is not null or undefined
    if (catalogRequestId === null || catalogRequestId === undefined) {
      throw new ParameterRequiredError('catalogRequestId');
    }
    return this.producer.getRequest(catalogRequestId);
  }
  /**
   * Returns overview info for auditlogic catalog
   * @summary Returns overview info for auditlogic catalog
   * @param artifactOrVersionId 
   * @openapi operation=getCatalogSchema path=/catalog/schemas/{artifactOrVersionId} method=GET
   */
  public async getSchema(artifactOrVersionId: UUID): Promise<CatalogSchema> {
    // verify required parameter 'artifactOrVersionId' is not null or undefined
    if (artifactOrVersionId === null || artifactOrVersionId === undefined) {
      throw new ParameterRequiredError('artifactOrVersionId');
    }
    return this.producer.getSchema(artifactOrVersionId);
  }
  /**
   * List a catalog request's comments
   * @summary List a catalog request's comments
   * @param catalogRequestId 
   * @param pageNumber The requested page. This value is 1-indexed.
   * @param pageSize The number of items in each page of data.
   * @openapi operation=listCatalogRequestComments path=/catalog/requests/{catalogRequestId}/comments method=GET
   */
  public async listRequestComments(catalogRequestId: UUID, pageNumber: number = 1, pageSize: number = 50): Promise<PagedResults<CatalogRequestCommentExtended>> {
    // verify required parameter 'catalogRequestId' is not null or undefined
    if (catalogRequestId === null || catalogRequestId === undefined) {
      throw new ParameterRequiredError('catalogRequestId');
    }
    if (pageNumber) {
      await Int32.parse(pageNumber);
    }
    if (pageSize) {
      await Int32.parse(pageSize);
    }
    const bag = new PagedResults<CatalogRequestCommentExtended>();
    bag.pageNumber = pageNumber;
    bag.pageSize = pageSize;
    await this.producer.listRequestComments(bag, catalogRequestId);
    if (bag.items === null || bag.items === undefined) {
      throw new UnexpectedError("Producers must return 'items' for PagedResults queries");
    }
    return bag;
  }
  /**
   * List catalog requests
   * @summary List catalog requests
   * @param pageNumber The requested page. This value is 1-indexed.
   * @param pageSize The number of items in each page of data.
   * @param artifactType 
   * @param search 
   * @param sort 
   * @openapi operation=listCatalogRequests path=/catalog/requests method=GET
   */
  public async listRequests(pageNumber: number = 1, pageSize: number = 50, artifactType?: CatalogRequestArtifactTypeDef, search?: string, sort?: SortObject): Promise<PagedResults<CatalogRequestExtended>> {
    if (pageNumber) {
      await Int32.parse(pageNumber);
    }
    if (pageSize) {
      await Int32.parse(pageSize);
    }
    const bag = new PagedResults<CatalogRequestExtended>();
    bag.pageNumber = pageNumber;
    bag.pageSize = pageSize;
    await this.producer.listRequests(bag, artifactType, search, sort);
    if (bag.items === null || bag.items === undefined) {
      throw new UnexpectedError("Producers must return 'items' for PagedResults queries");
    }
    return bag;
  }
  /**
   * Get column information for object search for a class
   * @summary Get column information for object search for a class
   * @param classId 
   * @openapi operation=objectSearchByClassColumns path=/catalog/objectSearch/{classId}/columns method=GET
   */
  public async objectSearchByClassColumns(classId: UUID): Promise<ObjectSearchColumns> {
    // verify required parameter 'classId' is not null or undefined
    if (classId === null || classId === undefined) {
      throw new ParameterRequiredError('classId');
    }
    return this.producer.objectSearchByClassColumns(classId);
  }
  /**
   * Search through objects within the catalog for a specific class
   * @summary Search through objects within the catalog for a specific class
   * @param classId 
   * @param objectSearchFilterForClass Filters to apply to the search.
   * @param pageNumber The requested page. This value is 1-indexed.
   * @param pageSize The number of items in each page of data.
   * @param sort Sort object
   * @openapi operation=objectSearchClass path=/catalog/objectSearch/{classId} method=POST
   */
  public async objectSearchByClass(classId: UUID, objectSearchFilterForClass: ObjectSearchFilterForClass, pageNumber: number = 1, pageSize: number = 50, sort?: SortObject): Promise<PagedResults<ObjectSearchResultForClass>> {
    // verify required parameter 'classId' is not null or undefined
    if (classId === null || classId === undefined) {
      throw new ParameterRequiredError('classId');
    }
    // verify required parameter 'objectSearchFilterForClass' is not null or undefined
    if (objectSearchFilterForClass === null || objectSearchFilterForClass === undefined) {
      throw new ParameterRequiredError('objectSearchFilterForClass');
    }
    if (pageNumber) {
      await Int32.parse(pageNumber);
    }
    if (pageSize) {
      await Int32.parse(pageSize);
    }
    const bag = new PagedResults<ObjectSearchResultForClass>();
    bag.pageNumber = pageNumber;
    bag.pageSize = pageSize;
    await this.producer.objectSearchByClass(bag, classId, objectSearchFilterForClass, sort);
    if (bag.items === null || bag.items === undefined) {
      throw new UnexpectedError("Producers must return 'items' for PagedResults queries");
    }
    return bag;
  }
  /**
   * 
   * @summary Search through objects within the catalog for a class and returns metadata about results that would be returned by objectSearch
   * @param classId 
   * @param objectSearchFilterForClass Filters to apply to the search.
   * @openapi operation=objectSearchMetadataByClass path=/catalog/objectSearchMetadata/{classId} method=POST
   */
  public async objectSearchMetadataByClass(classId: UUID, objectSearchFilterForClass: ObjectSearchFilterForClass): Promise<ObjectSearchResultsMetadata> {
    // verify required parameter 'classId' is not null or undefined
    if (classId === null || classId === undefined) {
      throw new ParameterRequiredError('classId');
    }
    // verify required parameter 'objectSearchFilterForClass' is not null or undefined
    if (objectSearchFilterForClass === null || objectSearchFilterForClass === undefined) {
      throw new ParameterRequiredError('objectSearchFilterForClass');
    }
    return this.producer.objectSearchMetadataByClass(classId, objectSearchFilterForClass);
  }
  /**
   * Remove a catalog request upvote
   * @summary Remove a catalog request upvote
   * @param catalogRequestId 
   * @openapi operation=removeCatalogRequestUpvote path=/catalog/requests/{catalogRequestId}/upvotes method=DELETE
   */
  public async removeRequestUpvote(catalogRequestId: UUID): Promise<void> {
    // verify required parameter 'catalogRequestId' is not null or undefined
    if (catalogRequestId === null || catalogRequestId === undefined) {
      throw new ParameterRequiredError('catalogRequestId');
    }
    return this.producer.removeRequestUpvote(catalogRequestId);
  }
  /**
   * Search catalog requests
   * @summary Search catalog requests
   * @param searchRequestBody 
   * @param pageNumber The requested page. This value is 1-indexed.
   * @param pageSize The number of items in each page of data.
   * @param sort 
   * @openapi operation=searchCatalogRequests path=/catalog/requestSearch method=POST
   */
  public async searchRequests(searchRequestBody: SearchRequestBody, pageNumber: number = 1, pageSize: number = 50, sort?: SortObject): Promise<PagedResults<CatalogRequestExtended>> {
    // verify required parameter 'searchRequestBody' is not null or undefined
    if (searchRequestBody === null || searchRequestBody === undefined) {
      throw new ParameterRequiredError('searchRequestBody');
    }
    if (pageNumber) {
      await Int32.parse(pageNumber);
    }
    if (pageSize) {
      await Int32.parse(pageSize);
    }
    const bag = new PagedResults<CatalogRequestExtended>();
    bag.pageNumber = pageNumber;
    bag.pageSize = pageSize;
    await this.producer.searchRequests(bag, searchRequestBody, sort);
    if (bag.items === null || bag.items === undefined) {
      throw new UnexpectedError("Producers must return 'items' for PagedResults queries");
    }
    return bag;
  }
  /**
   * Returns options/filters for catalog requests
   * @summary Returns options/filters for catalog requests
   * @openapi operation=searchCatalogRequestsOptions path=/catalog/requestSearch/options method=GET
   */
  public async searchRequestsOptions(): Promise<ResultsColumnOptionsWrapper> {
    return this.producer.searchRequestsOptions();
  }
  /**
   * Update a comment on a catalog request
   * @summary Update a comment on a catalog request
   * @param catalogRequestId 
   * @param commentId 
   * @param createCatalogRequestComment 
   * @openapi operation=updateCatalogRequestComment path=/catalog/requests/{catalogRequestId}/comments/{commentId} method=PUT
   */
  public async updateRequestComment(catalogRequestId: UUID, commentId: UUID, createCatalogRequestComment: CreateCatalogRequestComment): Promise<CatalogRequestCommentExtended> {
    // verify required parameter 'catalogRequestId' is not null or undefined
    if (catalogRequestId === null || catalogRequestId === undefined) {
      throw new ParameterRequiredError('catalogRequestId');
    }
    // verify required parameter 'commentId' is not null or undefined
    if (commentId === null || commentId === undefined) {
      throw new ParameterRequiredError('commentId');
    }
    // verify required parameter 'createCatalogRequestComment' is not null or undefined
    if (createCatalogRequestComment === null || createCatalogRequestComment === undefined) {
      throw new ParameterRequiredError('createCatalogRequestComment');
    }
    return this.producer.updateRequestComment(catalogRequestId, commentId, createCatalogRequestComment);
  }
  /**
   * Upvote a catalog request
   * @summary Upvote a catalog request
   * @param catalogRequestId 
   * @openapi operation=upvoteCatalogRequest path=/catalog/requests/{catalogRequestId}/upvotes method=PUT
   */
  public async upvoteRequest(catalogRequestId: UUID): Promise<void> {
    // verify required parameter 'catalogRequestId' is not null or undefined
    if (catalogRequestId === null || catalogRequestId === undefined) {
      throw new ParameterRequiredError('catalogRequestId');
    }
    return this.producer.upvoteRequest(catalogRequestId);
  }
}

/**
 * Wrap producer with mapping implementation
 */
export function wrapCatalogProducer(producer: CatalogProducerApi): CatalogApi {
  return new CatalogApiMappingImpl(producer);
}

/**
 * CatalogApiHttpImpl - Direct HTTP implementation
 *
 * Makes direct HTTP calls to the API using Axios.
 * Used by SDK clients for platform service access.
 */
export class CatalogApiHttpImpl implements CatalogProducerApi {
  private client: AxiosInstance;
  private headers: Record<string, string>;

  constructor(client: AxiosInstance, headers: Record<string, string> = {}) {
    this.client = client;
    this.headers = headers;
  }

  async searchClasses(results: PagedResults<CatalogClass>, searchClassBody: SearchClassBody, sort?: SortObject): Promise<void> {
  const _body = {
      searchClassBody,sort,
  };
  let _path = '/catalog/classes';
  return this.client.post(
    _path,
    {
      ..._body,
      pageNumber: results.pageNumber,
      pageSize: results.pageSize,
    })
    .then((response) => {
      // BaseApiClient uses validateStatus: () => true, so we must check status manually
      if (response.status >= 400) {
        throw CoreError.deserialize(response.data);
      }
      results.items = ObjectSerializer.deserialize(response.data, 'Array<CatalogClass>');
      results.count = response.headers.count ? Number(response.headers.count) : -1;
      results.pageToken = response.headers.pagetoken ?? response.headers.pageToken;
      results.headers = this.headers;
      results.baseUrl = new URL(`${this.client.getUri()}/catalog/classes`);
      results.httpMethod = HttpMethod.Post;
      results.body = _body;
      results.mapper = (obj) => ObjectSerializer.deserialize(obj, 'CatalogClass');
    })
    .catch((error) => {
      if (error.data) {
        throw CoreError.deserialize(error.data);
      } else {
        throw error;
      }
    });
  }
  async searchSchemas(results: PagedResults<CatalogSchema>, searchCatalogSchemaBody: SearchCatalogSchemaBody, sort?: SortObject): Promise<void> {
  const _body = {
      searchCatalogSchemaBody,sort,
  };
  let _path = '/catalog/schemas';
  return this.client.post(
    _path,
    {
      ..._body,
      pageNumber: results.pageNumber,
      pageSize: results.pageSize,
    })
    .then((response) => {
      // BaseApiClient uses validateStatus: () => true, so we must check status manually
      if (response.status >= 400) {
        throw CoreError.deserialize(response.data);
      }
      results.items = ObjectSerializer.deserialize(response.data, 'Array<CatalogSchema>');
      results.count = response.headers.count ? Number(response.headers.count) : -1;
      results.pageToken = response.headers.pagetoken ?? response.headers.pageToken;
      results.headers = this.headers;
      results.baseUrl = new URL(`${this.client.getUri()}/catalog/schemas`);
      results.httpMethod = HttpMethod.Post;
      results.body = _body;
      results.mapper = (obj) => ObjectSerializer.deserialize(obj, 'CatalogSchema');
    })
    .catch((error) => {
      if (error.data) {
        throw CoreError.deserialize(error.data);
      } else {
        throw error;
      }
    });
  }
  async createRequest(createCatalogRequest: CreateCatalogRequest): Promise<CatalogRequestExtended> {
  const _queryParams = {
      
  };
  const _bodyParams = {
      ...createCatalogRequest,
  };
  let _path = '/catalog/requests';
  return this.client.post(
    _path,
    _bodyParams)
    .then((response) => {
      // BaseApiClient uses validateStatus: () => true, so we must check status manually
      if (response.status >= 400) {
        throw CoreError.deserialize(response.data);
      }
      return ObjectSerializer.deserialize(response.data, 'CatalogRequestExtended')
    })
    .catch((error) => {
      if (error.data) {
        throw CoreError.deserialize(error.data);
      } else {
        throw error;
      }
    });
  }
  async createRequestComment(catalogRequestId: UUID, createCatalogRequestComment: CreateCatalogRequestComment): Promise<CatalogRequestCommentExtended> {
  const _queryParams = {
      
  };
  const _bodyParams = {
      createCatalogRequestComment,
  };
  let _path = '/catalog/requests/{catalogRequestId}/comments';
  _path = _path.replace('{catalogRequestId}', encodeURIComponent(String(catalogRequestId)));
  return this.client.post(
    _path,
    _bodyParams)
    .then((response) => {
      // BaseApiClient uses validateStatus: () => true, so we must check status manually
      if (response.status >= 400) {
        throw CoreError.deserialize(response.data);
      }
      return ObjectSerializer.deserialize(response.data, 'CatalogRequestCommentExtended')
    })
    .catch((error) => {
      if (error.data) {
        throw CoreError.deserialize(error.data);
      } else {
        throw error;
      }
    });
  }
  async deleteRequestComment(catalogRequestId: UUID, commentId: UUID): Promise<void> {
  const _queryParams = {
      
  };
  const _bodyParams = {
      
  };
  let _path = '/catalog/requests/{catalogRequestId}/comments/{commentId}';
  _path = _path.replace('{catalogRequestId}', encodeURIComponent(String(catalogRequestId)));
  _path = _path.replace('{commentId}', encodeURIComponent(String(commentId)));
  return this.client.delete(
    _path,
    { params: _queryParams })
    .then((response) => {
      // BaseApiClient uses validateStatus: () => true, so we must check status manually
      if (response.status >= 400) {
        throw CoreError.deserialize(response.data);
      }
      return ObjectSerializer.deserialize(response.data, '')
    })
    .catch((error) => {
      if (error.data) {
        throw CoreError.deserialize(error.data);
      } else {
        throw error;
      }
    });
  }
  async getOverviewCounts(): Promise<CatalogOverview> {
  const _queryParams = {
      
  };
  const _bodyParams = {
      
  };
  let _path = '/catalog/overviewCounts';
  return this.client.get(
    _path,
    { params: _queryParams })
    .then((response) => {
      // BaseApiClient uses validateStatus: () => true, so we must check status manually
      if (response.status >= 400) {
        throw CoreError.deserialize(response.data);
      }
      return ObjectSerializer.deserialize(response.data, 'CatalogOverview')
    })
    .catch((error) => {
      if (error.data) {
        throw CoreError.deserialize(error.data);
      } else {
        throw error;
      }
    });
  }
  async getOverviewSkeleton(): Promise<CatalogOverview> {
  const _queryParams = {
      
  };
  const _bodyParams = {
      
  };
  let _path = '/catalog/overviewSkeleton';
  return this.client.get(
    _path,
    { params: _queryParams })
    .then((response) => {
      // BaseApiClient uses validateStatus: () => true, so we must check status manually
      if (response.status >= 400) {
        throw CoreError.deserialize(response.data);
      }
      return ObjectSerializer.deserialize(response.data, 'CatalogOverview')
    })
    .catch((error) => {
      if (error.data) {
        throw CoreError.deserialize(error.data);
      } else {
        throw error;
      }
    });
  }
  async getRequest(catalogRequestId: UUID): Promise<CatalogRequestExtended> {
  const _queryParams = {
      
  };
  const _bodyParams = {
      
  };
  let _path = '/catalog/requests/{catalogRequestId}';
  _path = _path.replace('{catalogRequestId}', encodeURIComponent(String(catalogRequestId)));
  return this.client.get(
    _path,
    { params: _queryParams })
    .then((response) => {
      // BaseApiClient uses validateStatus: () => true, so we must check status manually
      if (response.status >= 400) {
        throw CoreError.deserialize(response.data);
      }
      return ObjectSerializer.deserialize(response.data, 'CatalogRequestExtended')
    })
    .catch((error) => {
      if (error.data) {
        throw CoreError.deserialize(error.data);
      } else {
        throw error;
      }
    });
  }
  async getSchema(artifactOrVersionId: UUID): Promise<CatalogSchema> {
  const _queryParams = {
      
  };
  const _bodyParams = {
      
  };
  let _path = '/catalog/schemas/{artifactOrVersionId}';
  _path = _path.replace('{artifactOrVersionId}', encodeURIComponent(String(artifactOrVersionId)));
  return this.client.get(
    _path,
    { params: _queryParams })
    .then((response) => {
      // BaseApiClient uses validateStatus: () => true, so we must check status manually
      if (response.status >= 400) {
        throw CoreError.deserialize(response.data);
      }
      return ObjectSerializer.deserialize(response.data, 'CatalogSchema')
    })
    .catch((error) => {
      if (error.data) {
        throw CoreError.deserialize(error.data);
      } else {
        throw error;
      }
    });
  }
  async listRequestComments(results: PagedResults<CatalogRequestCommentExtended>, catalogRequestId: UUID): Promise<void> {
  const _body = {
      catalogRequestId,
  };
  let _path = '/catalog/requests/{catalogRequestId}/comments';
  _path = _path.replace('{catalogRequestId}', encodeURIComponent(String(catalogRequestId)));
  return this.client.get(
    _path,
    {
      params: {
        ..._body,
        pageNumber: results.pageNumber,
        pageSize: results.pageSize,
      }
    })
    .then((response) => {
      // BaseApiClient uses validateStatus: () => true, so we must check status manually
      if (response.status >= 400) {
        throw CoreError.deserialize(response.data);
      }
      results.items = ObjectSerializer.deserialize(response.data, 'Array<CatalogRequestCommentExtended>');
      results.count = response.headers.count ? Number(response.headers.count) : -1;
      results.pageToken = response.headers.pagetoken ?? response.headers.pageToken;
      results.headers = this.headers;
      results.baseUrl = new URL(`${this.client.getUri()}/catalog/requests/{catalogRequestId}/comments`);
      results.httpMethod = HttpMethod.Get;
      results.body = _body;
      results.mapper = (obj) => ObjectSerializer.deserialize(obj, 'CatalogRequestCommentExtended');
    })
    .catch((error) => {
      if (error.data) {
        throw CoreError.deserialize(error.data);
      } else {
        throw error;
      }
    });
  }
  async listRequests(results: PagedResults<CatalogRequestExtended>, artifactType?: CatalogRequestArtifactTypeDef, search?: string, sort?: SortObject): Promise<void> {
  const _body = {
      artifactType,search,sort,
  };
  let _path = '/catalog/requests';
  return this.client.get(
    _path,
    {
      params: {
        ..._body,
        pageNumber: results.pageNumber,
        pageSize: results.pageSize,
      }
    })
    .then((response) => {
      // BaseApiClient uses validateStatus: () => true, so we must check status manually
      if (response.status >= 400) {
        throw CoreError.deserialize(response.data);
      }
      results.items = ObjectSerializer.deserialize(response.data, 'Array<CatalogRequestExtended>');
      results.count = response.headers.count ? Number(response.headers.count) : -1;
      results.pageToken = response.headers.pagetoken ?? response.headers.pageToken;
      results.headers = this.headers;
      results.baseUrl = new URL(`${this.client.getUri()}/catalog/requests`);
      results.httpMethod = HttpMethod.Get;
      results.body = _body;
      results.mapper = (obj) => ObjectSerializer.deserialize(obj, 'CatalogRequestExtended');
    })
    .catch((error) => {
      if (error.data) {
        throw CoreError.deserialize(error.data);
      } else {
        throw error;
      }
    });
  }
  async objectSearchByClassColumns(classId: UUID): Promise<ObjectSearchColumns> {
  const _queryParams = {
      
  };
  const _bodyParams = {
      
  };
  let _path = '/catalog/objectSearch/{classId}/columns';
  _path = _path.replace('{classId}', encodeURIComponent(String(classId)));
  return this.client.get(
    _path,
    { params: _queryParams })
    .then((response) => {
      // BaseApiClient uses validateStatus: () => true, so we must check status manually
      if (response.status >= 400) {
        throw CoreError.deserialize(response.data);
      }
      return ObjectSerializer.deserialize(response.data, 'ObjectSearchColumns')
    })
    .catch((error) => {
      if (error.data) {
        throw CoreError.deserialize(error.data);
      } else {
        throw error;
      }
    });
  }
  async objectSearchByClass(results: PagedResults<ObjectSearchResultForClass>, classId: UUID, objectSearchFilterForClass: ObjectSearchFilterForClass, sort?: SortObject): Promise<void> {
  const _body = {
      classId,objectSearchFilterForClass,sort,
  };
  let _path = '/catalog/objectSearch/{classId}';
  _path = _path.replace('{classId}', encodeURIComponent(String(classId)));
  return this.client.post(
    _path,
    {
      ..._body,
      pageNumber: results.pageNumber,
      pageSize: results.pageSize,
    })
    .then((response) => {
      // BaseApiClient uses validateStatus: () => true, so we must check status manually
      if (response.status >= 400) {
        throw CoreError.deserialize(response.data);
      }
      results.items = ObjectSerializer.deserialize(response.data, 'Array<ObjectSearchResultForClass>');
      results.count = response.headers.count ? Number(response.headers.count) : -1;
      results.pageToken = response.headers.pagetoken ?? response.headers.pageToken;
      results.headers = this.headers;
      results.baseUrl = new URL(`${this.client.getUri()}/catalog/objectSearch/{classId}`);
      results.httpMethod = HttpMethod.Post;
      results.body = _body;
      results.mapper = (obj) => ObjectSerializer.deserialize(obj, 'ObjectSearchResultForClass');
    })
    .catch((error) => {
      if (error.data) {
        throw CoreError.deserialize(error.data);
      } else {
        throw error;
      }
    });
  }
  async objectSearchMetadataByClass(classId: UUID, objectSearchFilterForClass: ObjectSearchFilterForClass): Promise<ObjectSearchResultsMetadata> {
  const _queryParams = {
      
  };
  const _bodyParams = {
      objectSearchFilterForClass,
  };
  let _path = '/catalog/objectSearchMetadata/{classId}';
  _path = _path.replace('{classId}', encodeURIComponent(String(classId)));
  return this.client.post(
    _path,
    _bodyParams)
    .then((response) => {
      // BaseApiClient uses validateStatus: () => true, so we must check status manually
      if (response.status >= 400) {
        throw CoreError.deserialize(response.data);
      }
      return ObjectSerializer.deserialize(response.data, 'ObjectSearchResultsMetadata')
    })
    .catch((error) => {
      if (error.data) {
        throw CoreError.deserialize(error.data);
      } else {
        throw error;
      }
    });
  }
  async removeRequestUpvote(catalogRequestId: UUID): Promise<void> {
  const _queryParams = {
      
  };
  const _bodyParams = {
      
  };
  let _path = '/catalog/requests/{catalogRequestId}/upvotes';
  _path = _path.replace('{catalogRequestId}', encodeURIComponent(String(catalogRequestId)));
  return this.client.delete(
    _path,
    { params: _queryParams })
    .then((response) => {
      // BaseApiClient uses validateStatus: () => true, so we must check status manually
      if (response.status >= 400) {
        throw CoreError.deserialize(response.data);
      }
      return ObjectSerializer.deserialize(response.data, '')
    })
    .catch((error) => {
      if (error.data) {
        throw CoreError.deserialize(error.data);
      } else {
        throw error;
      }
    });
  }
  async searchRequests(results: PagedResults<CatalogRequestExtended>, searchRequestBody: SearchRequestBody, sort?: SortObject): Promise<void> {
  const _body = {
      searchRequestBody,sort,
  };
  let _path = '/catalog/requestSearch';
  return this.client.post(
    _path,
    {
      ..._body,
      pageNumber: results.pageNumber,
      pageSize: results.pageSize,
    })
    .then((response) => {
      // BaseApiClient uses validateStatus: () => true, so we must check status manually
      if (response.status >= 400) {
        throw CoreError.deserialize(response.data);
      }
      results.items = ObjectSerializer.deserialize(response.data, 'Array<CatalogRequestExtended>');
      results.count = response.headers.count ? Number(response.headers.count) : -1;
      results.pageToken = response.headers.pagetoken ?? response.headers.pageToken;
      results.headers = this.headers;
      results.baseUrl = new URL(`${this.client.getUri()}/catalog/requestSearch`);
      results.httpMethod = HttpMethod.Post;
      results.body = _body;
      results.mapper = (obj) => ObjectSerializer.deserialize(obj, 'CatalogRequestExtended');
    })
    .catch((error) => {
      if (error.data) {
        throw CoreError.deserialize(error.data);
      } else {
        throw error;
      }
    });
  }
  async searchRequestsOptions(): Promise<ResultsColumnOptionsWrapper> {
  const _queryParams = {
      
  };
  const _bodyParams = {
      
  };
  let _path = '/catalog/requestSearch/options';
  return this.client.get(
    _path,
    { params: _queryParams })
    .then((response) => {
      // BaseApiClient uses validateStatus: () => true, so we must check status manually
      if (response.status >= 400) {
        throw CoreError.deserialize(response.data);
      }
      return ObjectSerializer.deserialize(response.data, 'ResultsColumnOptionsWrapper')
    })
    .catch((error) => {
      if (error.data) {
        throw CoreError.deserialize(error.data);
      } else {
        throw error;
      }
    });
  }
  async updateRequestComment(catalogRequestId: UUID, commentId: UUID, createCatalogRequestComment: CreateCatalogRequestComment): Promise<CatalogRequestCommentExtended> {
  const _queryParams = {
      
  };
  const _bodyParams = {
      createCatalogRequestComment,
  };
  let _path = '/catalog/requests/{catalogRequestId}/comments/{commentId}';
  _path = _path.replace('{catalogRequestId}', encodeURIComponent(String(catalogRequestId)));
  _path = _path.replace('{commentId}', encodeURIComponent(String(commentId)));
  return this.client.put(
    _path,
    _bodyParams)
    .then((response) => {
      // BaseApiClient uses validateStatus: () => true, so we must check status manually
      if (response.status >= 400) {
        throw CoreError.deserialize(response.data);
      }
      return ObjectSerializer.deserialize(response.data, 'CatalogRequestCommentExtended')
    })
    .catch((error) => {
      if (error.data) {
        throw CoreError.deserialize(error.data);
      } else {
        throw error;
      }
    });
  }
  async upvoteRequest(catalogRequestId: UUID): Promise<void> {
  const _queryParams = {
      
  };
  const _bodyParams = {
      
  };
  let _path = '/catalog/requests/{catalogRequestId}/upvotes';
  _path = _path.replace('{catalogRequestId}', encodeURIComponent(String(catalogRequestId)));
  return this.client.put(
    _path,
    _bodyParams)
    .then((response) => {
      // BaseApiClient uses validateStatus: () => true, so we must check status manually
      if (response.status >= 400) {
        throw CoreError.deserialize(response.data);
      }
      return ObjectSerializer.deserialize(response.data, '')
    })
    .catch((error) => {
      if (error.data) {
        throw CoreError.deserialize(error.data);
      } else {
        throw error;
      }
    });
  }
}
