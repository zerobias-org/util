/* eslint-disable */
// ===============================================
// This file is autogenerated - Please do not edit
// ===============================================
import { EnumValue, IllegalArgumentError, UUID } from '@zerobias-org/types-core-js';
import { ObjectSerializer, RequestFile } from './index.js';

/**
* Request body for union type sync
*/
export class SyncUnionTypeBody {
  'orgId'?: UUID;
  'mitre'?: boolean;
  'cpeProducts'?: boolean;
  'skipUnionTypes'?: Array<SyncUnionTypeBody.SkipUnionTypesEnumDef>;
  'testMode'?: boolean;
  'testModeSize'?: number;

  static readonly discriminator: string | undefined = undefined;

  static attributeTypeMap: ReadonlyArray<{name: string, baseName: string, type: string, format: string}> = [
    {
      "name": "orgId",
      "baseName": "orgId",
      // false
      // UUID
      // UUID
      "type": "UUID",
      "format": "uuid"
    },
    {
      "name": "mitre",
      "baseName": "mitre",
      // false
      // boolean
      // boolean
      "type": "boolean",
      "format": ""
    },
    {
      "name": "cpeProducts",
      "baseName": "cpeProducts",
      // false
      // boolean
      // boolean
      "type": "boolean",
      "format": ""
    },
    {
      "name": "skipUnionTypes",
      "baseName": "skipUnionTypes",
      // true
      // Array&lt;SyncUnionTypeBody.SkipUnionTypesEnum&gt;
      // Array&lt;SyncUnionTypeBody.SkipUnionTypesEnumDef&gt;
      "type": "Array<SyncUnionTypeBody.SkipUnionTypesEnum>",
      "format": ""
    },
    {
      "name": "testMode",
      "baseName": "testMode",
      // false
      // boolean
      // boolean
      "type": "boolean",
      "format": ""
    },
    {
      "name": "testModeSize",
      "baseName": "testModeSize",
      // false
      // number
      // number
      "type": "number",
      "format": ""
    }  ];

  static getAttributeTypeMap() {
    return SyncUnionTypeBody.attributeTypeMap;
  }

  static newInstance(obj: any): SyncUnionTypeBody {
    return ObjectSerializer.deserialize(obj, 'SyncUnionTypeBody');
  }

  constructor(orgId?: UUID, mitre?: boolean, cpeProducts?: boolean, skipUnionTypes?: Array<SyncUnionTypeBody.SkipUnionTypesEnumDef>, testMode?: boolean, testModeSize?: number) {
    this.orgId = orgId;
    this.mitre = mitre;
    this.cpeProducts = cpeProducts;
    this.skipUnionTypes = skipUnionTypes;
    this.testMode = testMode;
    this.testModeSize = testModeSize;
  }
}

export namespace SyncUnionTypeBody {
  export const SkipUnionTypesEnum = {
    /**  */
    Component: EnumValue.instance('SyncUnionTypeBody.SkipUnionTypesEnum', 'Component', 'component'),
    /**  */
    Finding: EnumValue.instance('SyncUnionTypeBody.SkipUnionTypesEnum', 'Finding', 'finding'),
    /**  */
    TestCase: EnumValue.instance('SyncUnionTypeBody.SkipUnionTypesEnum', 'TestCase', 'testCase'),
    /**  */
    Vulnerability: EnumValue.instance('SyncUnionTypeBody.SkipUnionTypesEnum', 'Vulnerability', 'vulnerability'),
    /**  */
    Weakness: EnumValue.instance('SyncUnionTypeBody.SkipUnionTypesEnum', 'Weakness', 'weakness'),
    /**  */
    AttackPattern: EnumValue.instance('SyncUnionTypeBody.SkipUnionTypesEnum', 'AttackPattern', 'attackPattern'),

    from(val: string | number): EnumValue {
      if (SkipUnionTypesEnum[val]) {
        return SkipUnionTypesEnum[val];
      }
      const byValue = SkipUnionTypesEnum.values.find((v) => v.value === val);
      if (byValue) {
        return byValue;
      }
      throw new IllegalArgumentError(`${val} is not a valid SkipUnionTypesEnum`);
    },

    get values(): EnumValue[] {
      return Object
        .keys(SkipUnionTypesEnum)
        .filter((k) => k !== 'values' && k !== 'from')
        .map((t) => SkipUnionTypesEnum[t]);
    }
  } as const;

  export type SkipUnionTypesEnumDef = typeof SkipUnionTypesEnum[keyof typeof SkipUnionTypesEnum];
}
