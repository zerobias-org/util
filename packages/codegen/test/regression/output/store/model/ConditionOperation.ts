/* eslint-disable */
// ===============================================
// This file is autogenerated - Please do not edit
// ===============================================
import { EnumValue, IllegalArgumentError } from '@zerobias-org/types-core-js';
import { ObjectSerializer, RequestFile } from './index.js';

/**
* The set of operations that may be provided when evaluating conditions.
*/
export const ConditionOperation = {
  /** the given property &#x60;exists&#x60; and its value may be null or an empty array. */
  Exists: EnumValue.instance('ConditionOperation', 'Exists', 'exists'),
  /** the given property does not exist. */
  DoesNotExist: EnumValue.instance('ConditionOperation', 'DoesNotExist', 'does_not_exist'),
  /** the given property &#x60;exists&#x60; and is not null or a non-zero length array. */
  IsDefined: EnumValue.instance('ConditionOperation', 'IsDefined', 'is_defined'),
  /** the given property exists and is null. */
  IsUndefined: EnumValue.instance('ConditionOperation', 'IsUndefined', 'is_undefined'),
  /** the given property is an exact match. */
  Equals: EnumValue.instance('ConditionOperation', 'Equals', 'equals'),
  /** the given property is not an exact match. */
  NotEquals: EnumValue.instance('ConditionOperation', 'NotEquals', 'not_equals'),
  /** the given property is an exact match ignoring case. */
  EqualsIc: EnumValue.instance('ConditionOperation', 'EqualsIc', 'equals_ic'),
  /** the given property is not an exact match ignoring case. */
  NotEqualsIc: EnumValue.instance('ConditionOperation', 'NotEqualsIc', 'not_equals_ic'),
  /** the given value matches a regular expression using * on either side. */
  Like: EnumValue.instance('ConditionOperation', 'Like', 'like'),
  /** the given value does not match a regular expression using * on either side. */
  NotLike: EnumValue.instance('ConditionOperation', 'NotLike', 'not_like'),
  /** the given value matches a regular expression using *, ignoring case. */
  LikeIc: EnumValue.instance('ConditionOperation', 'LikeIc', 'like_ic'),
  /** the given value does not match a regular expression using *, ignoring case. */
  NotLikeIc: EnumValue.instance('ConditionOperation', 'NotLikeIc', 'not_like_ic'),
  /** the given property is a number greater than or equals to value. */
  AtLeast: EnumValue.instance('ConditionOperation', 'AtLeast', 'at_least'),
  /** the given property is a number less than or equals to value. */
  AtMost: EnumValue.instance('ConditionOperation', 'AtMost', 'at_most'),
  /** the given property is an array and its size matches the given value. */
  LengthEquals: EnumValue.instance('ConditionOperation', 'LengthEquals', 'length_equals'),
  /** the given property is an array of size less than or equals to value. */
  LengthAtMost: EnumValue.instance('ConditionOperation', 'LengthAtMost', 'length_at_most'),
  /** the given property is an array of size greater than or equals to value. */
  LengthAtLeast: EnumValue.instance('ConditionOperation', 'LengthAtLeast', 'length_at_least'),
  /** the given property is an array and contains any of the given values. */
  AnyOf: EnumValue.instance('ConditionOperation', 'AnyOf', 'any_of'),
  /** the given property is an array and contains none of the given values. */
  NoneOf: EnumValue.instance('ConditionOperation', 'NoneOf', 'none_of'),
  /** the given property is an array and contains all of the given values. */
  AllOf: EnumValue.instance('ConditionOperation', 'AllOf', 'all_of'),

  from(val: string | number): EnumValue {
    if (ConditionOperation[val]) {
      return ConditionOperation[val];
    }
    const byValue = ConditionOperation.values.find((v) => v.value === val);
    if (byValue) {
      return byValue;
    }
    throw new IllegalArgumentError(`${val} is not a valid ConditionOperation`);
  },

  get values(): EnumValue[] {
    return Object
      .keys(ConditionOperation)
      .filter((k) => k !== 'values' && k !== 'from')
      .map((t) => ConditionOperation[t]);
  }
} as const;

export type ConditionOperationDef = typeof ConditionOperation[keyof typeof ConditionOperation];
