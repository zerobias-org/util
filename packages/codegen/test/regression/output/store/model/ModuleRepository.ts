/* eslint-disable */
// ===============================================
// This file is autogenerated - Please do not edit
// ===============================================
import { EnumValue, IllegalArgumentError } from '@zerobias-org/types-core-js';
import { ObjectSerializer, RequestFile } from './index.js';

/**
* Description of where to locate a module version
*/
export class ModuleRepository {
  /**
  * The type of repository
  */
  'type': ModuleRepository.TypeEnumDef;
  /**
  * Location string for the repository. Content is dependent on `type` - `npm`: the `location` string should be an NPM package name that the Hub server can resolve
  */
  'location': string;

  static readonly discriminator: string | undefined = undefined;

  static attributeTypeMap: ReadonlyArray<{name: string, baseName: string, type: string, format: string}> = [
    {
      "name": "type",
      "baseName": "type",
      // true
      // ModuleRepository.TypeEnum
      // ModuleRepository.TypeEnumDef
      "type": "ModuleRepository.TypeEnum",
      "format": ""
    },
    {
      "name": "location",
      "baseName": "location",
      // false
      // string
      // string
      "type": "string",
      "format": ""
    }  ];

  static getAttributeTypeMap() {
    return ModuleRepository.attributeTypeMap;
  }

  static newInstance(obj: any): ModuleRepository {
    return ObjectSerializer.deserialize(obj, 'ModuleRepository');
  }

  constructor(type: ModuleRepository.TypeEnumDef, location: string, ) {
    this.type = type;
    this.location = location;
  }
}

export namespace ModuleRepository {
  export const TypeEnum = {
    /**  */
    Npm: EnumValue.instance('ModuleRepository.TypeEnum', 'Npm', 'npm'),

    from(val: string | number): EnumValue {
      if (TypeEnum[val]) {
        return TypeEnum[val];
      }
      const byValue = TypeEnum.values.find((v) => v.value === val);
      if (byValue) {
        return byValue;
      }
      throw new IllegalArgumentError(`${val} is not a valid TypeEnum`);
    },

    get values(): EnumValue[] {
      return Object
        .keys(TypeEnum)
        .filter((k) => k !== 'values' && k !== 'from')
        .map((t) => TypeEnum[t]);
    }
  } as const;

  export type TypeEnumDef = typeof TypeEnum[keyof typeof TypeEnum];
}
