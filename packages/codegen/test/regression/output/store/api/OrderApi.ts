/* eslint-disable */
// ===============================================
// This file is autogenerated - Please do not edit
// ===============================================
import { AxiosInstance } from 'axios';
import { CatalogingOrder, CreateCatalogingOrder, CreateOperationOrder, CreateProductOrder, OperationOrder, Order, OrderStatusParam, OrderTypeDef, PatchOrder, PriorityDef, ProductOrder, SortParamDef } from '../model/index.js';
import { URL, EnumValue, IllegalArgumentError, PagedResults, Int32, UUID, CoreError, ParameterRequiredError, UnexpectedError, HttpMethod } from '@zerobias-org/types-core-js';
import { RequestFile, ObjectSerializer } from '../model/index.js';

export namespace OrderApi {
  export const OrderByEnum = {
    /**  */
    Description: EnumValue.instance('OrderApi.OrderByEnum', 'Description', 'description'),
    /**  */
    Created: EnumValue.instance('OrderApi.OrderByEnum', 'Created', 'created'),
    /**  */
    Expected: EnumValue.instance('OrderApi.OrderByEnum', 'Expected', 'expected'),
    /**  */
    Status: EnumValue.instance('OrderApi.OrderByEnum', 'Status', 'status'),

    from(val: string | number): EnumValue {
      if (OrderByEnum[val]) {
        return OrderByEnum[val];
      }
      const byValue = OrderByEnum.values.find((v) => v.value === val);
      if (byValue) {
        return byValue;
      }
      throw new IllegalArgumentError(`${val} is not a valid OrderByEnum`);
    },

    get values(): EnumValue[] {
      return Object
        .keys(OrderByEnum)
        .filter((k) => k !== 'values' && k !== 'from')
        .map((t) => OrderByEnum[t]);
    }
  } as const;

export type OrderByEnumDef = typeof OrderByEnum[keyof typeof OrderByEnum];
}

/**
 * OrderApi - interface
 * @export
 * @interface OrderApi
 */
export interface OrderApi {
  /**
   * 
   * @summary Adds an item to an order. This is currently only supported for product orders which may contain a single product id.
   * @param {UUID} orderId 
   * @param {Array<UUID>} uUID Adds a set of items to an order
   * @param {*} [options] Override http request option.
   * @throws {@link @zerobias-org/types-core-js#ParameterRequiredError} if any required parameter is not provided
   * @example
   * ```typescript
   * const result = await api.addItems('00000000-0000-0000-0000-000000000000', null);
   * ```
   * @openapi operation=addOrderItems path=/orders/{orderId}/items method=POST
   * @memberof OrderApi
   */
  addItems(orderId: UUID, uUID: Array<UUID>): Promise<Order>;

  /**
   * 
   * @summary Create an order. One of 3 order types may be requested:
  * product: A low fidelity product order
  * catalog: Cataloging request for an existing verified product
  * operation: Operations from an active cataloged product

An Operation order is a high fidelity order that may contain up to 10 operations that belong to the same module.
  * Operation orders may only contain `orderable` operations. 
  * Any order containing operations that aren't `orderable` will be vetoed.
A Product order is a low fidelity order that may contain information on a new product and its vendor and suite parent(s)
  * The output of such an order is one or more products in the `verified` status
A catalog order is a request to catalog a newly verified product.
  * The output of such an order is a fully cataloged product with a new module that can connect to the given product
  * Catalog orders have to go through business and lab analysis in order to lay out cost.

All order types may be provided a custom json context that is set by the customer.
   * @param {CreateOperationOrder | CreateProductOrder | CreateCatalogingOrder} createOperationOrderCreateProductOrderCreateCatalogingOrder An order that may contain up 10 operations on the same module or a product.
   * @param {*} [options] Override http request option.
   * @throws {@link @zerobias-org/types-core-js#ParameterRequiredError} if any required parameter is not provided
   * @example
   * ```typescript
   * const result = await api.create(null);
   * ```
   * @openapi operation=createOrder path=/orders method=POST
   * @memberof OrderApi
   */
  create(createOperationOrderCreateProductOrderCreateCatalogingOrder: CreateOperationOrder | CreateProductOrder | CreateCatalogingOrder): Promise<Order>;

  /**
   * 
   * @summary Retrieves details about the given order
   * @param {UUID} orderId 
   * @param {*} [options] Override http request option.
   * @throws {@link @zerobias-org/types-core-js#ParameterRequiredError} if any required parameter is not provided
   * @example
   * ```typescript
   * const result = await api.get('00000000-0000-0000-0000-000000000000');
   * ```
   * @openapi operation=getOrder path=/orders/{orderId} method=GET
   * @memberof OrderApi
   */
  get(orderId: UUID): Promise<ProductOrder | CatalogingOrder | OperationOrder>;

  /**
   * 
   * @summary Retrieves a list of orders
   * @param {number} [pageNumber] The requested page. This value is 1-indexed.
   * @param {number} [pageSize] The number of items in each page of data.
   * @param {OrderStatusParam} [orderStatus] Filter by order status
   * @param {OrderType} [orderType] Filter by order type
   * @param {Priority} [priority] Filter by order priority
   * @param {SortParam} [sort] The order in which to sort the results, defaults to &#x60;asc&#x60;
   * @param {OrderApi.OrderByEnum} [orderBy] Order by the given property
   * @param {*} [options] Override http request option.
   * @throws {@link @zerobias-org/types-core-js#ParameterRequiredError} if any required parameter is not provided
   * @example
   * ```typescript
   * const result = await api.list(1, 1, null, null, null, null, 'orderBy');
   * ```
   * @openapi operation=listOrders path=/orders method=GET
   * @memberof OrderApi
   */
  list(pageNumber?: number, pageSize?: number, orderStatus?: OrderStatusParam, orderType?: OrderTypeDef, priority?: PriorityDef, sort?: SortParamDef, orderBy?: OrderApi.OrderByEnumDef): Promise<PagedResults<Order>>;

  /**
   * 
   * @summary Removes items from an order.
   * @param {UUID} orderId 
   * @param {Array<UUID>} itemIds An array of items to remove from this order
   * @param {*} [options] Override http request option.
   * @throws {@link @zerobias-org/types-core-js#ParameterRequiredError} if any required parameter is not provided
   * @example
   * ```typescript
   * const result = await api.removeItems('00000000-0000-0000-0000-000000000000', null);
   * ```
   * @openapi operation=removeOrderItems path=/orders/{orderId}/items method=DELETE
   * @memberof OrderApi
   */
  removeItems(orderId: UUID, itemIds: Array<UUID>): Promise<void>;

  /**
   * 
   * @summary Updates an order
   * @param {UUID} orderId 
   * @param {PatchOrder} patchOrder Properties that may be updated on an order
   * @param {*} [options] Override http request option.
   * @throws {@link @zerobias-org/types-core-js#ParameterRequiredError} if any required parameter is not provided
   * @example
   * ```typescript
   * const result = await api.patch('00000000-0000-0000-0000-000000000000', null);
   * ```
   * @openapi operation=updateOrder path=/orders/{orderId} method=PATCH
   * @memberof OrderApi
   */
  patch(orderId: UUID, patchOrder: PatchOrder): Promise<Order>;

}

/**
 * OrderProducerApi - interface
 * Producer interface for Order
 * @export
 * @interface OrderProducerApi
 */
export interface OrderProducerApi {
  /**
  * 
  * @summary Adds an item to an order. This is currently only supported for product orders which may contain a single product id.
  * @param {UUID} orderId 
  * @param {Array<UUID>} uUID Adds a set of items to an order
  * @param {*} [options] Override http request option.
  * @throws {@link @zerobias-org/types-core-js#ParameterRequiredError} if any required parameter is not provided
  * @openapi operation=addOrderItems path=/orders/{orderId}/items method=POST
  * @memberof Order
  */
  addItems(orderId: UUID, uUID: Array<UUID>): Promise<Order>;
  /**
  * 
  * @summary Create an order. One of 3 order types may be requested:
  * product: A low fidelity product order
  * catalog: Cataloging request for an existing verified product
  * operation: Operations from an active cataloged product

An Operation order is a high fidelity order that may contain up to 10 operations that belong to the same module.
  * Operation orders may only contain `orderable` operations. 
  * Any order containing operations that aren't `orderable` will be vetoed.
A Product order is a low fidelity order that may contain information on a new product and its vendor and suite parent(s)
  * The output of such an order is one or more products in the `verified` status
A catalog order is a request to catalog a newly verified product.
  * The output of such an order is a fully cataloged product with a new module that can connect to the given product
  * Catalog orders have to go through business and lab analysis in order to lay out cost.

All order types may be provided a custom json context that is set by the customer.
  * @param {CreateOperationOrder | CreateProductOrder | CreateCatalogingOrder} createOperationOrderCreateProductOrderCreateCatalogingOrder An order that may contain up 10 operations on the same module or a product.
  * @param {*} [options] Override http request option.
  * @throws {@link @zerobias-org/types-core-js#ParameterRequiredError} if any required parameter is not provided
  * @openapi operation=createOrder path=/orders method=POST
  * @memberof Order
  */
  create(createOperationOrderCreateProductOrderCreateCatalogingOrder: CreateOperationOrder | CreateProductOrder | CreateCatalogingOrder): Promise<Order>;
  /**
  * 
  * @summary Retrieves details about the given order
  * @param {UUID} orderId 
  * @param {*} [options] Override http request option.
  * @throws {@link @zerobias-org/types-core-js#ParameterRequiredError} if any required parameter is not provided
  * @openapi operation=getOrder path=/orders/{orderId} method=GET
  * @memberof Order
  */
  get(orderId: UUID): Promise<ProductOrder | CatalogingOrder | OperationOrder>;
  /**
  * 
  * @summary Retrieves a list of orders
  * @param {OrderStatusParam} [orderStatus] Filter by order status
  * @param {OrderType} [orderType] Filter by order type
  * @param {Priority} [priority] Filter by order priority
  * @param {SortParam} [sort] The order in which to sort the results, defaults to &#x60;asc&#x60;
  * @param {OrderApi.OrderByEnum} [orderBy] Order by the given property
  * @param {*} [options] Override http request option.
  * @throws {@link @zerobias-org/types-core-js#ParameterRequiredError} if any required parameter is not provided
  * @openapi operation=listOrders path=/orders method=GET
  * @memberof Order
  */
  list(results: PagedResults<Order>, orderStatus?: OrderStatusParam, orderType?: OrderTypeDef, priority?: PriorityDef, sort?: SortParamDef, orderBy?: OrderApi.OrderByEnumDef): Promise<void>;
  /**
  * 
  * @summary Removes items from an order.
  * @param {UUID} orderId 
  * @param {Array<UUID>} itemIds An array of items to remove from this order
  * @param {*} [options] Override http request option.
  * @throws {@link @zerobias-org/types-core-js#ParameterRequiredError} if any required parameter is not provided
  * @openapi operation=removeOrderItems path=/orders/{orderId}/items method=DELETE
  * @memberof Order
  */
  removeItems(orderId: UUID, itemIds: Array<UUID>): Promise<void>;
  /**
  * 
  * @summary Updates an order
  * @param {UUID} orderId 
  * @param {PatchOrder} patchOrder Properties that may be updated on an order
  * @param {*} [options] Override http request option.
  * @throws {@link @zerobias-org/types-core-js#ParameterRequiredError} if any required parameter is not provided
  * @openapi operation=updateOrder path=/orders/{orderId} method=PATCH
  * @memberof Order
  */
  patch(orderId: UUID, patchOrder: PatchOrder): Promise<Order>;
}

export class OrderApiMappingImpl implements OrderApi {
  private producer: OrderProducerApi;
  constructor(producer: OrderProducerApi) {
    this.producer = producer;
  }

  /**
   * 
   * @summary Adds an item to an order. This is currently only supported for product orders which may contain a single product id.
   * @param orderId 
   * @param uUID Adds a set of items to an order
   * @openapi operation=addOrderItems path=/orders/{orderId}/items method=POST
   */
  public async addItems(orderId: UUID, uUID: Array<UUID>): Promise<Order> {
    // verify required parameter 'orderId' is not null or undefined
    if (orderId === null || orderId === undefined) {
      throw new ParameterRequiredError('orderId');
    }
    // verify required parameter 'uUID' is not null or undefined
    if (uUID === null || uUID === undefined) {
      throw new ParameterRequiredError('uUID');
    }
    return this.producer.addItems(orderId, uUID);
  }
  /**
   * 
   * @summary Create an order. One of 3 order types may be requested:
  * product: A low fidelity product order
  * catalog: Cataloging request for an existing verified product
  * operation: Operations from an active cataloged product

An Operation order is a high fidelity order that may contain up to 10 operations that belong to the same module.
  * Operation orders may only contain `orderable` operations. 
  * Any order containing operations that aren't `orderable` will be vetoed.
A Product order is a low fidelity order that may contain information on a new product and its vendor and suite parent(s)
  * The output of such an order is one or more products in the `verified` status
A catalog order is a request to catalog a newly verified product.
  * The output of such an order is a fully cataloged product with a new module that can connect to the given product
  * Catalog orders have to go through business and lab analysis in order to lay out cost.

All order types may be provided a custom json context that is set by the customer.
   * @param createOperationOrderCreateProductOrderCreateCatalogingOrder An order that may contain up 10 operations on the same module or a product.
   * @openapi operation=createOrder path=/orders method=POST
   */
  public async create(createOperationOrderCreateProductOrderCreateCatalogingOrder: CreateOperationOrder | CreateProductOrder | CreateCatalogingOrder): Promise<Order> {
    // verify required parameter 'createOperationOrderCreateProductOrderCreateCatalogingOrder' is not null or undefined
    if (createOperationOrderCreateProductOrderCreateCatalogingOrder === null || createOperationOrderCreateProductOrderCreateCatalogingOrder === undefined) {
      throw new ParameterRequiredError('createOperationOrderCreateProductOrderCreateCatalogingOrder');
    }
    return this.producer.create(createOperationOrderCreateProductOrderCreateCatalogingOrder);
  }
  /**
   * 
   * @summary Retrieves details about the given order
   * @param orderId 
   * @openapi operation=getOrder path=/orders/{orderId} method=GET
   */
  public async get(orderId: UUID): Promise<ProductOrder | CatalogingOrder | OperationOrder> {
    // verify required parameter 'orderId' is not null or undefined
    if (orderId === null || orderId === undefined) {
      throw new ParameterRequiredError('orderId');
    }
    return this.producer.get(orderId);
  }
  /**
   * 
   * @summary Retrieves a list of orders
   * @param pageNumber The requested page. This value is 1-indexed.
   * @param pageSize The number of items in each page of data.
   * @param orderStatus Filter by order status
   * @param orderType Filter by order type
   * @param priority Filter by order priority
   * @param sort The order in which to sort the results, defaults to &#x60;asc&#x60;
   * @param orderBy Order by the given property
   * @openapi operation=listOrders path=/orders method=GET
   */
  public async list(pageNumber: number = 1, pageSize: number = 50, orderStatus?: OrderStatusParam, orderType?: OrderTypeDef, priority?: PriorityDef, sort?: SortParamDef, orderBy: OrderApi.OrderByEnumDef = OrderApi.OrderByEnum.Created as OrderApi.OrderByEnumDef): Promise<PagedResults<Order>> {
    if (pageNumber) {
      await Int32.parse(pageNumber);
    }
    if (pageSize) {
      await Int32.parse(pageSize);
    }
    const bag = new PagedResults<Order>();
    bag.pageNumber = pageNumber;
    bag.pageSize = pageSize;
    await this.producer.list(bag, orderStatus, orderType, priority, sort, orderBy);
    if (bag.items === null || bag.items === undefined) {
      throw new UnexpectedError("Producers must return 'items' for PagedResults queries");
    }
    return bag;
  }
  /**
   * 
   * @summary Removes items from an order.
   * @param orderId 
   * @param itemIds An array of items to remove from this order
   * @openapi operation=removeOrderItems path=/orders/{orderId}/items method=DELETE
   */
  public async removeItems(orderId: UUID, itemIds: Array<UUID> = []): Promise<void> {
    // verify required parameter 'orderId' is not null or undefined
    if (orderId === null || orderId === undefined) {
      throw new ParameterRequiredError('orderId');
    }
    // verify required parameter 'itemIds' is not null or undefined
    if (itemIds === null || itemIds === undefined) {
      throw new ParameterRequiredError('itemIds');
    }
    return this.producer.removeItems(orderId, itemIds);
  }
  /**
   * 
   * @summary Updates an order
   * @param orderId 
   * @param patchOrder Properties that may be updated on an order
   * @openapi operation=updateOrder path=/orders/{orderId} method=PATCH
   */
  public async patch(orderId: UUID, patchOrder: PatchOrder): Promise<Order> {
    // verify required parameter 'orderId' is not null or undefined
    if (orderId === null || orderId === undefined) {
      throw new ParameterRequiredError('orderId');
    }
    // verify required parameter 'patchOrder' is not null or undefined
    if (patchOrder === null || patchOrder === undefined) {
      throw new ParameterRequiredError('patchOrder');
    }
    return this.producer.patch(orderId, patchOrder);
  }
}

/**
 * Wrap producer with mapping implementation
 */
export function wrapOrderProducer(producer: OrderProducerApi): OrderApi {
  return new OrderApiMappingImpl(producer);
}

/**
 * OrderApiHttpImpl - Direct HTTP implementation
 *
 * Makes direct HTTP calls to the API using Axios.
 * Used by SDK clients for platform service access.
 */
export class OrderApiHttpImpl implements OrderProducerApi {
  private client: AxiosInstance;
  private headers: Record<string, string>;

  constructor(client: AxiosInstance, headers: Record<string, string> = {}) {
    this.client = client;
    this.headers = headers;
  }

  async addItems(orderId: UUID, uUID: Array<UUID>): Promise<Order> {
  const _queryParams = {
      
  };
  const _bodyParams = {
      uUID,
  };
  let _path = '/orders/{orderId}/items';
  _path = _path.replace('{orderId}', encodeURIComponent(String(orderId)));
  return this.client.post(
    _path,
    _bodyParams)
    .then((response) => {
      // BaseApiClient uses validateStatus: () => true, so we must check status manually
      if (response.status >= 400) {
        throw CoreError.deserialize(response.data);
      }
      return ObjectSerializer.deserialize(response.data, 'Order')
    })
    .catch((error) => {
      if (error.data) {
        throw CoreError.deserialize(error.data);
      } else {
        throw error;
      }
    });
  }
  async create(createOperationOrderCreateProductOrderCreateCatalogingOrder: CreateOperationOrder | CreateProductOrder | CreateCatalogingOrder): Promise<Order> {
  const _queryParams = {
      
  };
  const _bodyParams = {
      ...createOperationOrderCreateProductOrderCreateCatalogingOrder,
  };
  let _path = '/orders';
  return this.client.post(
    _path,
    _bodyParams)
    .then((response) => {
      // BaseApiClient uses validateStatus: () => true, so we must check status manually
      if (response.status >= 400) {
        throw CoreError.deserialize(response.data);
      }
      return ObjectSerializer.deserialize(response.data, 'Order')
    })
    .catch((error) => {
      if (error.data) {
        throw CoreError.deserialize(error.data);
      } else {
        throw error;
      }
    });
  }
  async get(orderId: UUID): Promise<ProductOrder | CatalogingOrder | OperationOrder> {
  const _queryParams = {
      
  };
  const _bodyParams = {
      
  };
  let _path = '/orders/{orderId}';
  _path = _path.replace('{orderId}', encodeURIComponent(String(orderId)));
  return this.client.get(
    _path,
    { params: _queryParams })
    .then((response) => {
      // BaseApiClient uses validateStatus: () => true, so we must check status manually
      if (response.status >= 400) {
        throw CoreError.deserialize(response.data);
      }
      return ObjectSerializer.deserialize(response.data, 'ProductOrder | CatalogingOrder | OperationOrder')
    })
    .catch((error) => {
      if (error.data) {
        throw CoreError.deserialize(error.data);
      } else {
        throw error;
      }
    });
  }
  async list(results: PagedResults<Order>, orderStatus?: OrderStatusParam, orderType?: OrderTypeDef, priority?: PriorityDef, sort?: SortParamDef, orderBy?: OrderApi.OrderByEnumDef): Promise<void> {
  const _body = {
      orderStatus,orderType,priority,sort,orderBy,
  };
  let _path = '/orders';
  return this.client.get(
    _path,
    {
      params: {
        ..._body,
        pageNumber: results.pageNumber,
        pageSize: results.pageSize,
      }
    })
    .then((response) => {
      // BaseApiClient uses validateStatus: () => true, so we must check status manually
      if (response.status >= 400) {
        throw CoreError.deserialize(response.data);
      }
      results.items = ObjectSerializer.deserialize(response.data, 'Array<Order>');
      results.count = response.headers.count ? Number(response.headers.count) : -1;
      results.pageToken = response.headers.pagetoken ?? response.headers.pageToken;
      results.headers = this.headers;
      results.baseUrl = new URL(`${this.client.getUri()}/orders`);
      results.httpMethod = HttpMethod.Get;
      results.body = _body;
      results.mapper = (obj) => ObjectSerializer.deserialize(obj, 'Order');
    })
    .catch((error) => {
      if (error.data) {
        throw CoreError.deserialize(error.data);
      } else {
        throw error;
      }
    });
  }
  async removeItems(orderId: UUID, itemIds: Array<UUID>): Promise<void> {
  const _queryParams = {
      itemIds,
  };
  const _bodyParams = {
      
  };
  let _path = '/orders/{orderId}/items';
  _path = _path.replace('{orderId}', encodeURIComponent(String(orderId)));
  return this.client.delete(
    _path,
    { params: _queryParams })
    .then((response) => {
      // BaseApiClient uses validateStatus: () => true, so we must check status manually
      if (response.status >= 400) {
        throw CoreError.deserialize(response.data);
      }
      return ObjectSerializer.deserialize(response.data, '')
    })
    .catch((error) => {
      if (error.data) {
        throw CoreError.deserialize(error.data);
      } else {
        throw error;
      }
    });
  }
  async patch(orderId: UUID, patchOrder: PatchOrder): Promise<Order> {
  const _queryParams = {
      
  };
  const _bodyParams = {
      patchOrder,
  };
  let _path = '/orders/{orderId}';
  _path = _path.replace('{orderId}', encodeURIComponent(String(orderId)));
  return this.client.patch(
    _path,
    _bodyParams)
    .then((response) => {
      // BaseApiClient uses validateStatus: () => true, so we must check status manually
      if (response.status >= 400) {
        throw CoreError.deserialize(response.data);
      }
      return ObjectSerializer.deserialize(response.data, 'Order')
    })
    .catch((error) => {
      if (error.data) {
        throw CoreError.deserialize(error.data);
      } else {
        throw error;
      }
    });
  }
}
