/* eslint-disable */
// ===============================================
// This file is autogenerated - Please do not edit
// ===============================================
import { AxiosInstance } from 'axios';
import { Module, ModuleDependencyReport, ModuleSearch, ModuleStatusDef, ModuleVersion, ModuleVersionInfo, OpenApiMethodDef, Operation, OperationStatusDef, OperationTypeParamDef, OrderByParamDef, ResultsColumnOptionsWrapper, SearchModuleBody, SortObject, SortParamDef } from '../model/index.js';
import { URL, EnumValue, IllegalArgumentError, PagedResults, Int32, UUID, VersionRange, CoreError, ParameterRequiredError, UnexpectedError, HttpMethod } from '@zerobias-org/types-core-js';
import { RequestFile, ObjectSerializer } from '../model/index.js';

export namespace ModuleApi {
}

/**
 * ModuleApi - interface
 * @export
 * @interface ModuleApi
 */
export interface ModuleApi {
  /**
   * This endpoint generates a report describing the given Module and Version Range.
The moduleKeyOrId can either be:
  - a uuid of an existing module: i.e. 8086f5a7-e0bf-4478-b806-685c6095d1f2
  - a string that identifies the module by its key: i.e. the language specific package for this module. (@devsupply/github)
The output of this endpoint can then be used to feed into hub-server in order to create Modules and Module Versions.
   * @summary Generates a report that describes the given Module and Version Range.
   * @param {string} moduleKeyOrId The module to look for.  Either the module id or its key (@devsupply/github)
   * @param {UUID} [moduleVersionId] A specific version of a module.  The provided moduleVersionId must belong to the given module
   * @param {VersionRange} [version] Version specification for the module
   * @param {*} [options] Override http request option.
   * @throws {@link @zerobias-org/types-core-js#ParameterRequiredError} if any required parameter is not provided
   * @example
   * ```typescript
   * const result = await api.getDependencyReport('moduleKeyOrId', '00000000-0000-0000-0000-000000000000', null);
   * ```
   * @openapi operation=getDependencyReport path=/modules/{moduleKeyOrId}/dependencies method=GET
   * @memberof ModuleApi
   */
  getDependencyReport(moduleKeyOrId: string, moduleVersionId?: UUID, version?: VersionRange): Promise<ModuleDependencyReport>;

  /**
   * 
   * @summary Retrieves a module
   * @param {UUID} moduleId 
   * @param {*} [options] Override http request option.
   * @throws {@link @zerobias-org/types-core-js#ParameterRequiredError} if any required parameter is not provided
   * @example
   * ```typescript
   * const result = await api.get('00000000-0000-0000-0000-000000000000');
   * ```
   * @openapi operation=getModule path=/modules/{moduleId} method=GET
   * @memberof ModuleApi
   */
  get(moduleId: UUID): Promise<Module>;

  /**
   * 
   * @summary Retrieves a module version for a given module
   * @param {UUID} moduleId 
   * @param {string} version Version id or Semantic version
   * @param {*} [options] Override http request option.
   * @throws {@link @zerobias-org/types-core-js#ParameterRequiredError} if any required parameter is not provided
   * @example
   * ```typescript
   * const result = await api.getVersion('00000000-0000-0000-0000-000000000000', 'version');
   * ```
   * @openapi operation=getModuleVersionByModuleAndVersion path=/modules/{moduleId}/versions/{version} method=GET
   * @memberof ModuleApi
   */
  getVersion(moduleId: UUID, version: string): Promise<ModuleVersionInfo>;

  /**
   * 
   * @summary Retrieves a list of operations for the given module. The list of operations will contain: * Orderable and Ordered catalog operations. * Active Api operations. * Ordered Operations that have been activated are taken away from this view. * Additionally, Active operations will contain information about operations the ordered operations they are linked to. In most cases, this will be an array of size 1, however this will not always be the case. Operations may be searched by name, using keywords search. The search will match against any operation name or their simbling's (ordered operations linked to api operations) If `latest` is set to true, only Active operations associated with the latest module version will be returned.
   * @param {UUID} moduleId 
   * @param {number} [pageNumber] The requested page. This value is 1-indexed.
   * @param {number} [pageSize] The number of items in each page of data.
   * @param {OperationTypeParam} [type] Filter by operation type. Note: this is deprecated and will be removed in a future release.  Please use the status filter to filter operation by status.
   * @param {string} [name] This filter is now deprecated. Please use the &#x60;keywords&#x60; filter instead. Filters operation name(s). This filter is a text search filter which is based on: * The operation name, and all of it&#39;s linked operation names. * Split up sections of operation names, when those are easily identifiable:

  * i.e. resources.projects.list may be filterd on resource, projects and list
  * resourcesProjectsList may also match the same filters
Search terms may be separated by a space, in which case the search currently assumes a logical AND. * name&#x3D;&quot;resource projects search&quot; &#x3D;&gt; the name(s) must match resource project and search terms
   * @param {OperationStatus} [status] Filter by operation status
   * @param {OpenApiMethod} [method] Filter by HTTP Method. Note that this only applies to active operations.  Orderable and Ordered operations do not yet have a method.
   * @param {Array<string>} [keywords] Keywords to search by. These will match against resource name/description and aliases The following filter uses text search, results will be ordered by relevancy and whichever order/sort parameter was provided alongside. i.e. sort by rank desc, name asc
   * @param {boolean} [latest] Only return &#x60;active&#x60; operations that are present in the latest version of this module. Orderable operations will be filtered out from the result.
   * @param {OrderByParam} [orderBy] Order by the given property
   * @param {SortParam} [sort] The order in which to sort the results, defaults to &#x60;asc&#x60;
   * @param {*} [options] Override http request option.
   * @throws {@link @zerobias-org/types-core-js#ParameterRequiredError} if any required parameter is not provided
   * @example
   * ```typescript
   * const result = await api.listOperations('00000000-0000-0000-0000-000000000000', 1, 1, null, 'name', null, null, null, true, null, null);
   * ```
   * @openapi operation=listModuleOperations path=/modules/{moduleId}/operations method=GET
   * @memberof ModuleApi
   */
  listOperations(moduleId: UUID, pageNumber?: number, pageSize?: number, type?: OperationTypeParamDef, name?: string, status?: OperationStatusDef, method?: OpenApiMethodDef, keywords?: Array<string>, latest?: boolean, orderBy?: OrderByParamDef, sort?: SortParamDef): Promise<PagedResults<Operation>>;

  /**
   * 
   * @summary Retrieves a list of operations that were published by the given module version * All operations returned by this endpoint are `active` api operations. Operations may be searched by name, using keywords search. The search will match against any operation name or their simbling's (catalog operations linked to api operations)
   * @param {UUID} moduleId 
   * @param {string} version Version id or Semantic version
   * @param {number} [pageNumber] The requested page. This value is 1-indexed.
   * @param {number} [pageSize] The number of items in each page of data.
   * @param {string} [name] This filter is now deprecated. Please use the &#x60;keywords&#x60; filter instead. Filters operation name(s). This filter is a text search filter which is based on: * The operation name, and all of it&#39;s linked operation names. * Split up sections of operation names, when those are easily identifiable:

  * i.e. resources.projects.list may be filterd on resource, projects and list
  * resourcesProjectsList may also match the same filters
Search terms may be separated by a space, in which case the search currently assumes a logical AND. * name&#x3D;&quot;resource projects search&quot; &#x3D;&gt; the name(s) must match resource project and search terms
   * @param {OpenApiMethod} [method] Filter by HTTP Method. Note that this only applies to active operations.  Orderable and Ordered operations do not yet have a method.
   * @param {Array<string>} [keywords] Keywords to search by. These will match against resource name/description and aliases The following filter uses text search, results will be ordered by relevancy and whichever order/sort parameter was provided alongside. i.e. sort by rank desc, name asc
   * @param {UUID} [productVersionId] Filter by product version. This filter will list operations that are compatible with both the given module and product versions
   * @param {OrderByParam} [orderBy] Order by the given property
   * @param {SortParam} [sort] The order in which to sort the results, defaults to &#x60;asc&#x60;
   * @param {*} [options] Override http request option.
   * @throws {@link @zerobias-org/types-core-js#ParameterRequiredError} if any required parameter is not provided
   * @example
   * ```typescript
   * const result = await api.listModuleVersionOperations('00000000-0000-0000-0000-000000000000', 'version', 1, 1, 'name', null, null, '00000000-0000-0000-0000-000000000000', null, null);
   * ```
   * @openapi operation=listModuleVersionOperations path=/modules/{moduleId}/versions/{version}/operations method=GET
   * @memberof ModuleApi
   */
  listModuleVersionOperations(moduleId: UUID, version: string, pageNumber?: number, pageSize?: number, name?: string, method?: OpenApiMethodDef, keywords?: Array<string>, productVersionId?: UUID, orderBy?: OrderByParamDef, sort?: SortParamDef): Promise<PagedResults<Operation>>;

  /**
   * 
   * @summary Retrieves a list of module versions for a given module
   * @param {UUID} moduleId 
   * @param {number} [pageNumber] The requested page. This value is 1-indexed.
   * @param {number} [pageSize] The number of items in each page of data.
   * @param {boolean} [fileSupport] List only modules file support active or inactive.
   * @param {boolean} [dataSupport] List only modules data support active or inactive.
   * @param {*} [options] Override http request option.
   * @throws {@link @zerobias-org/types-core-js#ParameterRequiredError} if any required parameter is not provided
   * @example
   * ```typescript
   * const result = await api.listVersions('00000000-0000-0000-0000-000000000000', 1, 1, true, true);
   * ```
   * @openapi operation=listModuleVersions path=/modules/{moduleId}/versions method=GET
   * @memberof ModuleApi
   */
  listVersions(moduleId: UUID, pageNumber?: number, pageSize?: number, fileSupport?: boolean, dataSupport?: boolean): Promise<PagedResults<ModuleVersion>>;

  /**
   * 
   * @summary Retrieves a list of modules
   * @param {number} [pageNumber] The requested page. This value is 1-indexed.
   * @param {number} [pageSize] The number of items in each page of data.
   * @param {ModuleStatus} [status] Filter by module status
   * @param {Array<string>} [packageNames] List only modules compatible with the given product package names.
   * @param {boolean} [fileSupport] List only modules file support active or inactive.
   * @param {boolean} [dataSupport] List only modules data support active or inactive.
   * @param {OrderByParam} [orderBy] Order by the given property
   * @param {SortParam} [sort] The order in which to sort the results, defaults to &#x60;asc&#x60;
   * @param {*} [options] Override http request option.
   * @throws {@link @zerobias-org/types-core-js#ParameterRequiredError} if any required parameter is not provided
   * @example
   * ```typescript
   * const result = await api.list(1, 1, null, null, true, true, null, null);
   * ```
   * @openapi operation=listModules path=/modules method=GET
   * @memberof ModuleApi
   */
  list(pageNumber?: number, pageSize?: number, status?: ModuleStatusDef, packageNames?: Array<string>, fileSupport?: boolean, dataSupport?: boolean, orderBy?: OrderByParamDef, sort?: SortParamDef): Promise<PagedResults<Module>>;

  /**
   * Returns options/filters for modules
   * @summary Returns options/filters for modules
   * @param {*} [options] Override http request option.
   * @throws {@link @zerobias-org/types-core-js#ParameterRequiredError} if any required parameter is not provided
   * @openapi operation=searchModuleOptions path=/moduleSearch/options method=GET
   * @memberof ModuleApi
   */
  searchOptions(): Promise<ResultsColumnOptionsWrapper>;

  /**
   * search modules
   * @summary search modules
   * @param {SearchModuleBody} searchModuleBody 
   * @param {number} [pageNumber] The requested page. This value is 1-indexed.
   * @param {number} [pageSize] The number of items in each page of data.
   * @param {SortObject} [sort] Sort object
   * @param {*} [options] Override http request option.
   * @throws {@link @zerobias-org/types-core-js#ParameterRequiredError} if any required parameter is not provided
   * @example
   * ```typescript
   * const result = await api.search(null, 1, 1, null);
   * ```
   * @openapi operation=searchModules path=/moduleSearch method=POST
   * @memberof ModuleApi
   */
  search(searchModuleBody: SearchModuleBody, pageNumber?: number, pageSize?: number, sort?: SortObject): Promise<PagedResults<ModuleSearch>>;

}

/**
 * ModuleProducerApi - interface
 * Producer interface for Module
 * @export
 * @interface ModuleProducerApi
 */
export interface ModuleProducerApi {
  /**
  * This endpoint generates a report describing the given Module and Version Range.
The moduleKeyOrId can either be:
  - a uuid of an existing module: i.e. 8086f5a7-e0bf-4478-b806-685c6095d1f2
  - a string that identifies the module by its key: i.e. the language specific package for this module. (@devsupply/github)
The output of this endpoint can then be used to feed into hub-server in order to create Modules and Module Versions.
  * @summary Generates a report that describes the given Module and Version Range.
  * @param {string} moduleKeyOrId The module to look for.  Either the module id or its key (@devsupply/github)
  * @param {UUID} [moduleVersionId] A specific version of a module.  The provided moduleVersionId must belong to the given module
  * @param {VersionRange} [version] Version specification for the module
  * @param {*} [options] Override http request option.
  * @throws {@link @zerobias-org/types-core-js#ParameterRequiredError} if any required parameter is not provided
  * @openapi operation=getDependencyReport path=/modules/{moduleKeyOrId}/dependencies method=GET
  * @memberof Module
  */
  getDependencyReport(moduleKeyOrId: string, moduleVersionId?: UUID, version?: VersionRange): Promise<ModuleDependencyReport>;
  /**
  * 
  * @summary Retrieves a module
  * @param {UUID} moduleId 
  * @param {*} [options] Override http request option.
  * @throws {@link @zerobias-org/types-core-js#ParameterRequiredError} if any required parameter is not provided
  * @openapi operation=getModule path=/modules/{moduleId} method=GET
  * @memberof Module
  */
  get(moduleId: UUID): Promise<Module>;
  /**
  * 
  * @summary Retrieves a module version for a given module
  * @param {UUID} moduleId 
  * @param {string} version Version id or Semantic version
  * @param {*} [options] Override http request option.
  * @throws {@link @zerobias-org/types-core-js#ParameterRequiredError} if any required parameter is not provided
  * @openapi operation=getModuleVersionByModuleAndVersion path=/modules/{moduleId}/versions/{version} method=GET
  * @memberof Module
  */
  getVersion(moduleId: UUID, version: string): Promise<ModuleVersionInfo>;
  /**
  * 
  * @summary Retrieves a list of operations for the given module. The list of operations will contain: * Orderable and Ordered catalog operations. * Active Api operations. * Ordered Operations that have been activated are taken away from this view. * Additionally, Active operations will contain information about operations the ordered operations they are linked to. In most cases, this will be an array of size 1, however this will not always be the case. Operations may be searched by name, using keywords search. The search will match against any operation name or their simbling's (ordered operations linked to api operations) If `latest` is set to true, only Active operations associated with the latest module version will be returned.
  * @param {UUID} moduleId 
  * @param {OperationTypeParam} [type] Filter by operation type. Note: this is deprecated and will be removed in a future release.  Please use the status filter to filter operation by status.
  * @param {string} [name] This filter is now deprecated. Please use the &#x60;keywords&#x60; filter instead. Filters operation name(s). This filter is a text search filter which is based on: * The operation name, and all of it&#39;s linked operation names. * Split up sections of operation names, when those are easily identifiable:

  * i.e. resources.projects.list may be filterd on resource, projects and list
  * resourcesProjectsList may also match the same filters
Search terms may be separated by a space, in which case the search currently assumes a logical AND. * name&#x3D;&quot;resource projects search&quot; &#x3D;&gt; the name(s) must match resource project and search terms
  * @param {OperationStatus} [status] Filter by operation status
  * @param {OpenApiMethod} [method] Filter by HTTP Method. Note that this only applies to active operations.  Orderable and Ordered operations do not yet have a method.
  * @param {Array<string>} [keywords] Keywords to search by. These will match against resource name/description and aliases The following filter uses text search, results will be ordered by relevancy and whichever order/sort parameter was provided alongside. i.e. sort by rank desc, name asc
  * @param {boolean} [latest] Only return &#x60;active&#x60; operations that are present in the latest version of this module. Orderable operations will be filtered out from the result.
  * @param {OrderByParam} [orderBy] Order by the given property
  * @param {SortParam} [sort] The order in which to sort the results, defaults to &#x60;asc&#x60;
  * @param {*} [options] Override http request option.
  * @throws {@link @zerobias-org/types-core-js#ParameterRequiredError} if any required parameter is not provided
  * @openapi operation=listModuleOperations path=/modules/{moduleId}/operations method=GET
  * @memberof Module
  */
  listOperations(results: PagedResults<Operation>, moduleId: UUID, type?: OperationTypeParamDef, name?: string, status?: OperationStatusDef, method?: OpenApiMethodDef, keywords?: Array<string>, latest?: boolean, orderBy?: OrderByParamDef, sort?: SortParamDef): Promise<void>;
  /**
  * 
  * @summary Retrieves a list of operations that were published by the given module version * All operations returned by this endpoint are `active` api operations. Operations may be searched by name, using keywords search. The search will match against any operation name or their simbling's (catalog operations linked to api operations)
  * @param {UUID} moduleId 
  * @param {string} version Version id or Semantic version
  * @param {string} [name] This filter is now deprecated. Please use the &#x60;keywords&#x60; filter instead. Filters operation name(s). This filter is a text search filter which is based on: * The operation name, and all of it&#39;s linked operation names. * Split up sections of operation names, when those are easily identifiable:

  * i.e. resources.projects.list may be filterd on resource, projects and list
  * resourcesProjectsList may also match the same filters
Search terms may be separated by a space, in which case the search currently assumes a logical AND. * name&#x3D;&quot;resource projects search&quot; &#x3D;&gt; the name(s) must match resource project and search terms
  * @param {OpenApiMethod} [method] Filter by HTTP Method. Note that this only applies to active operations.  Orderable and Ordered operations do not yet have a method.
  * @param {Array<string>} [keywords] Keywords to search by. These will match against resource name/description and aliases The following filter uses text search, results will be ordered by relevancy and whichever order/sort parameter was provided alongside. i.e. sort by rank desc, name asc
  * @param {UUID} [productVersionId] Filter by product version. This filter will list operations that are compatible with both the given module and product versions
  * @param {OrderByParam} [orderBy] Order by the given property
  * @param {SortParam} [sort] The order in which to sort the results, defaults to &#x60;asc&#x60;
  * @param {*} [options] Override http request option.
  * @throws {@link @zerobias-org/types-core-js#ParameterRequiredError} if any required parameter is not provided
  * @openapi operation=listModuleVersionOperations path=/modules/{moduleId}/versions/{version}/operations method=GET
  * @memberof Module
  */
  listModuleVersionOperations(results: PagedResults<Operation>, moduleId: UUID, version: string, name?: string, method?: OpenApiMethodDef, keywords?: Array<string>, productVersionId?: UUID, orderBy?: OrderByParamDef, sort?: SortParamDef): Promise<void>;
  /**
  * 
  * @summary Retrieves a list of module versions for a given module
  * @param {UUID} moduleId 
  * @param {boolean} [fileSupport] List only modules file support active or inactive.
  * @param {boolean} [dataSupport] List only modules data support active or inactive.
  * @param {*} [options] Override http request option.
  * @throws {@link @zerobias-org/types-core-js#ParameterRequiredError} if any required parameter is not provided
  * @openapi operation=listModuleVersions path=/modules/{moduleId}/versions method=GET
  * @memberof Module
  */
  listVersions(results: PagedResults<ModuleVersion>, moduleId: UUID, fileSupport?: boolean, dataSupport?: boolean): Promise<void>;
  /**
  * 
  * @summary Retrieves a list of modules
  * @param {ModuleStatus} [status] Filter by module status
  * @param {Array<string>} [packageNames] List only modules compatible with the given product package names.
  * @param {boolean} [fileSupport] List only modules file support active or inactive.
  * @param {boolean} [dataSupport] List only modules data support active or inactive.
  * @param {OrderByParam} [orderBy] Order by the given property
  * @param {SortParam} [sort] The order in which to sort the results, defaults to &#x60;asc&#x60;
  * @param {*} [options] Override http request option.
  * @throws {@link @zerobias-org/types-core-js#ParameterRequiredError} if any required parameter is not provided
  * @openapi operation=listModules path=/modules method=GET
  * @memberof Module
  */
  list(results: PagedResults<Module>, status?: ModuleStatusDef, packageNames?: Array<string>, fileSupport?: boolean, dataSupport?: boolean, orderBy?: OrderByParamDef, sort?: SortParamDef): Promise<void>;
  /**
  * Returns options/filters for modules
  * @summary Returns options/filters for modules
  * @param {*} [options] Override http request option.
  * @throws {@link @zerobias-org/types-core-js#ParameterRequiredError} if any required parameter is not provided
  * @openapi operation=searchModuleOptions path=/moduleSearch/options method=GET
  * @memberof Module
  */
  searchOptions(): Promise<ResultsColumnOptionsWrapper>;
  /**
  * search modules
  * @summary search modules
  * @param {SearchModuleBody} searchModuleBody 
  * @param {SortObject} [sort] Sort object
  * @param {*} [options] Override http request option.
  * @throws {@link @zerobias-org/types-core-js#ParameterRequiredError} if any required parameter is not provided
  * @openapi operation=searchModules path=/moduleSearch method=POST
  * @memberof Module
  */
  search(results: PagedResults<ModuleSearch>, searchModuleBody: SearchModuleBody, sort?: SortObject): Promise<void>;
}

export class ModuleApiMappingImpl implements ModuleApi {
  private producer: ModuleProducerApi;
  constructor(producer: ModuleProducerApi) {
    this.producer = producer;
  }

  /**
   * This endpoint generates a report describing the given Module and Version Range.
The moduleKeyOrId can either be:
  - a uuid of an existing module: i.e. 8086f5a7-e0bf-4478-b806-685c6095d1f2
  - a string that identifies the module by its key: i.e. the language specific package for this module. (@devsupply/github)
The output of this endpoint can then be used to feed into hub-server in order to create Modules and Module Versions.
   * @summary Generates a report that describes the given Module and Version Range.
   * @param moduleKeyOrId The module to look for.  Either the module id or its key (@devsupply/github)
   * @param moduleVersionId A specific version of a module.  The provided moduleVersionId must belong to the given module
   * @param version Version specification for the module
   * @openapi operation=getDependencyReport path=/modules/{moduleKeyOrId}/dependencies method=GET
   */
  public async getDependencyReport(moduleKeyOrId: string, moduleVersionId?: UUID, version?: VersionRange): Promise<ModuleDependencyReport> {
    // verify required parameter 'moduleKeyOrId' is not null or undefined
    if (moduleKeyOrId === null || moduleKeyOrId === undefined || moduleKeyOrId === '') {
      throw new ParameterRequiredError('moduleKeyOrId');
    }
    return this.producer.getDependencyReport(moduleKeyOrId, moduleVersionId, version);
  }
  /**
   * 
   * @summary Retrieves a module
   * @param moduleId 
   * @openapi operation=getModule path=/modules/{moduleId} method=GET
   */
  public async get(moduleId: UUID): Promise<Module> {
    // verify required parameter 'moduleId' is not null or undefined
    if (moduleId === null || moduleId === undefined) {
      throw new ParameterRequiredError('moduleId');
    }
    return this.producer.get(moduleId);
  }
  /**
   * 
   * @summary Retrieves a module version for a given module
   * @param moduleId 
   * @param version Version id or Semantic version
   * @openapi operation=getModuleVersionByModuleAndVersion path=/modules/{moduleId}/versions/{version} method=GET
   */
  public async getVersion(moduleId: UUID, version: string): Promise<ModuleVersionInfo> {
    // verify required parameter 'moduleId' is not null or undefined
    if (moduleId === null || moduleId === undefined) {
      throw new ParameterRequiredError('moduleId');
    }
    // verify required parameter 'version' is not null or undefined
    if (version === null || version === undefined || version === '') {
      throw new ParameterRequiredError('version');
    }
    return this.producer.getVersion(moduleId, version);
  }
  /**
   * 
   * @summary Retrieves a list of operations for the given module. The list of operations will contain: * Orderable and Ordered catalog operations. * Active Api operations. * Ordered Operations that have been activated are taken away from this view. * Additionally, Active operations will contain information about operations the ordered operations they are linked to. In most cases, this will be an array of size 1, however this will not always be the case. Operations may be searched by name, using keywords search. The search will match against any operation name or their simbling's (ordered operations linked to api operations) If `latest` is set to true, only Active operations associated with the latest module version will be returned.
   * @param moduleId 
   * @param pageNumber The requested page. This value is 1-indexed.
   * @param pageSize The number of items in each page of data.
   * @param type Filter by operation type. Note: this is deprecated and will be removed in a future release.  Please use the status filter to filter operation by status.
   * @param name This filter is now deprecated. Please use the &#x60;keywords&#x60; filter instead. Filters operation name(s). This filter is a text search filter which is based on: * The operation name, and all of it&#39;s linked operation names. * Split up sections of operation names, when those are easily identifiable:

  * i.e. resources.projects.list may be filterd on resource, projects and list
  * resourcesProjectsList may also match the same filters
Search terms may be separated by a space, in which case the search currently assumes a logical AND. * name&#x3D;&quot;resource projects search&quot; &#x3D;&gt; the name(s) must match resource project and search terms
   * @param status Filter by operation status
   * @param method Filter by HTTP Method. Note that this only applies to active operations.  Orderable and Ordered operations do not yet have a method.
   * @param keywords Keywords to search by. These will match against resource name/description and aliases The following filter uses text search, results will be ordered by relevancy and whichever order/sort parameter was provided alongside. i.e. sort by rank desc, name asc
   * @param latest Only return &#x60;active&#x60; operations that are present in the latest version of this module. Orderable operations will be filtered out from the result.
   * @param orderBy Order by the given property
   * @param sort The order in which to sort the results, defaults to &#x60;asc&#x60;
   * @openapi operation=listModuleOperations path=/modules/{moduleId}/operations method=GET
   */
  public async listOperations(moduleId: UUID, pageNumber: number = 1, pageSize: number = 50, type?: OperationTypeParamDef, name?: string, status?: OperationStatusDef, method?: OpenApiMethodDef, keywords?: Array<string>, latest: boolean = false, orderBy?: OrderByParamDef, sort?: SortParamDef): Promise<PagedResults<Operation>> {
    // verify required parameter 'moduleId' is not null or undefined
    if (moduleId === null || moduleId === undefined) {
      throw new ParameterRequiredError('moduleId');
    }
    if (pageNumber) {
      await Int32.parse(pageNumber);
    }
    if (pageSize) {
      await Int32.parse(pageSize);
    }
    const bag = new PagedResults<Operation>();
    bag.pageNumber = pageNumber;
    bag.pageSize = pageSize;
    await this.producer.listOperations(bag, moduleId, type, name, status, method, keywords, latest, orderBy, sort);
    if (bag.items === null || bag.items === undefined) {
      throw new UnexpectedError("Producers must return 'items' for PagedResults queries");
    }
    return bag;
  }
  /**
   * 
   * @summary Retrieves a list of operations that were published by the given module version * All operations returned by this endpoint are `active` api operations. Operations may be searched by name, using keywords search. The search will match against any operation name or their simbling's (catalog operations linked to api operations)
   * @param moduleId 
   * @param version Version id or Semantic version
   * @param pageNumber The requested page. This value is 1-indexed.
   * @param pageSize The number of items in each page of data.
   * @param name This filter is now deprecated. Please use the &#x60;keywords&#x60; filter instead. Filters operation name(s). This filter is a text search filter which is based on: * The operation name, and all of it&#39;s linked operation names. * Split up sections of operation names, when those are easily identifiable:

  * i.e. resources.projects.list may be filterd on resource, projects and list
  * resourcesProjectsList may also match the same filters
Search terms may be separated by a space, in which case the search currently assumes a logical AND. * name&#x3D;&quot;resource projects search&quot; &#x3D;&gt; the name(s) must match resource project and search terms
   * @param method Filter by HTTP Method. Note that this only applies to active operations.  Orderable and Ordered operations do not yet have a method.
   * @param keywords Keywords to search by. These will match against resource name/description and aliases The following filter uses text search, results will be ordered by relevancy and whichever order/sort parameter was provided alongside. i.e. sort by rank desc, name asc
   * @param productVersionId Filter by product version. This filter will list operations that are compatible with both the given module and product versions
   * @param orderBy Order by the given property
   * @param sort The order in which to sort the results, defaults to &#x60;asc&#x60;
   * @openapi operation=listModuleVersionOperations path=/modules/{moduleId}/versions/{version}/operations method=GET
   */
  public async listModuleVersionOperations(moduleId: UUID, version: string, pageNumber: number = 1, pageSize: number = 50, name?: string, method?: OpenApiMethodDef, keywords?: Array<string>, productVersionId?: UUID, orderBy?: OrderByParamDef, sort?: SortParamDef): Promise<PagedResults<Operation>> {
    // verify required parameter 'moduleId' is not null or undefined
    if (moduleId === null || moduleId === undefined) {
      throw new ParameterRequiredError('moduleId');
    }
    // verify required parameter 'version' is not null or undefined
    if (version === null || version === undefined || version === '') {
      throw new ParameterRequiredError('version');
    }
    if (pageNumber) {
      await Int32.parse(pageNumber);
    }
    if (pageSize) {
      await Int32.parse(pageSize);
    }
    const bag = new PagedResults<Operation>();
    bag.pageNumber = pageNumber;
    bag.pageSize = pageSize;
    await this.producer.listModuleVersionOperations(bag, moduleId, version, name, method, keywords, productVersionId, orderBy, sort);
    if (bag.items === null || bag.items === undefined) {
      throw new UnexpectedError("Producers must return 'items' for PagedResults queries");
    }
    return bag;
  }
  /**
   * 
   * @summary Retrieves a list of module versions for a given module
   * @param moduleId 
   * @param pageNumber The requested page. This value is 1-indexed.
   * @param pageSize The number of items in each page of data.
   * @param fileSupport List only modules file support active or inactive.
   * @param dataSupport List only modules data support active or inactive.
   * @openapi operation=listModuleVersions path=/modules/{moduleId}/versions method=GET
   */
  public async listVersions(moduleId: UUID, pageNumber: number = 1, pageSize: number = 50, fileSupport?: boolean, dataSupport?: boolean): Promise<PagedResults<ModuleVersion>> {
    // verify required parameter 'moduleId' is not null or undefined
    if (moduleId === null || moduleId === undefined) {
      throw new ParameterRequiredError('moduleId');
    }
    if (pageNumber) {
      await Int32.parse(pageNumber);
    }
    if (pageSize) {
      await Int32.parse(pageSize);
    }
    const bag = new PagedResults<ModuleVersion>();
    bag.pageNumber = pageNumber;
    bag.pageSize = pageSize;
    await this.producer.listVersions(bag, moduleId, fileSupport, dataSupport);
    if (bag.items === null || bag.items === undefined) {
      throw new UnexpectedError("Producers must return 'items' for PagedResults queries");
    }
    return bag;
  }
  /**
   * 
   * @summary Retrieves a list of modules
   * @param pageNumber The requested page. This value is 1-indexed.
   * @param pageSize The number of items in each page of data.
   * @param status Filter by module status
   * @param packageNames List only modules compatible with the given product package names.
   * @param fileSupport List only modules file support active or inactive.
   * @param dataSupport List only modules data support active or inactive.
   * @param orderBy Order by the given property
   * @param sort The order in which to sort the results, defaults to &#x60;asc&#x60;
   * @openapi operation=listModules path=/modules method=GET
   */
  public async list(pageNumber: number = 1, pageSize: number = 50, status?: ModuleStatusDef, packageNames?: Array<string>, fileSupport?: boolean, dataSupport?: boolean, orderBy?: OrderByParamDef, sort?: SortParamDef): Promise<PagedResults<Module>> {
    if (pageNumber) {
      await Int32.parse(pageNumber);
    }
    if (pageSize) {
      await Int32.parse(pageSize);
    }
    const bag = new PagedResults<Module>();
    bag.pageNumber = pageNumber;
    bag.pageSize = pageSize;
    await this.producer.list(bag, status, packageNames, fileSupport, dataSupport, orderBy, sort);
    if (bag.items === null || bag.items === undefined) {
      throw new UnexpectedError("Producers must return 'items' for PagedResults queries");
    }
    return bag;
  }
  /**
   * Returns options/filters for modules
   * @summary Returns options/filters for modules
   * @openapi operation=searchModuleOptions path=/moduleSearch/options method=GET
   */
  public async searchOptions(): Promise<ResultsColumnOptionsWrapper> {
    return this.producer.searchOptions();
  }
  /**
   * search modules
   * @summary search modules
   * @param searchModuleBody 
   * @param pageNumber The requested page. This value is 1-indexed.
   * @param pageSize The number of items in each page of data.
   * @param sort Sort object
   * @openapi operation=searchModules path=/moduleSearch method=POST
   */
  public async search(searchModuleBody: SearchModuleBody, pageNumber: number = 1, pageSize: number = 50, sort?: SortObject): Promise<PagedResults<ModuleSearch>> {
    // verify required parameter 'searchModuleBody' is not null or undefined
    if (searchModuleBody === null || searchModuleBody === undefined) {
      throw new ParameterRequiredError('searchModuleBody');
    }
    if (pageNumber) {
      await Int32.parse(pageNumber);
    }
    if (pageSize) {
      await Int32.parse(pageSize);
    }
    const bag = new PagedResults<ModuleSearch>();
    bag.pageNumber = pageNumber;
    bag.pageSize = pageSize;
    await this.producer.search(bag, searchModuleBody, sort);
    if (bag.items === null || bag.items === undefined) {
      throw new UnexpectedError("Producers must return 'items' for PagedResults queries");
    }
    return bag;
  }
}

/**
 * Wrap producer with mapping implementation
 */
export function wrapModuleProducer(producer: ModuleProducerApi): ModuleApi {
  return new ModuleApiMappingImpl(producer);
}

/**
 * ModuleApiHttpImpl - Direct HTTP implementation
 *
 * Makes direct HTTP calls to the API using Axios.
 * Used by SDK clients for platform service access.
 */
export class ModuleApiHttpImpl implements ModuleProducerApi {
  private client: AxiosInstance;
  private headers: Record<string, string>;

  constructor(client: AxiosInstance, headers: Record<string, string> = {}) {
    this.client = client;
    this.headers = headers;
  }

  async getDependencyReport(moduleKeyOrId: string, moduleVersionId?: UUID, version?: VersionRange): Promise<ModuleDependencyReport> {
  const _queryParams = {
      moduleVersionId,version,
  };
  const _bodyParams = {
      
  };
  let _path = '/modules/{moduleKeyOrId}/dependencies';
  _path = _path.replace('{moduleKeyOrId}', encodeURIComponent(String(moduleKeyOrId)));
  return this.client.get(
    _path,
    { params: _queryParams })
    .then((response) => {
      // BaseApiClient uses validateStatus: () => true, so we must check status manually
      if (response.status >= 400) {
        throw CoreError.deserialize(response.data);
      }
      return ObjectSerializer.deserialize(response.data, 'ModuleDependencyReport')
    })
    .catch((error) => {
      if (error.data) {
        throw CoreError.deserialize(error.data);
      } else {
        throw error;
      }
    });
  }
  async get(moduleId: UUID): Promise<Module> {
  const _queryParams = {
      
  };
  const _bodyParams = {
      
  };
  let _path = '/modules/{moduleId}';
  _path = _path.replace('{moduleId}', encodeURIComponent(String(moduleId)));
  return this.client.get(
    _path,
    { params: _queryParams })
    .then((response) => {
      // BaseApiClient uses validateStatus: () => true, so we must check status manually
      if (response.status >= 400) {
        throw CoreError.deserialize(response.data);
      }
      return ObjectSerializer.deserialize(response.data, 'Module')
    })
    .catch((error) => {
      if (error.data) {
        throw CoreError.deserialize(error.data);
      } else {
        throw error;
      }
    });
  }
  async getVersion(moduleId: UUID, version: string): Promise<ModuleVersionInfo> {
  const _queryParams = {
      
  };
  const _bodyParams = {
      
  };
  let _path = '/modules/{moduleId}/versions/{version}';
  _path = _path.replace('{moduleId}', encodeURIComponent(String(moduleId)));
  _path = _path.replace('{version}', encodeURIComponent(String(version)));
  return this.client.get(
    _path,
    { params: _queryParams })
    .then((response) => {
      // BaseApiClient uses validateStatus: () => true, so we must check status manually
      if (response.status >= 400) {
        throw CoreError.deserialize(response.data);
      }
      return ObjectSerializer.deserialize(response.data, 'ModuleVersionInfo')
    })
    .catch((error) => {
      if (error.data) {
        throw CoreError.deserialize(error.data);
      } else {
        throw error;
      }
    });
  }
  async listOperations(results: PagedResults<Operation>, moduleId: UUID, type?: OperationTypeParamDef, name?: string, status?: OperationStatusDef, method?: OpenApiMethodDef, keywords?: Array<string>, latest?: boolean, orderBy?: OrderByParamDef, sort?: SortParamDef): Promise<void> {
  const _body = {
      moduleId,type,name,status,method,keywords,latest,orderBy,sort,
  };
  let _path = '/modules/{moduleId}/operations';
  _path = _path.replace('{moduleId}', encodeURIComponent(String(moduleId)));
  return this.client.get(
    _path,
    {
      params: {
        ..._body,
        pageNumber: results.pageNumber,
        pageSize: results.pageSize,
      }
    })
    .then((response) => {
      // BaseApiClient uses validateStatus: () => true, so we must check status manually
      if (response.status >= 400) {
        throw CoreError.deserialize(response.data);
      }
      results.items = ObjectSerializer.deserialize(response.data, 'Array<Operation>');
      results.count = response.headers.count ? Number(response.headers.count) : -1;
      results.pageToken = response.headers.pagetoken ?? response.headers.pageToken;
      results.headers = this.headers;
      results.baseUrl = new URL(`${this.client.getUri()}/modules/{moduleId}/operations`);
      results.httpMethod = HttpMethod.Get;
      results.body = _body;
      results.mapper = (obj) => ObjectSerializer.deserialize(obj, 'Operation');
    })
    .catch((error) => {
      if (error.data) {
        throw CoreError.deserialize(error.data);
      } else {
        throw error;
      }
    });
  }
  async listModuleVersionOperations(results: PagedResults<Operation>, moduleId: UUID, version: string, name?: string, method?: OpenApiMethodDef, keywords?: Array<string>, productVersionId?: UUID, orderBy?: OrderByParamDef, sort?: SortParamDef): Promise<void> {
  const _body = {
      moduleId,version,name,method,keywords,productVersionId,orderBy,sort,
  };
  let _path = '/modules/{moduleId}/versions/{version}/operations';
  _path = _path.replace('{moduleId}', encodeURIComponent(String(moduleId)));
  _path = _path.replace('{version}', encodeURIComponent(String(version)));
  return this.client.get(
    _path,
    {
      params: {
        ..._body,
        pageNumber: results.pageNumber,
        pageSize: results.pageSize,
      }
    })
    .then((response) => {
      // BaseApiClient uses validateStatus: () => true, so we must check status manually
      if (response.status >= 400) {
        throw CoreError.deserialize(response.data);
      }
      results.items = ObjectSerializer.deserialize(response.data, 'Array<Operation>');
      results.count = response.headers.count ? Number(response.headers.count) : -1;
      results.pageToken = response.headers.pagetoken ?? response.headers.pageToken;
      results.headers = this.headers;
      results.baseUrl = new URL(`${this.client.getUri()}/modules/{moduleId}/versions/{version}/operations`);
      results.httpMethod = HttpMethod.Get;
      results.body = _body;
      results.mapper = (obj) => ObjectSerializer.deserialize(obj, 'Operation');
    })
    .catch((error) => {
      if (error.data) {
        throw CoreError.deserialize(error.data);
      } else {
        throw error;
      }
    });
  }
  async listVersions(results: PagedResults<ModuleVersion>, moduleId: UUID, fileSupport?: boolean, dataSupport?: boolean): Promise<void> {
  const _body = {
      moduleId,fileSupport,dataSupport,
  };
  let _path = '/modules/{moduleId}/versions';
  _path = _path.replace('{moduleId}', encodeURIComponent(String(moduleId)));
  return this.client.get(
    _path,
    {
      params: {
        ..._body,
        pageNumber: results.pageNumber,
        pageSize: results.pageSize,
      }
    })
    .then((response) => {
      // BaseApiClient uses validateStatus: () => true, so we must check status manually
      if (response.status >= 400) {
        throw CoreError.deserialize(response.data);
      }
      results.items = ObjectSerializer.deserialize(response.data, 'Array<ModuleVersion>');
      results.count = response.headers.count ? Number(response.headers.count) : -1;
      results.pageToken = response.headers.pagetoken ?? response.headers.pageToken;
      results.headers = this.headers;
      results.baseUrl = new URL(`${this.client.getUri()}/modules/{moduleId}/versions`);
      results.httpMethod = HttpMethod.Get;
      results.body = _body;
      results.mapper = (obj) => ObjectSerializer.deserialize(obj, 'ModuleVersion');
    })
    .catch((error) => {
      if (error.data) {
        throw CoreError.deserialize(error.data);
      } else {
        throw error;
      }
    });
  }
  async list(results: PagedResults<Module>, status?: ModuleStatusDef, packageNames?: Array<string>, fileSupport?: boolean, dataSupport?: boolean, orderBy?: OrderByParamDef, sort?: SortParamDef): Promise<void> {
  const _body = {
      status,packageNames,fileSupport,dataSupport,orderBy,sort,
  };
  let _path = '/modules';
  return this.client.get(
    _path,
    {
      params: {
        ..._body,
        pageNumber: results.pageNumber,
        pageSize: results.pageSize,
      }
    })
    .then((response) => {
      // BaseApiClient uses validateStatus: () => true, so we must check status manually
      if (response.status >= 400) {
        throw CoreError.deserialize(response.data);
      }
      results.items = ObjectSerializer.deserialize(response.data, 'Array<Module>');
      results.count = response.headers.count ? Number(response.headers.count) : -1;
      results.pageToken = response.headers.pagetoken ?? response.headers.pageToken;
      results.headers = this.headers;
      results.baseUrl = new URL(`${this.client.getUri()}/modules`);
      results.httpMethod = HttpMethod.Get;
      results.body = _body;
      results.mapper = (obj) => ObjectSerializer.deserialize(obj, 'Module');
    })
    .catch((error) => {
      if (error.data) {
        throw CoreError.deserialize(error.data);
      } else {
        throw error;
      }
    });
  }
  async searchOptions(): Promise<ResultsColumnOptionsWrapper> {
  const _queryParams = {
      
  };
  const _bodyParams = {
      
  };
  let _path = '/moduleSearch/options';
  return this.client.get(
    _path,
    { params: _queryParams })
    .then((response) => {
      // BaseApiClient uses validateStatus: () => true, so we must check status manually
      if (response.status >= 400) {
        throw CoreError.deserialize(response.data);
      }
      return ObjectSerializer.deserialize(response.data, 'ResultsColumnOptionsWrapper')
    })
    .catch((error) => {
      if (error.data) {
        throw CoreError.deserialize(error.data);
      } else {
        throw error;
      }
    });
  }
  async search(results: PagedResults<ModuleSearch>, searchModuleBody: SearchModuleBody, sort?: SortObject): Promise<void> {
  const _body = {
      searchModuleBody,sort,
  };
  let _path = '/moduleSearch';
  return this.client.post(
    _path,
    {
      ..._body,
      pageNumber: results.pageNumber,
      pageSize: results.pageSize,
    })
    .then((response) => {
      // BaseApiClient uses validateStatus: () => true, so we must check status manually
      if (response.status >= 400) {
        throw CoreError.deserialize(response.data);
      }
      results.items = ObjectSerializer.deserialize(response.data, 'Array<ModuleSearch>');
      results.count = response.headers.count ? Number(response.headers.count) : -1;
      results.pageToken = response.headers.pagetoken ?? response.headers.pageToken;
      results.headers = this.headers;
      results.baseUrl = new URL(`${this.client.getUri()}/moduleSearch`);
      results.httpMethod = HttpMethod.Post;
      results.body = _body;
      results.mapper = (obj) => ObjectSerializer.deserialize(obj, 'ModuleSearch');
    })
    .catch((error) => {
      if (error.data) {
        throw CoreError.deserialize(error.data);
      } else {
        throw error;
      }
    });
  }
}
