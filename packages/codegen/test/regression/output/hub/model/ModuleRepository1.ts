/* eslint-disable */
// ===============================================
// This file is autogenerated - Please do not edit
// ===============================================
import { EnumValue, IllegalArgumentError } from '@zerobias-org/types-core-js';
import { ObjectSerializer, RequestFile } from './index.js';

/**
* Description of where to locate a module version
*/
export class ModuleRepository1 {
  /**
  * The type of repository
  */
  'type': ModuleRepository1.TypeEnumDef;
  /**
  * Location string for the repository. Content is dependent on `type` - `npm`: the `location` string should be an NPM package name that the Hub server can resolve
  */
  'location': any | null;

  static readonly discriminator: string | undefined = undefined;

  static attributeTypeMap: ReadonlyArray<{name: string, baseName: string, type: string, format: string}> = [
    {
      "name": "type",
      "baseName": "type",
      // true
      // ModuleRepository1.TypeEnum
      // ModuleRepository1.TypeEnumDef
      "type": "ModuleRepository1.TypeEnum",
      "format": ""
    },
    {
      "name": "location",
      "baseName": "location",
      // false
      // any
      // any
      "type": "any",
      "format": ""
    }  ];

  static getAttributeTypeMap() {
    return ModuleRepository1.attributeTypeMap;
  }

  static newInstance(obj: any): ModuleRepository1 {
    return ObjectSerializer.deserialize(obj, 'ModuleRepository1');
  }

  constructor(type: ModuleRepository1.TypeEnumDef, location: any, ) {
    this.type = type;
    this.location = location;
  }
}

export namespace ModuleRepository1 {
  export const TypeEnum = {
    /**  */
    Npm: EnumValue.instance('ModuleRepository1.TypeEnum', 'Npm', 'npm'),

    from(val: string | number): EnumValue {
      if (TypeEnum[val]) {
        return TypeEnum[val];
      }
      const byValue = TypeEnum.values.find((v) => v.value === val);
      if (byValue) {
        return byValue;
      }
      throw new IllegalArgumentError(`${val} is not a valid TypeEnum`);
    },

    get values(): EnumValue[] {
      return Object
        .keys(TypeEnum)
        .filter((k) => k !== 'values' && k !== 'from')
        .map((t) => TypeEnum[t]);
    }
  } as const;

  export type TypeEnumDef = typeof TypeEnum[keyof typeof TypeEnum];
}
