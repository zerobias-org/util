/* eslint-disable */
// ===============================================
// This file is autogenerated - Please do not edit
// ===============================================
import { AlertFilterDef } from './AlertFilter.js';
import { AlertFilter } from './AlertFilter.js';
import { SchemasCondition } from './SchemasCondition.js';
import { Nmtoken, UUID } from '@zerobias-org/types-core-js';
import { ObjectSerializer, RequestFile } from './index.js';

/**
* Filters to apply when searching for resources
*/
export class ResourceSearchFilter {
  /**
  * Resource Type to search for. These will be combined as an `or`
  */
  'types'?: Array<Nmtoken>;
  /**
  * Keywords to search by. These will be combined as an `or`
  */
  'keywords'?: Array<string>;
  /**
  * Names of tags to search for. These will be combined as an `or`
  */
  'tags'?: Array<Nmtoken>;
  /**
  * Flag indicating whether or not the result set should be fully-inflated. This may be used in conjunction with the `conditions` filter
  */
  'inflate'?: boolean;
  /**
  * A set of conditions to match resources against. These will be combined as an `or` Conditions are evaluated against the inflated resource payload.  This parameter must be used with `inflate=true`.
  */
  'conditions'?: Array<SchemasCondition>;
  'alerts'?: AlertFilterDef;
  /**
  * A boundary that contains all resources which this search applies to. (not implemented)
  */
  'boundaryId'?: Array<UUID>;

  static readonly discriminator: string | undefined = undefined;

  static attributeTypeMap: ReadonlyArray<{name: string, baseName: string, type: string, format: string}> = [
    {
      "name": "types",
      "baseName": "types",
      // false
      // Array&lt;Nmtoken&gt;
      // Array&lt;Nmtoken&gt;
      "type": "Array<Nmtoken>",
      "format": "nmtoken"
    },
    {
      "name": "keywords",
      "baseName": "keywords",
      // false
      // Array&lt;string&gt;
      // Array&lt;string&gt;
      "type": "Array<string>",
      "format": ""
    },
    {
      "name": "tags",
      "baseName": "tags",
      // false
      // Array&lt;Nmtoken&gt;
      // Array&lt;Nmtoken&gt;
      "type": "Array<Nmtoken>",
      "format": "nmtoken"
    },
    {
      "name": "inflate",
      "baseName": "inflate",
      // false
      // boolean
      // boolean
      "type": "boolean",
      "format": ""
    },
    {
      "name": "conditions",
      "baseName": "conditions",
      // false
      // Array&lt;SchemasCondition&gt;
      // Array&lt;SchemasCondition&gt;
      "type": "Array<SchemasCondition>",
      "format": ""
    },
    {
      "name": "alerts",
      "baseName": "alerts",
      // false
      // AlertFilter
      // AlertFilterDef
      "type": "AlertFilter",
      "format": ""
    },
    {
      "name": "boundaryId",
      "baseName": "boundaryId",
      // false
      // Array&lt;UUID&gt;
      // Array&lt;UUID&gt;
      "type": "Array<UUID>",
      "format": "uuid"
    }  ];

  static getAttributeTypeMap() {
    return ResourceSearchFilter.attributeTypeMap;
  }

  static newInstance(obj: any): ResourceSearchFilter {
    return ObjectSerializer.deserialize(obj, 'ResourceSearchFilter');
  }

  constructor(types?: Array<Nmtoken>, keywords?: Array<string>, tags?: Array<Nmtoken>, inflate?: boolean, conditions?: Array<SchemasCondition>, alerts?: AlertFilterDef, boundaryId?: Array<UUID>) {
    this.types = types;
    this.keywords = keywords;
    this.tags = tags;
    this.inflate = inflate;
    this.conditions = conditions;
    this.alerts = alerts;
    this.boundaryId = boundaryId;
  }
}

