/* eslint-disable */
// ===============================================
// This file is autogenerated - Please do not edit
// ===============================================
import { EnumValue, IllegalArgumentError } from '@zerobias-org/types-core-js';
import { ObjectSerializer, RequestFile } from './index.js';

export class Condition {
  /**
  * The name of the property in a jsonpath simplified format. example:






























































































  ```
  {
    "name": "foo",
    "children": [
      {
        "name": bar
      },
      {
        "name": baz
      }
    ]
  }
  ```
- "name": will match against the top level `name` property only. i.e. `foo` - "children.name": will match against `name` items inside of the `children` array: i.e. ["bar", "baz"]
  */
  'property': string;
  /**
  * The set of operations that may be provided when evaluating conditions.
  */
  'operation': Condition.OperationEnumDef;
  /**
  * the value or set of values to match the condition against. An array may be specified for the following operations:






























































































  * any_of
  * one_of
  * none_of
  * all_of
  */
  'value'?: string | number | boolean | Array<string | number | boolean> | null;

  static readonly discriminator: string | undefined = undefined;

  static attributeTypeMap: ReadonlyArray<{name: string, baseName: string, type: string, format: string}> = [
    {
      "name": "property",
      "baseName": "property",
      // false
      // string
      // string
      "type": "string",
      "format": ""
    },
    {
      "name": "operation",
      "baseName": "operation",
      // true
      // Condition.OperationEnum
      // Condition.OperationEnumDef
      "type": "Condition.OperationEnum",
      "format": ""
    },
    {
      "name": "value",
      "baseName": "value",
      // false
      // string | number | boolean | Array&lt;string | number | boolean&gt;
      // string | number | boolean | Array&lt;string | number | boolean&gt;
      "type": "string | number | boolean | Array<string | number | boolean>",
      "format": ""
    }  ];

  static getAttributeTypeMap() {
    return Condition.attributeTypeMap;
  }

  static newInstance(obj: any): Condition {
    return ObjectSerializer.deserialize(obj, 'Condition');
  }

  constructor(property: string, operation: Condition.OperationEnumDef, value?: string | number | boolean | Array<string | number | boolean>) {
    this.property = property;
    this.operation = operation;
    this.value = value;
  }
}

export namespace Condition {
  export const OperationEnum = {
    /** the given property &#x60;exists&#x60; and its value may be null or an empty array. */
    Exists: EnumValue.instance('Condition.OperationEnum', 'Exists', 'exists'),
    /** the given property does not exist. */
    DoesNotExist: EnumValue.instance('Condition.OperationEnum', 'DoesNotExist', 'does_not_exist'),
    /** the given property &#x60;exists&#x60; and is not null or a non-zero length array. */
    IsDefined: EnumValue.instance('Condition.OperationEnum', 'IsDefined', 'is_defined'),
    /** the given property exists and is null. */
    IsUndefined: EnumValue.instance('Condition.OperationEnum', 'IsUndefined', 'is_undefined'),
    /** the given property is an exact match. */
    Equals: EnumValue.instance('Condition.OperationEnum', 'Equals', 'equals'),
    /** the given property is not an exact match. */
    NotEquals: EnumValue.instance('Condition.OperationEnum', 'NotEquals', 'not_equals'),
    /** the given property is an exact match ignoring case. */
    EqualsIc: EnumValue.instance('Condition.OperationEnum', 'EqualsIc', 'equals_ic'),
    /** the given property is not an exact match ignoring case. */
    NotEqualsIc: EnumValue.instance('Condition.OperationEnum', 'NotEqualsIc', 'not_equals_ic'),
    /** the given value matches a regular expression using * on either side. */
    Like: EnumValue.instance('Condition.OperationEnum', 'Like', 'like'),
    /** the given value does not match a regular expression using * on either side. */
    NotLike: EnumValue.instance('Condition.OperationEnum', 'NotLike', 'not_like'),
    /** the given value matches a regular expression using *, ignoring case. */
    LikeIc: EnumValue.instance('Condition.OperationEnum', 'LikeIc', 'like_ic'),
    /** the given value does not match a regular expression using *, ignoring case. */
    NotLikeIc: EnumValue.instance('Condition.OperationEnum', 'NotLikeIc', 'not_like_ic'),
    /** the given property is a number greater than or equals to value. */
    AtLeast: EnumValue.instance('Condition.OperationEnum', 'AtLeast', 'at_least'),
    /** the given property is a number less than or equals to value. */
    AtMost: EnumValue.instance('Condition.OperationEnum', 'AtMost', 'at_most'),
    /** the given property is an array and its size matches the given value. */
    LengthEquals: EnumValue.instance('Condition.OperationEnum', 'LengthEquals', 'length_equals'),
    /** the given property is an array of size less than or equals to value. */
    LengthAtMost: EnumValue.instance('Condition.OperationEnum', 'LengthAtMost', 'length_at_most'),
    /** the given property is an array of size greater than or equals to value. */
    LengthAtLeast: EnumValue.instance('Condition.OperationEnum', 'LengthAtLeast', 'length_at_least'),
    /** the given property is an array and contains any of the given values. */
    AnyOf: EnumValue.instance('Condition.OperationEnum', 'AnyOf', 'any_of'),
    /** the given property is an array and contains none of the given values. */
    NoneOf: EnumValue.instance('Condition.OperationEnum', 'NoneOf', 'none_of'),
    /** the given property is an array and contains all of the given values. */
    AllOf: EnumValue.instance('Condition.OperationEnum', 'AllOf', 'all_of'),

    from(val: string | number): EnumValue {
      if (OperationEnum[val]) {
        return OperationEnum[val];
      }
      const byValue = OperationEnum.values.find((v) => v.value === val);
      if (byValue) {
        return byValue;
      }
      throw new IllegalArgumentError(`${val} is not a valid OperationEnum`);
    },

    get values(): EnumValue[] {
      return Object
        .keys(OperationEnum)
        .filter((k) => k !== 'values' && k !== 'from')
        .map((t) => OperationEnum[t]);
    }
  } as const;

  export type OperationEnumDef = typeof OperationEnum[keyof typeof OperationEnum];
}
