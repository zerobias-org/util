/* eslint-disable */
// ===============================================
// This file is autogenerated - Please do not edit
// ===============================================
import { EnumValue, IllegalArgumentError } from '@zerobias-org/types-core-js';
import { ObjectSerializer, RequestFile } from './index.js';

/**
* Various environment settings from the node's host.
*/
export class HandshakeEnvironment {
  /**
  * Name of the operating system on the node's host.
  */
  'osName'?: string;
  /**
  * Version of the operating system running on the node's host
  */
  'osVersion'?: string;
  'arch'?: HandshakeEnvironment.ArchEnumDef;

  static readonly discriminator: string | undefined = undefined;

  static attributeTypeMap: ReadonlyArray<{name: string, baseName: string, type: string, format: string}> = [
    {
      "name": "osName",
      "baseName": "osName",
      // false
      // string
      // string
      "type": "string",
      "format": ""
    },
    {
      "name": "osVersion",
      "baseName": "osVersion",
      // false
      // string
      // string
      "type": "string",
      "format": ""
    },
    {
      "name": "arch",
      "baseName": "arch",
      // true
      // HandshakeEnvironment.ArchEnum
      // HandshakeEnvironment.ArchEnumDef
      "type": "HandshakeEnvironment.ArchEnum",
      "format": ""
    }  ];

  static getAttributeTypeMap() {
    return HandshakeEnvironment.attributeTypeMap;
  }

  static newInstance(obj: any): HandshakeEnvironment {
    return ObjectSerializer.deserialize(obj, 'HandshakeEnvironment');
  }

  constructor(osName?: string, osVersion?: string, arch?: HandshakeEnvironment.ArchEnumDef) {
    this.osName = osName;
    this.osVersion = osVersion;
    this.arch = arch;
  }
}

export namespace HandshakeEnvironment {
  export const ArchEnum = {
    /**  */
    Arm: EnumValue.instance('HandshakeEnvironment.ArchEnum', 'Arm', 'arm'),
    /**  */
    Arm64: EnumValue.instance('HandshakeEnvironment.ArchEnum', 'Arm64', 'arm64'),
    /**  */
    Ia32: EnumValue.instance('HandshakeEnvironment.ArchEnum', 'Ia32', 'ia32'),
    /**  */
    Mips: EnumValue.instance('HandshakeEnvironment.ArchEnum', 'Mips', 'mips'),
    /**  */
    Mipsel: EnumValue.instance('HandshakeEnvironment.ArchEnum', 'Mipsel', 'mipsel'),
    /**  */
    Ppc: EnumValue.instance('HandshakeEnvironment.ArchEnum', 'Ppc', 'ppc'),
    /**  */
    Ppc64: EnumValue.instance('HandshakeEnvironment.ArchEnum', 'Ppc64', 'ppc64'),
    /**  */
    S390: EnumValue.instance('HandshakeEnvironment.ArchEnum', 'S390', 's390'),
    /**  */
    S390x: EnumValue.instance('HandshakeEnvironment.ArchEnum', 'S390x', 's390x'),
    /**  */
    X32: EnumValue.instance('HandshakeEnvironment.ArchEnum', 'X32', 'x32'),
    /**  */
    X64: EnumValue.instance('HandshakeEnvironment.ArchEnum', 'X64', 'x64'),

    from(val: string | number): EnumValue {
      if (ArchEnum[val]) {
        return ArchEnum[val];
      }
      const byValue = ArchEnum.values.find((v) => v.value === val);
      if (byValue) {
        return byValue;
      }
      throw new IllegalArgumentError(`${val} is not a valid ArchEnum`);
    },

    get values(): EnumValue[] {
      return Object
        .keys(ArchEnum)
        .filter((k) => k !== 'values' && k !== 'from')
        .map((t) => ArchEnum[t]);
    }
  } as const;

  export type ArchEnumDef = typeof ArchEnum[keyof typeof ArchEnum];
}
