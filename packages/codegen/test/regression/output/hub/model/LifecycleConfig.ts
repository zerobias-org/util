/* eslint-disable */
// ===============================================
// This file is autogenerated - Please do not edit
// ===============================================
import { RetryPolicy } from './RetryPolicy.js';
import { EnumValue, IllegalArgumentError, Duration } from '@zerobias-org/types-core-js';
import { ObjectSerializer, RequestFile } from './index.js';

/**
* A connection to a specific system for a Deployment
*/
export class LifecycleConfig {
  /**
  * Describes how this connection is managed
  */
  'mode': LifecycleConfig.ModeEnumDef;
  /**
  * Time after which connections will be closed in automatic mode. Required if mode is `auto`
  */
  'idleTimeout'?: Duration;
  'retryPolicy'?: RetryPolicy;

  static readonly discriminator: string | undefined = undefined;

  static attributeTypeMap: ReadonlyArray<{name: string, baseName: string, type: string, format: string}> = [
    {
      "name": "mode",
      "baseName": "mode",
      // true
      // LifecycleConfig.ModeEnum
      // LifecycleConfig.ModeEnumDef
      "type": "LifecycleConfig.ModeEnum",
      "format": ""
    },
    {
      "name": "idleTimeout",
      "baseName": "idleTimeout",
      // false
      // Duration
      // Duration
      "type": "Duration",
      "format": "duration"
    },
    {
      "name": "retryPolicy",
      "baseName": "retryPolicy",
      // false
      // RetryPolicy
      // RetryPolicy
      "type": "RetryPolicy",
      "format": ""
    }  ];

  static getAttributeTypeMap() {
    return LifecycleConfig.attributeTypeMap;
  }

  static newInstance(obj: any): LifecycleConfig {
    return ObjectSerializer.deserialize(obj, 'LifecycleConfig');
  }

  constructor(mode: LifecycleConfig.ModeEnumDef, idleTimeout?: Duration, retryPolicy?: RetryPolicy) {
    this.mode = mode;
    this.idleTimeout = idleTimeout;
    this.retryPolicy = retryPolicy;
  }
}

export namespace LifecycleConfig {
  export const ModeEnum = {
    /** Connection is automatically established on demand. */
    Auto: EnumValue.instance('LifecycleConfig.ModeEnum', 'Auto', 'auto'),
    /** Connection must be manually established before execution against this Connection. */
    Manual: EnumValue.instance('LifecycleConfig.ModeEnum', 'Manual', 'manual'),

    from(val: string | number): EnumValue {
      if (ModeEnum[val]) {
        return ModeEnum[val];
      }
      const byValue = ModeEnum.values.find((v) => v.value === val);
      if (byValue) {
        return byValue;
      }
      throw new IllegalArgumentError(`${val} is not a valid ModeEnum`);
    },

    get values(): EnumValue[] {
      return Object
        .keys(ModeEnum)
        .filter((k) => k !== 'values' && k !== 'from')
        .map((t) => ModeEnum[t]);
    }
  } as const;

  export type ModeEnumDef = typeof ModeEnum[keyof typeof ModeEnum];
}
