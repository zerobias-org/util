/* eslint-disable */
// ===============================================
// This file is autogenerated - Please do not edit
// ===============================================
import { EnumValue, IllegalArgumentError } from '@zerobias-org/types-core-js';
import { ObjectSerializer, RequestFile } from './index.js';

/**
* Representation of a node in a secrets manager's tree
*/
export class SecretNode {
  /**
  * The path to the node
  */
  'path': string;
  /**
  * The type of node this is. Nodes have other nodes below them; Secrets are leaf nodes
  */
  'type': SecretNode.TypeEnumDef;
  /**
  * Flag indicating whether or not nodes in this tree are writable. This is a general  indicator of writeability to the secrets provider; it is NOT checked on a per-node basis. So whereas you may be able to write to the given secrets manager, you may not have permission to write to a given node. This will only be discovered once you attempt a write, as we are not attempting to write to each node.
In short, this is a best-case indicator rather than an exact indicator.
  */
  'writable': boolean;
  /**
  * Flag indicating whether or not nodes in this tree are active. This is a general indicator that there are missing or invalid env variables on the system.
  */
  'active': boolean;
  /**
  * Flag indicating whether or not nodes in this tree were successfully able to write.
This is an exact indicator if this node is writable.
  */
  'writeSuccess'?: boolean;
  /**
  * If writeSucces is false, this should be populated with the error that occured on validate
  */
  'writeError'?: string;
  /**
  * If unable to connect to secret manager this should be populated with the error that occured
  */
  'connectError'?: string;

  static readonly discriminator: string | undefined = undefined;

  static attributeTypeMap: ReadonlyArray<{name: string, baseName: string, type: string, format: string}> = [
    {
      "name": "path",
      "baseName": "path",
      // false
      // string
      // string
      "type": "string",
      "format": ""
    },
    {
      "name": "type",
      "baseName": "type",
      // true
      // SecretNode.TypeEnum
      // SecretNode.TypeEnumDef
      "type": "SecretNode.TypeEnum",
      "format": ""
    },
    {
      "name": "writable",
      "baseName": "writable",
      // false
      // boolean
      // boolean
      "type": "boolean",
      "format": ""
    },
    {
      "name": "active",
      "baseName": "active",
      // false
      // boolean
      // boolean
      "type": "boolean",
      "format": ""
    },
    {
      "name": "writeSuccess",
      "baseName": "writeSuccess",
      // false
      // boolean
      // boolean
      "type": "boolean",
      "format": ""
    },
    {
      "name": "writeError",
      "baseName": "writeError",
      // false
      // string
      // string
      "type": "string",
      "format": ""
    },
    {
      "name": "connectError",
      "baseName": "connectError",
      // false
      // string
      // string
      "type": "string",
      "format": ""
    }  ];

  static getAttributeTypeMap() {
    return SecretNode.attributeTypeMap;
  }

  static newInstance(obj: any): SecretNode {
    return ObjectSerializer.deserialize(obj, 'SecretNode');
  }

  constructor(path: string, type: SecretNode.TypeEnumDef, writable: boolean, active: boolean, writeSuccess?: boolean, writeError?: string, connectError?: string) {
    this.path = path;
    this.type = type;
    this.writable = writable;
    this.active = active;
    this.writeSuccess = writeSuccess;
    this.writeError = writeError;
    this.connectError = connectError;
  }
}

export namespace SecretNode {
  export const TypeEnum = {
    /**  */
    Node: EnumValue.instance('SecretNode.TypeEnum', 'Node', 'Node'),
    /**  */
    Secret: EnumValue.instance('SecretNode.TypeEnum', 'Secret', 'Secret'),

    from(val: string | number): EnumValue {
      if (TypeEnum[val]) {
        return TypeEnum[val];
      }
      const byValue = TypeEnum.values.find((v) => v.value === val);
      if (byValue) {
        return byValue;
      }
      throw new IllegalArgumentError(`${val} is not a valid TypeEnum`);
    },

    get values(): EnumValue[] {
      return Object
        .keys(TypeEnum)
        .filter((k) => k !== 'values' && k !== 'from')
        .map((t) => TypeEnum[t]);
    }
  } as const;

  export type TypeEnumDef = typeof TypeEnum[keyof typeof TypeEnum];
}
