/* eslint-disable */
// ===============================================
// This file is autogenerated - Please do not edit
// ===============================================
import { EnumValue, IllegalArgumentError, IpAddress } from '@zerobias-org/types-core-js';
import { ObjectSerializer, RequestFile } from './index.js';

export class NetworkAddress {
  /**
  * The IP address associated with the given interface.
  */
  'ip'?: IpAddress;
  /**
  * The subnet bitmask for the network interface, if it is an IPv4 address.
  */
  'subnetBits'?: number;
  'type'?: NetworkAddress.TypeEnumDef;

  static readonly discriminator: string | undefined = undefined;

  static attributeTypeMap: ReadonlyArray<{name: string, baseName: string, type: string, format: string}> = [
    {
      "name": "ip",
      "baseName": "ip",
      // false
      // IpAddress
      // IpAddress
      "type": "IpAddress",
      "format": "ip"
    },
    {
      "name": "subnetBits",
      "baseName": "subnetBits",
      // false
      // number
      // number
      "type": "number",
      "format": ""
    },
    {
      "name": "type",
      "baseName": "type",
      // true
      // NetworkAddress.TypeEnum
      // NetworkAddress.TypeEnumDef
      "type": "NetworkAddress.TypeEnum",
      "format": ""
    }  ];

  static getAttributeTypeMap() {
    return NetworkAddress.attributeTypeMap;
  }

  static newInstance(obj: any): NetworkAddress {
    return ObjectSerializer.deserialize(obj, 'NetworkAddress');
  }

  constructor(ip?: IpAddress, subnetBits?: number, type?: NetworkAddress.TypeEnumDef) {
    this.ip = ip;
    this.subnetBits = subnetBits;
    this.type = type;
  }
}

export namespace NetworkAddress {
  export const TypeEnum = {
    /**  */
    Inet: EnumValue.instance('NetworkAddress.TypeEnum', 'Inet', 'inet'),
    /**  */
    Inet6: EnumValue.instance('NetworkAddress.TypeEnum', 'Inet6', 'inet6'),
    /**  */
    Unknown: EnumValue.instance('NetworkAddress.TypeEnum', 'Unknown', 'unknown'),

    from(val: string | number): EnumValue {
      if (TypeEnum[val]) {
        return TypeEnum[val];
      }
      const byValue = TypeEnum.values.find((v) => v.value === val);
      if (byValue) {
        return byValue;
      }
      throw new IllegalArgumentError(`${val} is not a valid TypeEnum`);
    },

    get values(): EnumValue[] {
      return Object
        .keys(TypeEnum)
        .filter((k) => k !== 'values' && k !== 'from')
        .map((t) => TypeEnum[t]);
    }
  } as const;

  export type TypeEnumDef = typeof TypeEnum[keyof typeof TypeEnum];
}
