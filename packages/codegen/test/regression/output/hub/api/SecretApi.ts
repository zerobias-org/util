/* eslint-disable */
// ===============================================
// This file is autogenerated - Please do not edit
// ===============================================
import { AxiosInstance } from 'axios';
import { CreateOauthSecret, CreateSecret, OAuthSecret, Secret, SecretsManager, SortDirectionDef, UpdateSecret } from '../model/index.js';
import { URL, EnumValue, IllegalArgumentError, PagedResults, Int32, UUID, CoreError, ParameterRequiredError, UnexpectedError, HttpMethod } from '@zerobias-org/types-core-js';
import { RequestFile, ObjectSerializer } from '../model/index.js';

export namespace SecretApi {
}

/**
 * SecretApi - interface
 * @export
 * @interface SecretApi
 */
export interface SecretApi {
  /**
   * 
   * @summary Creates a new OAuth secret
   * @param {CreateOauthSecret} createOauthSecret 
   * @param {*} [options] Override http request option.
   * @throws {@link @zerobias-org/types-core-js#ParameterRequiredError} if any required parameter is not provided
   * @example
   * ```typescript
   * const result = await api.createOauthSecret(null);
   * ```
   * @openapi operation=createOauthSecret path=/oauthSecrets method=POST
   * @memberof SecretApi
   */
  createOauthSecret(createOauthSecret: CreateOauthSecret): Promise<OAuthSecret>;

  /**
   * 
   * @summary Creates a new secret. New secrets will be created as draft and may only be used once taken out of draft. Use `updateSecret` to enable a secret.
   * @param {CreateSecret} createSecret 
   * @param {*} [options] Override http request option.
   * @throws {@link @zerobias-org/types-core-js#ParameterRequiredError} if any required parameter is not provided
   * @example
   * ```typescript
   * const result = await api.create(null);
   * ```
   * @openapi operation=createSecret path=/secrets method=POST
   * @memberof SecretApi
   */
  create(createSecret: CreateSecret): Promise<Secret>;

  /**
   * 
   * @summary Deletes a secret
   * @param {UUID} id ID of the Secret to access
   * @param {*} [options] Override http request option.
   * @throws {@link @zerobias-org/types-core-js#ParameterRequiredError} if any required parameter is not provided
   * @example
   * ```typescript
   * const result = await api.delete('00000000-0000-0000-0000-000000000000');
   * ```
   * @openapi operation=deleteSecret path=/secrets/{id} method=DELETE
   * @memberof SecretApi
   */
  delete(id: UUID): Promise<void>;

  /**
   * 
   * @summary Retrieves a secret
   * @param {UUID} id ID of the Secret to access
   * @param {*} [options] Override http request option.
   * @throws {@link @zerobias-org/types-core-js#ParameterRequiredError} if any required parameter is not provided
   * @example
   * ```typescript
   * const result = await api.get('00000000-0000-0000-0000-000000000000');
   * ```
   * @openapi operation=getSecret path=/secrets/{id} method=GET
   * @memberof SecretApi
   */
  get(id: UUID): Promise<Secret>;

  /**
   * 
   * @summary Lists all defined secrets
   * @param {number} [pageNumber] The requested page. This value is 1-indexed.
   * @param {number} [pageSize] The number of items in each page of data.
   * @param {string} [filter] An optional filter to search tags by name. This is a case-insensitive filter
   * @param {Array<SortDirection>} [sortDir] Array of directions to sort by. Must correspond with &#x60;sortBy&#x60;
   * @param {Array<string>} [sortBy] Array of columns to sort by, in order
   * @param {UUID} [connectionProfileId] Filters Secrets to only those matching the given connectionProfileId
   * @param {UUID} [nodeId] Filters Secrets to only those used by the given node
   * @param {*} [options] Override http request option.
   * @throws {@link @zerobias-org/types-core-js#ParameterRequiredError} if any required parameter is not provided
   * @example
   * ```typescript
   * const result = await api.list(1, 1, 'filter', null, null, '00000000-0000-0000-0000-000000000000', '00000000-0000-0000-0000-000000000000');
   * ```
   * @openapi operation=listSecrets path=/secrets method=GET
   * @memberof SecretApi
   */
  list(pageNumber?: number, pageSize?: number, filter?: string, sortDir?: Array<SortDirectionDef>, sortBy?: Array<string>, connectionProfileId?: UUID, nodeId?: UUID): Promise<PagedResults<Secret>>;

  /**
   * 
   * @summary Lists all secrets managers available for node use
   * @param {*} [options] Override http request option.
   * @throws {@link @zerobias-org/types-core-js#ParameterRequiredError} if any required parameter is not provided
   * @openapi operation=listSecretsManagers path=/secretsManagers method=GET
   * @memberof SecretApi
   */
  listSecretsManagers(): Promise<Array<SecretsManager>>;

  /**
   * 
   * @summary Updates the values for the given Secret, writing the secrets to the given Secrets Manager. Only updates the values provided, leaving other values in the profile alone.
   * @param {UUID} id Secret ID
   * @param {UUID} nodeId The Hub Node to use to store the secret values for this secret.
   * @param {{ [key: string]: any; }} requestBody 
   * @param {string} [rootNode] The root secret node to create the new secret under. Hub Server will attempt to determine which one to use if this is not provided. If there are multiple writable root nodes and  this parameter is not provided, an error will be thrown.
   * @param {*} [options] Override http request option.
   * @throws {@link @zerobias-org/types-core-js#ParameterRequiredError} if any required parameter is not provided
   * @example
   * ```typescript
   * const result = await api.patchSecretValues('00000000-0000-0000-0000-000000000000', '00000000-0000-0000-0000-000000000000', null, 'rootNode');
   * ```
   * @openapi operation=patchSecretValues path=/secrets/{id}/values method=PATCH
   * @memberof SecretApi
   */
  patchSecretValues(id: UUID, nodeId: UUID, requestBody: { [key: string]: any; }, rootNode?: string): Promise<Secret>;

  /**
   * Note that this method acts like a PATCH, only updating fields that are provided.
   * @summary Updates a secret
   * @param {UUID} id ID of the Secret to access
   * @param {UpdateSecret} updateSecret 
   * @param {*} [options] Override http request option.
   * @throws {@link @zerobias-org/types-core-js#ParameterRequiredError} if any required parameter is not provided
   * @example
   * ```typescript
   * const result = await api.update('00000000-0000-0000-0000-000000000000', null);
   * ```
   * @openapi operation=updateSecret path=/secrets/{id} method=PUT
   * @memberof SecretApi
   */
  update(id: UUID, updateSecret: UpdateSecret): Promise<Secret>;

  /**
   * 
   * @summary Updates the values for the given Secret, writing the secrets to the given Secrets Manager
   * @param {UUID} id Secret ID
   * @param {UUID} nodeId The Hub Node to use to store the secret values for this secret.
   * @param {{ [key: string]: any; }} requestBody 
   * @param {string} [rootNode] The root secret node to create the new secret under. Hub Server will attempt to determine which one to use if this is not provided. If there are multiple writable root nodes and  this parameter is not provided, an error will be thrown.
   * @param {*} [options] Override http request option.
   * @throws {@link @zerobias-org/types-core-js#ParameterRequiredError} if any required parameter is not provided
   * @example
   * ```typescript
   * const result = await api.updateSecretValues('00000000-0000-0000-0000-000000000000', '00000000-0000-0000-0000-000000000000', null, 'rootNode');
   * ```
   * @openapi operation=updateSecretValues path=/secrets/{id}/values method=PUT
   * @memberof SecretApi
   */
  updateSecretValues(id: UUID, nodeId: UUID, requestBody: { [key: string]: any; }, rootNode?: string): Promise<Secret>;

}

/**
 * SecretProducerApi - interface
 * Producer interface for Secret
 * @export
 * @interface SecretProducerApi
 */
export interface SecretProducerApi {
  /**
  * 
  * @summary Creates a new OAuth secret
  * @param {CreateOauthSecret} createOauthSecret 
  * @param {*} [options] Override http request option.
  * @throws {@link @zerobias-org/types-core-js#ParameterRequiredError} if any required parameter is not provided
  * @openapi operation=createOauthSecret path=/oauthSecrets method=POST
  * @memberof Secret
  */
  createOauthSecret(createOauthSecret: CreateOauthSecret): Promise<OAuthSecret>;
  /**
  * 
  * @summary Creates a new secret. New secrets will be created as draft and may only be used once taken out of draft. Use `updateSecret` to enable a secret.
  * @param {CreateSecret} createSecret 
  * @param {*} [options] Override http request option.
  * @throws {@link @zerobias-org/types-core-js#ParameterRequiredError} if any required parameter is not provided
  * @openapi operation=createSecret path=/secrets method=POST
  * @memberof Secret
  */
  create(createSecret: CreateSecret): Promise<Secret>;
  /**
  * 
  * @summary Deletes a secret
  * @param {UUID} id ID of the Secret to access
  * @param {*} [options] Override http request option.
  * @throws {@link @zerobias-org/types-core-js#ParameterRequiredError} if any required parameter is not provided
  * @openapi operation=deleteSecret path=/secrets/{id} method=DELETE
  * @memberof Secret
  */
  delete(id: UUID): Promise<void>;
  /**
  * 
  * @summary Retrieves a secret
  * @param {UUID} id ID of the Secret to access
  * @param {*} [options] Override http request option.
  * @throws {@link @zerobias-org/types-core-js#ParameterRequiredError} if any required parameter is not provided
  * @openapi operation=getSecret path=/secrets/{id} method=GET
  * @memberof Secret
  */
  get(id: UUID): Promise<Secret>;
  /**
  * 
  * @summary Lists all defined secrets
  * @param {string} [filter] An optional filter to search tags by name. This is a case-insensitive filter
  * @param {UUID} [connectionProfileId] Filters Secrets to only those matching the given connectionProfileId
  * @param {UUID} [nodeId] Filters Secrets to only those used by the given node
  * @param {*} [options] Override http request option.
  * @throws {@link @zerobias-org/types-core-js#ParameterRequiredError} if any required parameter is not provided
  * @openapi operation=listSecrets path=/secrets method=GET
  * @memberof Secret
  */
  list(results: PagedResults<Secret>, filter?: string, connectionProfileId?: UUID, nodeId?: UUID): Promise<void>;
  /**
  * 
  * @summary Lists all secrets managers available for node use
  * @param {*} [options] Override http request option.
  * @throws {@link @zerobias-org/types-core-js#ParameterRequiredError} if any required parameter is not provided
  * @openapi operation=listSecretsManagers path=/secretsManagers method=GET
  * @memberof Secret
  */
  listSecretsManagers(): Promise<Array<SecretsManager>>;
  /**
  * 
  * @summary Updates the values for the given Secret, writing the secrets to the given Secrets Manager. Only updates the values provided, leaving other values in the profile alone.
  * @param {UUID} id Secret ID
  * @param {UUID} nodeId The Hub Node to use to store the secret values for this secret.
  * @param {{ [key: string]: any; }} requestBody 
  * @param {string} [rootNode] The root secret node to create the new secret under. Hub Server will attempt to determine which one to use if this is not provided. If there are multiple writable root nodes and  this parameter is not provided, an error will be thrown.
  * @param {*} [options] Override http request option.
  * @throws {@link @zerobias-org/types-core-js#ParameterRequiredError} if any required parameter is not provided
  * @openapi operation=patchSecretValues path=/secrets/{id}/values method=PATCH
  * @memberof Secret
  */
  patchSecretValues(id: UUID, nodeId: UUID, requestBody: { [key: string]: any; }, rootNode?: string): Promise<Secret>;
  /**
  * Note that this method acts like a PATCH, only updating fields that are provided.
  * @summary Updates a secret
  * @param {UUID} id ID of the Secret to access
  * @param {UpdateSecret} updateSecret 
  * @param {*} [options] Override http request option.
  * @throws {@link @zerobias-org/types-core-js#ParameterRequiredError} if any required parameter is not provided
  * @openapi operation=updateSecret path=/secrets/{id} method=PUT
  * @memberof Secret
  */
  update(id: UUID, updateSecret: UpdateSecret): Promise<Secret>;
  /**
  * 
  * @summary Updates the values for the given Secret, writing the secrets to the given Secrets Manager
  * @param {UUID} id Secret ID
  * @param {UUID} nodeId The Hub Node to use to store the secret values for this secret.
  * @param {{ [key: string]: any; }} requestBody 
  * @param {string} [rootNode] The root secret node to create the new secret under. Hub Server will attempt to determine which one to use if this is not provided. If there are multiple writable root nodes and  this parameter is not provided, an error will be thrown.
  * @param {*} [options] Override http request option.
  * @throws {@link @zerobias-org/types-core-js#ParameterRequiredError} if any required parameter is not provided
  * @openapi operation=updateSecretValues path=/secrets/{id}/values method=PUT
  * @memberof Secret
  */
  updateSecretValues(id: UUID, nodeId: UUID, requestBody: { [key: string]: any; }, rootNode?: string): Promise<Secret>;
}

export class SecretApiMappingImpl implements SecretApi {
  private producer: SecretProducerApi;
  constructor(producer: SecretProducerApi) {
    this.producer = producer;
  }

  /**
   * 
   * @summary Creates a new OAuth secret
   * @param createOauthSecret 
   * @openapi operation=createOauthSecret path=/oauthSecrets method=POST
   */
  public async createOauthSecret(createOauthSecret: CreateOauthSecret): Promise<OAuthSecret> {
    // verify required parameter 'createOauthSecret' is not null or undefined
    if (createOauthSecret === null || createOauthSecret === undefined) {
      throw new ParameterRequiredError('createOauthSecret');
    }
    return this.producer.createOauthSecret(createOauthSecret);
  }
  /**
   * 
   * @summary Creates a new secret. New secrets will be created as draft and may only be used once taken out of draft. Use `updateSecret` to enable a secret.
   * @param createSecret 
   * @openapi operation=createSecret path=/secrets method=POST
   */
  public async create(createSecret: CreateSecret): Promise<Secret> {
    // verify required parameter 'createSecret' is not null or undefined
    if (createSecret === null || createSecret === undefined) {
      throw new ParameterRequiredError('createSecret');
    }
    return this.producer.create(createSecret);
  }
  /**
   * 
   * @summary Deletes a secret
   * @param id ID of the Secret to access
   * @openapi operation=deleteSecret path=/secrets/{id} method=DELETE
   */
  public async delete(id: UUID): Promise<void> {
    // verify required parameter 'id' is not null or undefined
    if (id === null || id === undefined) {
      throw new ParameterRequiredError('id');
    }
    return this.producer.delete(id);
  }
  /**
   * 
   * @summary Retrieves a secret
   * @param id ID of the Secret to access
   * @openapi operation=getSecret path=/secrets/{id} method=GET
   */
  public async get(id: UUID): Promise<Secret> {
    // verify required parameter 'id' is not null or undefined
    if (id === null || id === undefined) {
      throw new ParameterRequiredError('id');
    }
    return this.producer.get(id);
  }
  /**
   * 
   * @summary Lists all defined secrets
   * @param pageNumber The requested page. This value is 1-indexed.
   * @param pageSize The number of items in each page of data.
   * @param filter An optional filter to search tags by name. This is a case-insensitive filter
   * @param sortDir Array of directions to sort by. Must correspond with &#x60;sortBy&#x60;
   * @param sortBy Array of columns to sort by, in order
   * @param connectionProfileId Filters Secrets to only those matching the given connectionProfileId
   * @param nodeId Filters Secrets to only those used by the given node
   * @openapi operation=listSecrets path=/secrets method=GET
   */
  public async list(pageNumber: number = 1, pageSize: number = 50, filter?: string, sortDir?: Array<SortDirectionDef>, sortBy?: Array<string>, connectionProfileId?: UUID, nodeId?: UUID): Promise<PagedResults<Secret>> {
    if (pageNumber) {
      await Int32.parse(pageNumber);
    }
    if (pageSize) {
      await Int32.parse(pageSize);
    }
    const bag = new PagedResults<Secret>();
    bag.pageNumber = pageNumber;
    bag.pageSize = pageSize;
    if (sortBy && sortDir) {
      bag.sort(sortBy, sortDir);
    }
    await this.producer.list(bag, filter, connectionProfileId, nodeId);
    if (bag.items === null || bag.items === undefined) {
      throw new UnexpectedError("Producers must return 'items' for PagedResults queries");
    }
    return bag;
  }
  /**
   * 
   * @summary Lists all secrets managers available for node use
   * @openapi operation=listSecretsManagers path=/secretsManagers method=GET
   */
  public async listSecretsManagers(): Promise<Array<SecretsManager>> {
    return this.producer.listSecretsManagers();
  }
  /**
   * 
   * @summary Updates the values for the given Secret, writing the secrets to the given Secrets Manager. Only updates the values provided, leaving other values in the profile alone.
   * @param id Secret ID
   * @param nodeId The Hub Node to use to store the secret values for this secret.
   * @param requestBody 
   * @param rootNode The root secret node to create the new secret under. Hub Server will attempt to determine which one to use if this is not provided. If there are multiple writable root nodes and  this parameter is not provided, an error will be thrown.
   * @openapi operation=patchSecretValues path=/secrets/{id}/values method=PATCH
   */
  public async patchSecretValues(id: UUID, nodeId: UUID, requestBody: { [key: string]: any; }, rootNode?: string): Promise<Secret> {
    // verify required parameter 'id' is not null or undefined
    if (id === null || id === undefined) {
      throw new ParameterRequiredError('id');
    }
    // verify required parameter 'nodeId' is not null or undefined
    if (nodeId === null || nodeId === undefined) {
      throw new ParameterRequiredError('nodeId');
    }
    // verify required parameter 'requestBody' is not null or undefined
    if (requestBody === null || requestBody === undefined) {
      throw new ParameterRequiredError('requestBody');
    }
    return this.producer.patchSecretValues(id, nodeId, requestBody, rootNode);
  }
  /**
   * Note that this method acts like a PATCH, only updating fields that are provided.
   * @summary Updates a secret
   * @param id ID of the Secret to access
   * @param updateSecret 
   * @openapi operation=updateSecret path=/secrets/{id} method=PUT
   */
  public async update(id: UUID, updateSecret: UpdateSecret): Promise<Secret> {
    // verify required parameter 'id' is not null or undefined
    if (id === null || id === undefined) {
      throw new ParameterRequiredError('id');
    }
    // verify required parameter 'updateSecret' is not null or undefined
    if (updateSecret === null || updateSecret === undefined) {
      throw new ParameterRequiredError('updateSecret');
    }
    return this.producer.update(id, updateSecret);
  }
  /**
   * 
   * @summary Updates the values for the given Secret, writing the secrets to the given Secrets Manager
   * @param id Secret ID
   * @param nodeId The Hub Node to use to store the secret values for this secret.
   * @param requestBody 
   * @param rootNode The root secret node to create the new secret under. Hub Server will attempt to determine which one to use if this is not provided. If there are multiple writable root nodes and  this parameter is not provided, an error will be thrown.
   * @openapi operation=updateSecretValues path=/secrets/{id}/values method=PUT
   */
  public async updateSecretValues(id: UUID, nodeId: UUID, requestBody: { [key: string]: any; }, rootNode?: string): Promise<Secret> {
    // verify required parameter 'id' is not null or undefined
    if (id === null || id === undefined) {
      throw new ParameterRequiredError('id');
    }
    // verify required parameter 'nodeId' is not null or undefined
    if (nodeId === null || nodeId === undefined) {
      throw new ParameterRequiredError('nodeId');
    }
    // verify required parameter 'requestBody' is not null or undefined
    if (requestBody === null || requestBody === undefined) {
      throw new ParameterRequiredError('requestBody');
    }
    return this.producer.updateSecretValues(id, nodeId, requestBody, rootNode);
  }
}

/**
 * Wrap producer with mapping implementation
 */
export function wrapSecretProducer(producer: SecretProducerApi): SecretApi {
  return new SecretApiMappingImpl(producer);
}

/**
 * SecretApiHttpImpl - Direct HTTP implementation
 *
 * Makes direct HTTP calls to the API using Axios.
 * Used by SDK clients for platform service access.
 */
export class SecretApiHttpImpl implements SecretProducerApi {
  private client: AxiosInstance;
  private headers: Record<string, string>;

  constructor(client: AxiosInstance, headers: Record<string, string> = {}) {
    this.client = client;
    this.headers = headers;
  }

  async createOauthSecret(createOauthSecret: CreateOauthSecret): Promise<OAuthSecret> {
  const _queryParams = {
      
  };
  const _bodyParams = {
      ...createOauthSecret,
  };
  let _path = '/oauthSecrets';
  return this.client.post(
    _path,
    _bodyParams)
    .then((response) => {
      // BaseApiClient uses validateStatus: () => true, so we must check status manually
      if (response.status >= 400) {
        throw CoreError.deserialize(response.data);
      }
      return ObjectSerializer.deserialize(response.data, 'OAuthSecret')
    })
    .catch((error) => {
      if (error.data) {
        throw CoreError.deserialize(error.data);
      } else {
        throw error;
      }
    });
  }
  async create(createSecret: CreateSecret): Promise<Secret> {
  const _queryParams = {
      
  };
  const _bodyParams = {
      ...createSecret,
  };
  let _path = '/secrets';
  return this.client.post(
    _path,
    _bodyParams)
    .then((response) => {
      // BaseApiClient uses validateStatus: () => true, so we must check status manually
      if (response.status >= 400) {
        throw CoreError.deserialize(response.data);
      }
      return ObjectSerializer.deserialize(response.data, 'Secret')
    })
    .catch((error) => {
      if (error.data) {
        throw CoreError.deserialize(error.data);
      } else {
        throw error;
      }
    });
  }
  async delete(id: UUID): Promise<void> {
  const _queryParams = {
      
  };
  const _bodyParams = {
      
  };
  let _path = '/secrets/{id}';
  _path = _path.replace('{id}', encodeURIComponent(String(id)));
  return this.client.delete(
    _path,
    { params: _queryParams })
    .then((response) => {
      // BaseApiClient uses validateStatus: () => true, so we must check status manually
      if (response.status >= 400) {
        throw CoreError.deserialize(response.data);
      }
      return ObjectSerializer.deserialize(response.data, '')
    })
    .catch((error) => {
      if (error.data) {
        throw CoreError.deserialize(error.data);
      } else {
        throw error;
      }
    });
  }
  async get(id: UUID): Promise<Secret> {
  const _queryParams = {
      
  };
  const _bodyParams = {
      
  };
  let _path = '/secrets/{id}';
  _path = _path.replace('{id}', encodeURIComponent(String(id)));
  return this.client.get(
    _path,
    { params: _queryParams })
    .then((response) => {
      // BaseApiClient uses validateStatus: () => true, so we must check status manually
      if (response.status >= 400) {
        throw CoreError.deserialize(response.data);
      }
      return ObjectSerializer.deserialize(response.data, 'Secret')
    })
    .catch((error) => {
      if (error.data) {
        throw CoreError.deserialize(error.data);
      } else {
        throw error;
      }
    });
  }
  async list(results: PagedResults<Secret>, filter?: string, connectionProfileId?: UUID, nodeId?: UUID): Promise<void> {
  const _body = {
      filter,connectionProfileId,nodeId,
  };
  let _path = '/secrets';
  return this.client.get(
    _path,
    {
      params: {
        ..._body,
        pageNumber: results.pageNumber,
        pageSize: results.pageSize,
      }
    })
    .then((response) => {
      // BaseApiClient uses validateStatus: () => true, so we must check status manually
      if (response.status >= 400) {
        throw CoreError.deserialize(response.data);
      }
      results.items = ObjectSerializer.deserialize(response.data, 'Array<Secret>');
      results.count = response.headers.count ? Number(response.headers.count) : -1;
      results.pageToken = response.headers.pagetoken ?? response.headers.pageToken;
      results.headers = this.headers;
      results.baseUrl = new URL(`${this.client.getUri()}/secrets`);
      results.httpMethod = HttpMethod.Get;
      results.body = _body;
      results.mapper = (obj) => ObjectSerializer.deserialize(obj, 'Secret');
    })
    .catch((error) => {
      if (error.data) {
        throw CoreError.deserialize(error.data);
      } else {
        throw error;
      }
    });
  }
  async listSecretsManagers(): Promise<Array<SecretsManager>> {
  const _queryParams = {
      
  };
  const _bodyParams = {
      
  };
  let _path = '/secretsManagers';
  return this.client.get(
    _path,
    { params: _queryParams })
    .then((response) => {
      // BaseApiClient uses validateStatus: () => true, so we must check status manually
      if (response.status >= 400) {
        throw CoreError.deserialize(response.data);
      }
      return ObjectSerializer.deserialize(response.data, 'Array<SecretsManager>')
    })
    .catch((error) => {
      if (error.data) {
        throw CoreError.deserialize(error.data);
      } else {
        throw error;
      }
    });
  }
  async patchSecretValues(id: UUID, nodeId: UUID, requestBody: { [key: string]: any; }, rootNode?: string): Promise<Secret> {
  const _queryParams = {
      nodeId,rootNode,
  };
  const _bodyParams = {
      requestBody,
  };
  let _path = '/secrets/{id}/values';
  _path = _path.replace('{id}', encodeURIComponent(String(id)));
  return this.client.patch(
    _path,
    _bodyParams)
    .then((response) => {
      // BaseApiClient uses validateStatus: () => true, so we must check status manually
      if (response.status >= 400) {
        throw CoreError.deserialize(response.data);
      }
      return ObjectSerializer.deserialize(response.data, 'Secret')
    })
    .catch((error) => {
      if (error.data) {
        throw CoreError.deserialize(error.data);
      } else {
        throw error;
      }
    });
  }
  async update(id: UUID, updateSecret: UpdateSecret): Promise<Secret> {
  const _queryParams = {
      
  };
  const _bodyParams = {
      updateSecret,
  };
  let _path = '/secrets/{id}';
  _path = _path.replace('{id}', encodeURIComponent(String(id)));
  return this.client.put(
    _path,
    _bodyParams)
    .then((response) => {
      // BaseApiClient uses validateStatus: () => true, so we must check status manually
      if (response.status >= 400) {
        throw CoreError.deserialize(response.data);
      }
      return ObjectSerializer.deserialize(response.data, 'Secret')
    })
    .catch((error) => {
      if (error.data) {
        throw CoreError.deserialize(error.data);
      } else {
        throw error;
      }
    });
  }
  async updateSecretValues(id: UUID, nodeId: UUID, requestBody: { [key: string]: any; }, rootNode?: string): Promise<Secret> {
  const _queryParams = {
      nodeId,rootNode,
  };
  const _bodyParams = {
      requestBody,
  };
  let _path = '/secrets/{id}/values';
  _path = _path.replace('{id}', encodeURIComponent(String(id)));
  return this.client.put(
    _path,
    _bodyParams)
    .then((response) => {
      // BaseApiClient uses validateStatus: () => true, so we must check status manually
      if (response.status >= 400) {
        throw CoreError.deserialize(response.data);
      }
      return ObjectSerializer.deserialize(response.data, 'Secret')
    })
    .catch((error) => {
      if (error.data) {
        throw CoreError.deserialize(error.data);
      } else {
        throw error;
      }
    });
  }
}
