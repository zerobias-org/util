/* eslint-disable */
// ===============================================
// This file is autogenerated - Please do not edit
// ===============================================
import { AxiosInstance } from 'axios';
import { Module, ModuleDependencyReport, ModuleVersion, Operation } from '../model/index.js';
import { URL, EnumValue, IllegalArgumentError, PagedResults, Int32, UUID, VersionRange, CoreError, ParameterRequiredError, UnexpectedError, HttpMethod } from '@zerobias-org/types-core-js';
import { RequestFile, ObjectSerializer } from '../model/index.js';

export namespace ModuleApi {
}

/**
 * ModuleApi - interface
 * @export
 * @interface ModuleApi
 */
export interface ModuleApi {
  /**
   * This endpoint generates a report describing Targets which may be able to satisfy a given
module requirement. The following information will be provided, if available:
  - `Module`: if the server knows about the module
  - `ModuleVersion`: if the server knows about a version that matches the provided version range
  - `Nodes`: a list of all nodes which *could* host a deployment of the module/version
  - `Deployments`: a list of all deployments which provide the requested module (version)

The each of the `deployments` will have an array of `targets` if the `Deployment` requires
a `Connection`. All the `Connections` specified for that `Deployment` will be listed under
there.
   * @summary Determines whether or not the given module specification can be satisfied by any targets in the system
   * @param {string} moduleKeyOrId The module to look for.  Either the module id or its key (@zerobias-org/github)
   * @param {VersionRange} [version] Version specification for the module. This will use the latest version of the module if not provided.
   * @param {UUID} [nodeId] An optional Node id to filter deployments with.
   * @param {*} [options] Override http request option.
   * @throws {@link @zerobias-org/types-core-js#ParameterRequiredError} if any required parameter is not provided
   * @example
   * ```typescript
   * const result = await api.getDependencyReport('moduleKeyOrId', null, '00000000-0000-0000-0000-000000000000');
   * ```
   * @openapi operation=getDependencyReport path=/modules/{moduleKeyOrId}/dependencies method=GET
   * @memberof ModuleApi
   */
  getDependencyReport(moduleKeyOrId: string, version?: VersionRange, nodeId?: UUID): Promise<ModuleDependencyReport>;

  /**
   * 
   * @summary Retrieves a Module by ID
   * @param {UUID} id Module ID
   * @param {*} [options] Override http request option.
   * @throws {@link @zerobias-org/types-core-js#ParameterRequiredError} if any required parameter is not provided
   * @example
   * ```typescript
   * const result = await api.get('00000000-0000-0000-0000-000000000000');
   * ```
   * @openapi operation=getModule path=/modules/{id} method=GET
   * @memberof ModuleApi
   */
  get(id: UUID): Promise<Module>;

  /**
   * 
   * @summary Retrieves a single module version
   * @param {UUID} moduleId Module ID
   * @param {string} version Version ID or version string
   * @param {*} [options] Override http request option.
   * @throws {@link @zerobias-org/types-core-js#ParameterRequiredError} if any required parameter is not provided
   * @example
   * ```typescript
   * const result = await api.getModuleVersion('00000000-0000-0000-0000-000000000000', 'version');
   * ```
   * @openapi operation=getModuleVersion path=/modules/{moduleId}/versions/{version} method=GET
   * @memberof ModuleApi
   */
  getModuleVersion(moduleId: UUID, version: string): Promise<ModuleVersion>;

  /**
   * 
   * @summary Retrieves a single module version
   * @param {UUID} moduleVersionId Module Version ID
   * @param {*} [options] Override http request option.
   * @throws {@link @zerobias-org/types-core-js#ParameterRequiredError} if any required parameter is not provided
   * @example
   * ```typescript
   * const result = await api.getModuleVersionById('00000000-0000-0000-0000-000000000000');
   * ```
   * @openapi operation=getModuleVersionById path=/moduleVersions/{moduleVersionId} method=GET
   * @memberof ModuleApi
   */
  getModuleVersionById(moduleVersionId: UUID): Promise<ModuleVersion>;

  /**
   * Provides a full list of all modules in the system.
   * @summary Lists all modules available
   * @param {number} [pageNumber] The requested page. This value is 1-indexed.
   * @param {number} [pageSize] The number of items in each page of data.
   * @param {*} [options] Override http request option.
   * @throws {@link @zerobias-org/types-core-js#ParameterRequiredError} if any required parameter is not provided
   * @example
   * ```typescript
   * const result = await api.list(1, 1);
   * ```
   * @openapi operation=listModules path=/modules method=GET
   * @memberof ModuleApi
   */
  list(pageNumber?: number, pageSize?: number): Promise<PagedResults<Module>>;

  /**
   * 
   * @summary Retrieves all the operations available on a given ModuleVersion
   * @param {UUID} moduleId Module ID
   * @param {string} version Version ID or version string
   * @param {number} [pageNumber] The requested page. This value is 1-indexed.
   * @param {number} [pageSize] The number of items in each page of data.
   * @param {*} [options] Override http request option.
   * @throws {@link @zerobias-org/types-core-js#ParameterRequiredError} if any required parameter is not provided
   * @example
   * ```typescript
   * const result = await api.listOperations('00000000-0000-0000-0000-000000000000', 'version', 1, 1);
   * ```
   * @openapi operation=listOperations path=/modules/{moduleId}/versions/{version}/operations method=GET
   * @memberof ModuleApi
   */
  listOperations(moduleId: UUID, version: string, pageNumber?: number, pageSize?: number): Promise<PagedResults<Operation>>;

  /**
   * 
   * @summary Retrieves all versions of a given module
   * @param {UUID} id Module ID
   * @param {number} [pageNumber] The requested page. This value is 1-indexed.
   * @param {number} [pageSize] The number of items in each page of data.
   * @param {*} [options] Override http request option.
   * @throws {@link @zerobias-org/types-core-js#ParameterRequiredError} if any required parameter is not provided
   * @example
   * ```typescript
   * const result = await api.listVersions('00000000-0000-0000-0000-000000000000', 1, 1);
   * ```
   * @openapi operation=listVersions path=/modules/{id}/versions method=GET
   * @memberof ModuleApi
   */
  listVersions(id: UUID, pageNumber?: number, pageSize?: number): Promise<PagedResults<ModuleVersion>>;

  /**
   * Synchronize the database with the store
   * @summary Synchronizes the modules in the database with the store
   * @param {boolean} [allVersions] Optionally sync all versions, not just the latest
   * @param {UUID} [moduleId] Optionally specify a specific module
   * @param {string} [version] Optionally specify a specific version for the module, default to latest
   * @param {*} [options] Override http request option.
   * @throws {@link @zerobias-org/types-core-js#ParameterRequiredError} if any required parameter is not provided
   * @example
   * ```typescript
   * const result = await api.storeSync(true, '00000000-0000-0000-0000-000000000000', 'version');
   * ```
   * @openapi operation=storeSync path=/storeSync method=GET
   * @memberof ModuleApi
   */
  storeSync(allVersions?: boolean, moduleId?: UUID, version?: string): Promise<void>;

}

/**
 * ModuleProducerApi - interface
 * Producer interface for Module
 * @export
 * @interface ModuleProducerApi
 */
export interface ModuleProducerApi {
  /**
  * This endpoint generates a report describing Targets which may be able to satisfy a given
module requirement. The following information will be provided, if available:
  - `Module`: if the server knows about the module
  - `ModuleVersion`: if the server knows about a version that matches the provided version range
  - `Nodes`: a list of all nodes which *could* host a deployment of the module/version
  - `Deployments`: a list of all deployments which provide the requested module (version)

The each of the `deployments` will have an array of `targets` if the `Deployment` requires
a `Connection`. All the `Connections` specified for that `Deployment` will be listed under
there.
  * @summary Determines whether or not the given module specification can be satisfied by any targets in the system
  * @param {string} moduleKeyOrId The module to look for.  Either the module id or its key (@zerobias-org/github)
  * @param {VersionRange} [version] Version specification for the module. This will use the latest version of the module if not provided.
  * @param {UUID} [nodeId] An optional Node id to filter deployments with.
  * @param {*} [options] Override http request option.
  * @throws {@link @zerobias-org/types-core-js#ParameterRequiredError} if any required parameter is not provided
  * @openapi operation=getDependencyReport path=/modules/{moduleKeyOrId}/dependencies method=GET
  * @memberof Module
  */
  getDependencyReport(moduleKeyOrId: string, version?: VersionRange, nodeId?: UUID): Promise<ModuleDependencyReport>;
  /**
  * 
  * @summary Retrieves a Module by ID
  * @param {UUID} id Module ID
  * @param {*} [options] Override http request option.
  * @throws {@link @zerobias-org/types-core-js#ParameterRequiredError} if any required parameter is not provided
  * @openapi operation=getModule path=/modules/{id} method=GET
  * @memberof Module
  */
  get(id: UUID): Promise<Module>;
  /**
  * 
  * @summary Retrieves a single module version
  * @param {UUID} moduleId Module ID
  * @param {string} version Version ID or version string
  * @param {*} [options] Override http request option.
  * @throws {@link @zerobias-org/types-core-js#ParameterRequiredError} if any required parameter is not provided
  * @openapi operation=getModuleVersion path=/modules/{moduleId}/versions/{version} method=GET
  * @memberof Module
  */
  getModuleVersion(moduleId: UUID, version: string): Promise<ModuleVersion>;
  /**
  * 
  * @summary Retrieves a single module version
  * @param {UUID} moduleVersionId Module Version ID
  * @param {*} [options] Override http request option.
  * @throws {@link @zerobias-org/types-core-js#ParameterRequiredError} if any required parameter is not provided
  * @openapi operation=getModuleVersionById path=/moduleVersions/{moduleVersionId} method=GET
  * @memberof Module
  */
  getModuleVersionById(moduleVersionId: UUID): Promise<ModuleVersion>;
  /**
  * Provides a full list of all modules in the system.
  * @summary Lists all modules available
  * @param {*} [options] Override http request option.
  * @throws {@link @zerobias-org/types-core-js#ParameterRequiredError} if any required parameter is not provided
  * @openapi operation=listModules path=/modules method=GET
  * @memberof Module
  */
  list(results: PagedResults<Module>): Promise<void>;
  /**
  * 
  * @summary Retrieves all the operations available on a given ModuleVersion
  * @param {UUID} moduleId Module ID
  * @param {string} version Version ID or version string
  * @param {*} [options] Override http request option.
  * @throws {@link @zerobias-org/types-core-js#ParameterRequiredError} if any required parameter is not provided
  * @openapi operation=listOperations path=/modules/{moduleId}/versions/{version}/operations method=GET
  * @memberof Module
  */
  listOperations(results: PagedResults<Operation>, moduleId: UUID, version: string): Promise<void>;
  /**
  * 
  * @summary Retrieves all versions of a given module
  * @param {UUID} id Module ID
  * @param {*} [options] Override http request option.
  * @throws {@link @zerobias-org/types-core-js#ParameterRequiredError} if any required parameter is not provided
  * @openapi operation=listVersions path=/modules/{id}/versions method=GET
  * @memberof Module
  */
  listVersions(results: PagedResults<ModuleVersion>, id: UUID): Promise<void>;
  /**
  * Synchronize the database with the store
  * @summary Synchronizes the modules in the database with the store
  * @param {boolean} [allVersions] Optionally sync all versions, not just the latest
  * @param {UUID} [moduleId] Optionally specify a specific module
  * @param {string} [version] Optionally specify a specific version for the module, default to latest
  * @param {*} [options] Override http request option.
  * @throws {@link @zerobias-org/types-core-js#ParameterRequiredError} if any required parameter is not provided
  * @openapi operation=storeSync path=/storeSync method=GET
  * @memberof Module
  */
  storeSync(allVersions?: boolean, moduleId?: UUID, version?: string): Promise<void>;
}

export class ModuleApiMappingImpl implements ModuleApi {
  private producer: ModuleProducerApi;
  constructor(producer: ModuleProducerApi) {
    this.producer = producer;
  }

  /**
   * This endpoint generates a report describing Targets which may be able to satisfy a given
module requirement. The following information will be provided, if available:
  - `Module`: if the server knows about the module
  - `ModuleVersion`: if the server knows about a version that matches the provided version range
  - `Nodes`: a list of all nodes which *could* host a deployment of the module/version
  - `Deployments`: a list of all deployments which provide the requested module (version)

The each of the `deployments` will have an array of `targets` if the `Deployment` requires
a `Connection`. All the `Connections` specified for that `Deployment` will be listed under
there.
   * @summary Determines whether or not the given module specification can be satisfied by any targets in the system
   * @param moduleKeyOrId The module to look for.  Either the module id or its key (@zerobias-org/github)
   * @param version Version specification for the module. This will use the latest version of the module if not provided.
   * @param nodeId An optional Node id to filter deployments with.
   * @openapi operation=getDependencyReport path=/modules/{moduleKeyOrId}/dependencies method=GET
   */
  public async getDependencyReport(moduleKeyOrId: string, version?: VersionRange, nodeId?: UUID): Promise<ModuleDependencyReport> {
    // verify required parameter 'moduleKeyOrId' is not null or undefined
    if (moduleKeyOrId === null || moduleKeyOrId === undefined || moduleKeyOrId === '') {
      throw new ParameterRequiredError('moduleKeyOrId');
    }
    return this.producer.getDependencyReport(moduleKeyOrId, version, nodeId);
  }
  /**
   * 
   * @summary Retrieves a Module by ID
   * @param id Module ID
   * @openapi operation=getModule path=/modules/{id} method=GET
   */
  public async get(id: UUID): Promise<Module> {
    // verify required parameter 'id' is not null or undefined
    if (id === null || id === undefined) {
      throw new ParameterRequiredError('id');
    }
    return this.producer.get(id);
  }
  /**
   * 
   * @summary Retrieves a single module version
   * @param moduleId Module ID
   * @param version Version ID or version string
   * @openapi operation=getModuleVersion path=/modules/{moduleId}/versions/{version} method=GET
   */
  public async getModuleVersion(moduleId: UUID, version: string): Promise<ModuleVersion> {
    // verify required parameter 'moduleId' is not null or undefined
    if (moduleId === null || moduleId === undefined) {
      throw new ParameterRequiredError('moduleId');
    }
    // verify required parameter 'version' is not null or undefined
    if (version === null || version === undefined || version === '') {
      throw new ParameterRequiredError('version');
    }
    return this.producer.getModuleVersion(moduleId, version);
  }
  /**
   * 
   * @summary Retrieves a single module version
   * @param moduleVersionId Module Version ID
   * @openapi operation=getModuleVersionById path=/moduleVersions/{moduleVersionId} method=GET
   */
  public async getModuleVersionById(moduleVersionId: UUID): Promise<ModuleVersion> {
    // verify required parameter 'moduleVersionId' is not null or undefined
    if (moduleVersionId === null || moduleVersionId === undefined) {
      throw new ParameterRequiredError('moduleVersionId');
    }
    return this.producer.getModuleVersionById(moduleVersionId);
  }
  /**
   * Provides a full list of all modules in the system.
   * @summary Lists all modules available
   * @param pageNumber The requested page. This value is 1-indexed.
   * @param pageSize The number of items in each page of data.
   * @openapi operation=listModules path=/modules method=GET
   */
  public async list(pageNumber: number = 1, pageSize: number = 50): Promise<PagedResults<Module>> {
    if (pageNumber) {
      await Int32.parse(pageNumber);
    }
    if (pageSize) {
      await Int32.parse(pageSize);
    }
    const bag = new PagedResults<Module>();
    bag.pageNumber = pageNumber;
    bag.pageSize = pageSize;
    await this.producer.list(bag);
    if (bag.items === null || bag.items === undefined) {
      throw new UnexpectedError("Producers must return 'items' for PagedResults queries");
    }
    return bag;
  }
  /**
   * 
   * @summary Retrieves all the operations available on a given ModuleVersion
   * @param moduleId Module ID
   * @param version Version ID or version string
   * @param pageNumber The requested page. This value is 1-indexed.
   * @param pageSize The number of items in each page of data.
   * @openapi operation=listOperations path=/modules/{moduleId}/versions/{version}/operations method=GET
   */
  public async listOperations(moduleId: UUID, version: string, pageNumber: number = 1, pageSize: number = 50): Promise<PagedResults<Operation>> {
    // verify required parameter 'moduleId' is not null or undefined
    if (moduleId === null || moduleId === undefined) {
      throw new ParameterRequiredError('moduleId');
    }
    // verify required parameter 'version' is not null or undefined
    if (version === null || version === undefined || version === '') {
      throw new ParameterRequiredError('version');
    }
    if (pageNumber) {
      await Int32.parse(pageNumber);
    }
    if (pageSize) {
      await Int32.parse(pageSize);
    }
    const bag = new PagedResults<Operation>();
    bag.pageNumber = pageNumber;
    bag.pageSize = pageSize;
    await this.producer.listOperations(bag, moduleId, version);
    if (bag.items === null || bag.items === undefined) {
      throw new UnexpectedError("Producers must return 'items' for PagedResults queries");
    }
    return bag;
  }
  /**
   * 
   * @summary Retrieves all versions of a given module
   * @param id Module ID
   * @param pageNumber The requested page. This value is 1-indexed.
   * @param pageSize The number of items in each page of data.
   * @openapi operation=listVersions path=/modules/{id}/versions method=GET
   */
  public async listVersions(id: UUID, pageNumber: number = 1, pageSize: number = 50): Promise<PagedResults<ModuleVersion>> {
    // verify required parameter 'id' is not null or undefined
    if (id === null || id === undefined) {
      throw new ParameterRequiredError('id');
    }
    if (pageNumber) {
      await Int32.parse(pageNumber);
    }
    if (pageSize) {
      await Int32.parse(pageSize);
    }
    const bag = new PagedResults<ModuleVersion>();
    bag.pageNumber = pageNumber;
    bag.pageSize = pageSize;
    await this.producer.listVersions(bag, id);
    if (bag.items === null || bag.items === undefined) {
      throw new UnexpectedError("Producers must return 'items' for PagedResults queries");
    }
    return bag;
  }
  /**
   * Synchronize the database with the store
   * @summary Synchronizes the modules in the database with the store
   * @param allVersions Optionally sync all versions, not just the latest
   * @param moduleId Optionally specify a specific module
   * @param version Optionally specify a specific version for the module, default to latest
   * @openapi operation=storeSync path=/storeSync method=GET
   */
  public async storeSync(allVersions?: boolean, moduleId?: UUID, version?: string): Promise<void> {
    return this.producer.storeSync(allVersions, moduleId, version);
  }
}

/**
 * Wrap producer with mapping implementation
 */
export function wrapModuleProducer(producer: ModuleProducerApi): ModuleApi {
  return new ModuleApiMappingImpl(producer);
}

/**
 * ModuleApiHttpImpl - Direct HTTP implementation
 *
 * Makes direct HTTP calls to the API using Axios.
 * Used by SDK clients for platform service access.
 */
export class ModuleApiHttpImpl implements ModuleProducerApi {
  private client: AxiosInstance;
  private headers: Record<string, string>;

  constructor(client: AxiosInstance, headers: Record<string, string> = {}) {
    this.client = client;
    this.headers = headers;
  }

  async getDependencyReport(moduleKeyOrId: string, version?: VersionRange, nodeId?: UUID): Promise<ModuleDependencyReport> {
  const _queryParams = {
      version,nodeId,
  };
  const _bodyParams = {
      
  };
  let _path = '/modules/{moduleKeyOrId}/dependencies';
  _path = _path.replace('{moduleKeyOrId}', encodeURIComponent(String(moduleKeyOrId)));
  return this.client.get(
    _path,
    { params: _queryParams })
    .then((response) => {
      // BaseApiClient uses validateStatus: () => true, so we must check status manually
      if (response.status >= 400) {
        throw CoreError.deserialize(response.data);
      }
      return ObjectSerializer.deserialize(response.data, 'ModuleDependencyReport')
    })
    .catch((error) => {
      if (error.data) {
        throw CoreError.deserialize(error.data);
      } else {
        throw error;
      }
    });
  }
  async get(id: UUID): Promise<Module> {
  const _queryParams = {
      
  };
  const _bodyParams = {
      
  };
  let _path = '/modules/{id}';
  _path = _path.replace('{id}', encodeURIComponent(String(id)));
  return this.client.get(
    _path,
    { params: _queryParams })
    .then((response) => {
      // BaseApiClient uses validateStatus: () => true, so we must check status manually
      if (response.status >= 400) {
        throw CoreError.deserialize(response.data);
      }
      return ObjectSerializer.deserialize(response.data, 'Module')
    })
    .catch((error) => {
      if (error.data) {
        throw CoreError.deserialize(error.data);
      } else {
        throw error;
      }
    });
  }
  async getModuleVersion(moduleId: UUID, version: string): Promise<ModuleVersion> {
  const _queryParams = {
      
  };
  const _bodyParams = {
      
  };
  let _path = '/modules/{moduleId}/versions/{version}';
  _path = _path.replace('{moduleId}', encodeURIComponent(String(moduleId)));
  _path = _path.replace('{version}', encodeURIComponent(String(version)));
  return this.client.get(
    _path,
    { params: _queryParams })
    .then((response) => {
      // BaseApiClient uses validateStatus: () => true, so we must check status manually
      if (response.status >= 400) {
        throw CoreError.deserialize(response.data);
      }
      return ObjectSerializer.deserialize(response.data, 'ModuleVersion')
    })
    .catch((error) => {
      if (error.data) {
        throw CoreError.deserialize(error.data);
      } else {
        throw error;
      }
    });
  }
  async getModuleVersionById(moduleVersionId: UUID): Promise<ModuleVersion> {
  const _queryParams = {
      
  };
  const _bodyParams = {
      
  };
  let _path = '/moduleVersions/{moduleVersionId}';
  _path = _path.replace('{moduleVersionId}', encodeURIComponent(String(moduleVersionId)));
  return this.client.get(
    _path,
    { params: _queryParams })
    .then((response) => {
      // BaseApiClient uses validateStatus: () => true, so we must check status manually
      if (response.status >= 400) {
        throw CoreError.deserialize(response.data);
      }
      return ObjectSerializer.deserialize(response.data, 'ModuleVersion')
    })
    .catch((error) => {
      if (error.data) {
        throw CoreError.deserialize(error.data);
      } else {
        throw error;
      }
    });
  }
  async list(results: PagedResults<Module>): Promise<void> {
  const _body = {
      
  };
  let _path = '/modules';
  return this.client.get(
    _path,
    {
      params: {
        ..._body,
        pageNumber: results.pageNumber,
        pageSize: results.pageSize,
      }
    })
    .then((response) => {
      // BaseApiClient uses validateStatus: () => true, so we must check status manually
      if (response.status >= 400) {
        throw CoreError.deserialize(response.data);
      }
      results.items = ObjectSerializer.deserialize(response.data, 'Array<Module>');
      results.count = response.headers.count ? Number(response.headers.count) : -1;
      results.pageToken = response.headers.pagetoken ?? response.headers.pageToken;
      results.headers = this.headers;
      results.baseUrl = new URL(`${this.client.getUri()}/modules`);
      results.httpMethod = HttpMethod.Get;
      results.body = _body;
      results.mapper = (obj) => ObjectSerializer.deserialize(obj, 'Module');
    })
    .catch((error) => {
      if (error.data) {
        throw CoreError.deserialize(error.data);
      } else {
        throw error;
      }
    });
  }
  async listOperations(results: PagedResults<Operation>, moduleId: UUID, version: string): Promise<void> {
  const _body = {
      moduleId,version,
  };
  let _path = '/modules/{moduleId}/versions/{version}/operations';
  _path = _path.replace('{moduleId}', encodeURIComponent(String(moduleId)));
  _path = _path.replace('{version}', encodeURIComponent(String(version)));
  return this.client.get(
    _path,
    {
      params: {
        ..._body,
        pageNumber: results.pageNumber,
        pageSize: results.pageSize,
      }
    })
    .then((response) => {
      // BaseApiClient uses validateStatus: () => true, so we must check status manually
      if (response.status >= 400) {
        throw CoreError.deserialize(response.data);
      }
      results.items = ObjectSerializer.deserialize(response.data, 'Array<Operation>');
      results.count = response.headers.count ? Number(response.headers.count) : -1;
      results.pageToken = response.headers.pagetoken ?? response.headers.pageToken;
      results.headers = this.headers;
      results.baseUrl = new URL(`${this.client.getUri()}/modules/{moduleId}/versions/{version}/operations`);
      results.httpMethod = HttpMethod.Get;
      results.body = _body;
      results.mapper = (obj) => ObjectSerializer.deserialize(obj, 'Operation');
    })
    .catch((error) => {
      if (error.data) {
        throw CoreError.deserialize(error.data);
      } else {
        throw error;
      }
    });
  }
  async listVersions(results: PagedResults<ModuleVersion>, id: UUID): Promise<void> {
  const _body = {
      id,
  };
  let _path = '/modules/{id}/versions';
  _path = _path.replace('{id}', encodeURIComponent(String(id)));
  return this.client.get(
    _path,
    {
      params: {
        ..._body,
        pageNumber: results.pageNumber,
        pageSize: results.pageSize,
      }
    })
    .then((response) => {
      // BaseApiClient uses validateStatus: () => true, so we must check status manually
      if (response.status >= 400) {
        throw CoreError.deserialize(response.data);
      }
      results.items = ObjectSerializer.deserialize(response.data, 'Array<ModuleVersion>');
      results.count = response.headers.count ? Number(response.headers.count) : -1;
      results.pageToken = response.headers.pagetoken ?? response.headers.pageToken;
      results.headers = this.headers;
      results.baseUrl = new URL(`${this.client.getUri()}/modules/{id}/versions`);
      results.httpMethod = HttpMethod.Get;
      results.body = _body;
      results.mapper = (obj) => ObjectSerializer.deserialize(obj, 'ModuleVersion');
    })
    .catch((error) => {
      if (error.data) {
        throw CoreError.deserialize(error.data);
      } else {
        throw error;
      }
    });
  }
  async storeSync(allVersions?: boolean, moduleId?: UUID, version?: string): Promise<void> {
  const _queryParams = {
      allVersions,moduleId,version,
  };
  const _bodyParams = {
      
  };
  let _path = '/storeSync';
  return this.client.get(
    _path,
    { params: _queryParams })
    .then((response) => {
      // BaseApiClient uses validateStatus: () => true, so we must check status manually
      if (response.status >= 400) {
        throw CoreError.deserialize(response.data);
      }
      return ObjectSerializer.deserialize(response.data, '')
    })
    .catch((error) => {
      if (error.data) {
        throw CoreError.deserialize(error.data);
      } else {
        throw error;
      }
    });
  }
}
