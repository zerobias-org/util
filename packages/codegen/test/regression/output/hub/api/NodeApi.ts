/* eslint-disable */
// ===============================================
// This file is autogenerated - Please do not edit
// ===============================================
import { AxiosInstance } from 'axios';
import { AddTag, ClaimNodeBody, ConnectionListView, CreateNodeDeployment, CreateRegistration, DeploymentSlimView, DeploymentView, EnvVar, MigrateNodeBody, MigrateNodeCheckBody, MigrateNodeCheckResponse, Node, NodeInfo, OperationalStatusDef, RegistrationExtended, ResultsColumnOptionsWrapper, SearchNodeBody, SearchNodeConnectionBody, Secret, SecretNode, SetVersionBody, SortObject, UpdateNode } from '../model/index.js';
import { URL, EnumValue, IllegalArgumentError, PagedResults, Int32, Semver, UUID, CoreError, ParameterRequiredError, UnexpectedError, HttpMethod } from '@zerobias-org/types-core-js';
import { RequestFile, ObjectSerializer } from '../model/index.js';

export namespace NodeApi {
}

/**
 * NodeApi - interface
 * @export
 * @interface NodeApi
 */
export interface NodeApi {
  /**
   * 
   * @summary Adds a new tag to the given Node
   * @param {UUID} id Node ID
   * @param {AddTag} addTag 
   * @param {*} [options] Override http request option.
   * @throws {@link @zerobias-org/types-core-js#ParameterRequiredError} if any required parameter is not provided
   * @example
   * ```typescript
   * const result = await api.addTag('00000000-0000-0000-0000-000000000000', null);
   * ```
   * @openapi operation=addNodeTag path=/nodes/{id}/tags method=POST
   * @memberof NodeApi
   */
  addTag(id: UUID, addTag: AddTag): Promise<void>;

  /**
   * Moves a node from the lost and found to the caller organization
   * @summary Claim a node from lost and found
   * @param {string} code Registration code
   * @param {ClaimNodeBody} claimNodeBody 
   * @param {UUID} [danaOrgId] Organization ID
   * @param {*} [options] Override http request option.
   * @throws {@link @zerobias-org/types-core-js#ParameterRequiredError} if any required parameter is not provided
   * @example
   * ```typescript
   * const result = await api.claimNode('code', null, '00000000-0000-0000-0000-000000000000');
   * ```
   * @openapi operation=claimNode path=/registrations/{code}/claim method=PUT
   * @memberof NodeApi
   */
  claimNode(code: string, claimNodeBody: ClaimNodeBody, danaOrgId?: UUID): Promise<Node>;

  /**
   * This operation creates a new node. Nodes are identified by the system by the BIOS UUID of the machine they are running on. The alternate identifier is the MAC address of the machine. During the initial handshake, the MAC address will be used to sync the BIOS UUID number. Once the BIOS UUID is set, it becomes the primary identifier and is then indelible.
This method does not actually create an `Node` model, however - it just stores the registration. The registration is resolved when the node with the given MAC address connects.
   * @summary Create a new Registration
   * @param {CreateRegistration} createRegistration 
   * @param {*} [options] Override http request option.
   * @throws {@link @zerobias-org/types-core-js#ParameterRequiredError} if any required parameter is not provided
   * @example
   * ```typescript
   * const result = await api.create(null);
   * ```
   * @openapi operation=createNode path=/nodes method=POST
   * @memberof NodeApi
   */
  create(createRegistration: CreateRegistration): Promise<RegistrationExtended>;

  /**
   * Creates a new deployment
   * @summary Creates a new Deployment on this Node
   * @param {UUID} nodeId Node ID
   * @param {CreateNodeDeployment} createNodeDeployment 
   * @param {*} [options] Override http request option.
   * @throws {@link @zerobias-org/types-core-js#ParameterRequiredError} if any required parameter is not provided
   * @example
   * ```typescript
   * const result = await api.createNodeDeployment('00000000-0000-0000-0000-000000000000', null);
   * ```
   * @openapi operation=createNodeDeployment path=/nodes/{nodeId}/deployments method=POST
   * @memberof NodeApi
   */
  createNodeDeployment(nodeId: UUID, createNodeDeployment: CreateNodeDeployment): Promise<DeploymentView>;

  /**
   * Deletes a node by its identifier. This will evict the Node if it is currently connected.
   * @summary Deletes an node
   * @param {UUID} id Node ID
   * @param {boolean} [cascadeDeployments] If &#x60;true&#x60;, this operation will also delete all &#x60;Deployments&#x60; on the &#x60;Node&#x60;
   * @param {boolean} [cascadeConnections] If &#x60;true&#x60;, this operation will also delete all &#x60;Connections&#x60; under all &#x60;Deployments&#x60;  on the &#x60;Node&#x60;. Note that if &#x60;cascadeDeployments&#x60; is &#x60;false&#x60;, the value of  &#x60;cascadeConnections&#x60; does not matter
   * @param {*} [options] Override http request option.
   * @throws {@link @zerobias-org/types-core-js#ParameterRequiredError} if any required parameter is not provided
   * @example
   * ```typescript
   * const result = await api.delete('00000000-0000-0000-0000-000000000000', true, true);
   * ```
   * @openapi operation=deleteNode path=/nodes/{id} method=DELETE
   * @memberof NodeApi
   */
  delete(id: UUID, cascadeDeployments?: boolean, cascadeConnections?: boolean): Promise<void>;

  /**
   * Deletes a Registration by its identifier
   * @summary Delete an registration by ID or code
   * @param {string} id Registration ID or code
   * @param {*} [options] Override http request option.
   * @throws {@link @zerobias-org/types-core-js#ParameterRequiredError} if any required parameter is not provided
   * @example
   * ```typescript
   * const result = await api.deleteRegistration('id');
   * ```
   * @openapi operation=deleteRegistration path=/registrations/{id} method=DELETE
   * @memberof NodeApi
   */
  deleteRegistration(id: string): Promise<void>;

  /**
   * This will download the latest compliance scan summary
   * @summary Download the latest compliance scan summary
   * @param {UUID} id Node ID
   * @param {*} [options] Override http request option.
   * @throws {@link @zerobias-org/types-core-js#ParameterRequiredError} if any required parameter is not provided
   * @example
   * ```typescript
   * const result = await api.downloadComplianceReport('00000000-0000-0000-0000-000000000000');
   * ```
   * @openapi operation=downloadComplianceReport path=/nodes/{id}/appliance/complianceScan/download method=GET
   * @memberof NodeApi
   */
  downloadComplianceReport(id: UUID): Promise<void>;

  /**
   * Forces a node to ensure it and its child nodes deployments
   * @summary Forces a node to ensure it and its child nodes deployments
   * @param {UUID} nodeId Node ID
   * @param {*} [options] Override http request option.
   * @throws {@link @zerobias-org/types-core-js#ParameterRequiredError} if any required parameter is not provided
   * @example
   * ```typescript
   * const result = await api.ensureDeployments('00000000-0000-0000-0000-000000000000');
   * ```
   * @openapi operation=ensureDeployments path=/nodes/{nodeId}/ensureDeployments method=POST
   * @memberof NodeApi
   */
  ensureDeployments(nodeId: UUID): Promise<void>;

  /**
   * Retrieves an node's info
   * @summary Retrieve an node's info
   * @param {UUID} id Node ID
   * @param {*} [options] Override http request option.
   * @throws {@link @zerobias-org/types-core-js#ParameterRequiredError} if any required parameter is not provided
   * @example
   * ```typescript
   * const result = await api.getInfo('00000000-0000-0000-0000-000000000000');
   * ```
   * @openapi operation=getInfo path=/nodes/{id}/info method=GET
   * @memberof NodeApi
   */
  getInfo(id: UUID): Promise<NodeInfo>;

  /**
   * Retrieves a node by its identifier
   * @summary Retrieve an node
   * @param {UUID} id Node ID
   * @param {*} [options] Override http request option.
   * @throws {@link @zerobias-org/types-core-js#ParameterRequiredError} if any required parameter is not provided
   * @example
   * ```typescript
   * const result = await api.get('00000000-0000-0000-0000-000000000000');
   * ```
   * @openapi operation=getNode path=/nodes/{id} method=GET
   * @memberof NodeApi
   */
  get(id: UUID): Promise<Node>;

  /**
   * Gets latest node version.
   * @summary Gets latest node version
   * @param {UUID} id Node ID
   * @param {*} [options] Override http request option.
   * @throws {@link @zerobias-org/types-core-js#ParameterRequiredError} if any required parameter is not provided
   * @example
   * ```typescript
   * const result = await api.getNodeAvailableLatestVersion('00000000-0000-0000-0000-000000000000');
   * ```
   * @openapi operation=getNodeAvailableLatestVersion path=/nodes/{id}/latestAvailableVersion method=GET
   * @memberof NodeApi
   */
  getNodeAvailableLatestVersion(id: UUID): Promise<Semver>;

  /**
   * Retrieves a Registration by its identifier
   * @summary Retrieve an registration by ID or code
   * @param {string} id Registration ID or code
   * @param {*} [options] Override http request option.
   * @throws {@link @zerobias-org/types-core-js#ParameterRequiredError} if any required parameter is not provided
   * @example
   * ```typescript
   * const result = await api.getRegistration('id');
   * ```
   * @openapi operation=getRegistration path=/registrations/{id} method=GET
   * @memberof NodeApi
   */
  getRegistration(id: string): Promise<RegistrationExtended>;

  /**
   * Returns the writable secret path from the node
   * @summary Requests the writable secret path from the Node
   * @param {UUID} id Node ID
   * @param {*} [options] Override http request option.
   * @throws {@link @zerobias-org/types-core-js#ParameterRequiredError} if any required parameter is not provided
   * @example
   * ```typescript
   * const result = await api.getWritableSecretPath('00000000-0000-0000-0000-000000000000');
   * ```
   * @openapi operation=getWritableSecretPath path=/nodes/{id}/writableSecret method=GET
   * @memberof NodeApi
   */
  getWritableSecretPath(id: UUID): Promise<string>;

  /**
   * Retrieves all the node metadata we can determine from this node via the  `hub-node-metadata` module. If necessary, this will install the module and execute it on  the node, returning all data the module returns
   * @summary Retrieves node metadata
   * @param {UUID} id Node ID
   * @param {*} [options] Override http request option.
   * @throws {@link @zerobias-org/types-core-js#ParameterRequiredError} if any required parameter is not provided
   * @example
   * ```typescript
   * const result = await api.identify('00000000-0000-0000-0000-000000000000');
   * ```
   * @openapi operation=identifyNode path=/nodes/{id}/identify method=GET
   * @memberof NodeApi
   */
  identify(id: UUID): Promise<{ [key: string]: any; }>;

  /**
   * 
   * @summary Returns all the connections on a node using a secret
   * @param {UUID} id Node ID
   * @param {UUID} secretId Return connections that use this secret
   * @param {number} [pageNumber] The requested page. This value is 1-indexed.
   * @param {number} [pageSize] The number of items in each page of data.
   * @param {*} [options] Override http request option.
   * @throws {@link @zerobias-org/types-core-js#ParameterRequiredError} if any required parameter is not provided
   * @example
   * ```typescript
   * const result = await api.listConnectionsBySecretId('00000000-0000-0000-0000-000000000000', '00000000-0000-0000-0000-000000000000', 1, 1);
   * ```
   * @openapi operation=listConnectionsBySecretId path=/nodes/{id}/secrets/{secretId}/connections method=GET
   * @memberof NodeApi
   */
  listConnectionsBySecretId(id: UUID, secretId: UUID, pageNumber?: number, pageSize?: number): Promise<PagedResults<ConnectionListView>>;

  /**
   * 
   * @summary Retrieves all connections for this Node
   * @param {UUID} id Node ID
   * @param {number} [pageNumber] The requested page. This value is 1-indexed.
   * @param {number} [pageSize] The number of items in each page of data.
   * @param {*} [options] Override http request option.
   * @throws {@link @zerobias-org/types-core-js#ParameterRequiredError} if any required parameter is not provided
   * @example
   * ```typescript
   * const result = await api.listConnections('00000000-0000-0000-0000-000000000000', 1, 1);
   * ```
   * @openapi operation=listConnectionsForNode path=/nodes/{id}/connections method=GET
   * @memberof NodeApi
   */
  listConnections(id: UUID, pageNumber?: number, pageSize?: number): Promise<PagedResults<ConnectionListView>>;

  /**
   * 
   * @summary Returns all the deployments on a node using a secret
   * @param {UUID} id Node ID
   * @param {UUID} secretId Return deployments that use this secret
   * @param {number} [pageNumber] The requested page. This value is 1-indexed.
   * @param {number} [pageSize] The number of items in each page of data.
   * @param {*} [options] Override http request option.
   * @throws {@link @zerobias-org/types-core-js#ParameterRequiredError} if any required parameter is not provided
   * @example
   * ```typescript
   * const result = await api.listDeploymentsBySecretId('00000000-0000-0000-0000-000000000000', '00000000-0000-0000-0000-000000000000', 1, 1);
   * ```
   * @openapi operation=listDeploymentsBySecretId path=/nodes/{id}/secrets/{secretId}/deployments method=GET
   * @memberof NodeApi
   */
  listDeploymentsBySecretId(id: UUID, secretId: UUID, pageNumber?: number, pageSize?: number): Promise<PagedResults<DeploymentView>>;

  /**
   * Lists all deployments for this Node
   * @summary Lists deployments for this node
   * @param {UUID} nodeId Node ID
   * @param {number} [pageNumber] The requested page. This value is 1-indexed.
   * @param {number} [pageSize] The number of items in each page of data.
   * @param {string} [filter] An optional filter to search tags by name. This is a case-insensitive filter
   * @param {*} [options] Override http request option.
   * @throws {@link @zerobias-org/types-core-js#ParameterRequiredError} if any required parameter is not provided
   * @example
   * ```typescript
   * const result = await api.listDeployments('00000000-0000-0000-0000-000000000000', 1, 1, 'filter');
   * ```
   * @openapi operation=listDeploymentsForNode path=/nodes/{nodeId}/deployments method=GET
   * @memberof NodeApi
   */
  listDeployments(nodeId: UUID, pageNumber?: number, pageSize?: number, filter?: string): Promise<PagedResults<DeploymentView>>;

  /**
   * Lists all deployments for this Node
   * @summary Lists deployments for this node
   * @param {UUID} nodeId Node ID
   * @param {number} [pageNumber] The requested page. This value is 1-indexed.
   * @param {number} [pageSize] The number of items in each page of data.
   * @param {string} [filter] An optional filter to search tags by name. This is a case-insensitive filter
   * @param {*} [options] Override http request option.
   * @throws {@link @zerobias-org/types-core-js#ParameterRequiredError} if any required parameter is not provided
   * @example
   * ```typescript
   * const result = await api.listDeploymentsSlim('00000000-0000-0000-0000-000000000000', 1, 1, 'filter');
   * ```
   * @openapi operation=listDeploymentsSlimForNode path=/nodes/{nodeId}/slimDeployments method=GET
   * @memberof NodeApi
   */
  listDeploymentsSlim(nodeId: UUID, pageNumber?: number, pageSize?: number, filter?: string): Promise<PagedResults<DeploymentSlimView>>;

  /**
   * Lists node versions.
   * @summary Lists node versions
   * @param {UUID} id Node ID
   * @param {*} [options] Override http request option.
   * @throws {@link @zerobias-org/types-core-js#ParameterRequiredError} if any required parameter is not provided
   * @example
   * ```typescript
   * const result = await api.listNodeAvailableVersions('00000000-0000-0000-0000-000000000000');
   * ```
   * @openapi operation=listNodeAvailableVersions path=/nodes/{id}/availableVersions method=GET
   * @memberof NodeApi
   */
  listNodeAvailableVersions(id: UUID): Promise<Array<Semver>>;

  /**
   * Lists all nodes that the current caller has access to.
   * @summary Lists all Nodes
   * @param {number} [pageNumber] The requested page. This value is 1-indexed.
   * @param {number} [pageSize] The number of items in each page of data.
   * @param {string} [filter] An optional filter to search tags by name. This is a case-insensitive filter
   * @param {OperationalStatus} [status] Optional status filter
   * @param {*} [options] Override http request option.
   * @throws {@link @zerobias-org/types-core-js#ParameterRequiredError} if any required parameter is not provided
   * @example
   * ```typescript
   * const result = await api.list(1, 1, 'filter', null);
   * ```
   * @openapi operation=listNodes path=/nodes method=GET
   * @memberof NodeApi
   */
  list(pageNumber?: number, pageSize?: number, filter?: string, status?: OperationalStatusDef): Promise<PagedResults<Node>>;

  /**
   * 
   * @summary Lists all unresolved Node registrations
   * @param {number} [pageNumber] The requested page. This value is 1-indexed.
   * @param {number} [pageSize] The number of items in each page of data.
   * @param {*} [options] Override http request option.
   * @throws {@link @zerobias-org/types-core-js#ParameterRequiredError} if any required parameter is not provided
   * @example
   * ```typescript
   * const result = await api.listRegistrations(1, 1);
   * ```
   * @openapi operation=listRegistrations path=/registrations method=GET
   * @memberof NodeApi
   */
  listRegistrations(pageNumber?: number, pageSize?: number): Promise<PagedResults<RegistrationExtended>>;

  /**
   * 
   * @summary Returns all Nodes root secret keys if path not given or all Nodes secret keys
   * @param {UUID} id Node ID
   * @param {string} [path] The optional secret path
   * @param {*} [options] Override http request option.
   * @throws {@link @zerobias-org/types-core-js#ParameterRequiredError} if any required parameter is not provided
   * @example
   * ```typescript
   * const result = await api.listSecretNodes('00000000-0000-0000-0000-000000000000', 'path');
   * ```
   * @openapi operation=listSecretNodes path=/nodes/{id}/secretNodes method=GET
   * @memberof NodeApi
   */
  listSecretNodes(id: UUID, path?: string): Promise<Array<SecretNode>>;

  /**
   * 
   * @summary Returns all the shared secrets the node is using
   * @param {UUID} id Node ID
   * @param {number} [pageNumber] The requested page. This value is 1-indexed.
   * @param {number} [pageSize] The number of items in each page of data.
   * @param {UUID} [connectionProfileId] Filters Secrets to only those matching the given connectionProfileId
   * @param {*} [options] Override http request option.
   * @throws {@link @zerobias-org/types-core-js#ParameterRequiredError} if any required parameter is not provided
   * @example
   * ```typescript
   * const result = await api.listSharedSecrets('00000000-0000-0000-0000-000000000000', 1, 1, '00000000-0000-0000-0000-000000000000');
   * ```
   * @openapi operation=listSharedSecrets path=/nodes/{id}/secrets method=GET
   * @memberof NodeApi
   */
  listSharedSecrets(id: UUID, pageNumber?: number, pageSize?: number, connectionProfileId?: UUID): Promise<PagedResults<Secret>>;

  /**
   * Migrate deployments from node to node
   * @summary Migrate deployments from node to node
   * @param {UUID} nodeId Node ID
   * @param {MigrateNodeBody} migrateNodeBody 
   * @param {*} [options] Override http request option.
   * @throws {@link @zerobias-org/types-core-js#ParameterRequiredError} if any required parameter is not provided
   * @example
   * ```typescript
   * const result = await api.migrate('00000000-0000-0000-0000-000000000000', null);
   * ```
   * @openapi operation=migrateNode path=/nodes/{nodeId}/migrate method=POST
   * @memberof NodeApi
   */
  migrate(nodeId: UUID, migrateNodeBody: MigrateNodeBody): Promise<void>;

  /**
   * Check if migrate node will have any complications
   * @summary Check if migrate node will have any complications
   * @param {UUID} nodeId Node ID
   * @param {MigrateNodeCheckBody} migrateNodeCheckBody 
   * @param {*} [options] Override http request option.
   * @throws {@link @zerobias-org/types-core-js#ParameterRequiredError} if any required parameter is not provided
   * @example
   * ```typescript
   * const result = await api.migrateCheck('00000000-0000-0000-0000-000000000000', null);
   * ```
   * @openapi operation=migrateNodeCheck path=/nodes/{nodeId}/migrateCheck method=POST
   * @memberof NodeApi
   */
  migrateCheck(nodeId: UUID, migrateNodeCheckBody: MigrateNodeCheckBody): Promise<MigrateNodeCheckResponse>;

  /**
   * This will signal to the node it should run a compliance scan
   * @summary Request the node run a compliance scan and return the results file
   * @param {UUID} id Node ID
   * @param {*} [options] Override http request option.
   * @throws {@link @zerobias-org/types-core-js#ParameterRequiredError} if any required parameter is not provided
   * @example
   * ```typescript
   * const result = await api.requestComplianceScan('00000000-0000-0000-0000-000000000000');
   * ```
   * @openapi operation=requestComplianceScan path=/nodes/{id}/appliance/complianceScan/run method=GET
   * @memberof NodeApi
   */
  requestComplianceScan(id: UUID): Promise<void>;

  /**
   * This will signal to the Node that it should restart. This operation will return before  the node actually installs this version of the software which will happen in the  background.
   * @summary Requests that the Node process restart
   * @param {UUID} id Node ID
   * @param {*} [options] Override http request option.
   * @throws {@link @zerobias-org/types-core-js#ParameterRequiredError} if any required parameter is not provided
   * @example
   * ```typescript
   * const result = await api.requestRestart('00000000-0000-0000-0000-000000000000');
   * ```
   * @openapi operation=requestNodeRestart path=/nodes/{id}/restart method=PUT
   * @memberof NodeApi
   */
  requestRestart(id: UUID): Promise<void>;

  /**
   * Search connections for a given node
   * @param {UUID} id 
   * @param {SearchNodeConnectionBody} searchNodeConnectionBody 
   * @param {number} [pageNumber] The requested page. This value is 1-indexed.
   * @param {number} [pageSize] The number of items in each page of data.
   * @param {SortObject} [sort] 
   * @param {UUID} [boundaryId] The boundaryId to scope this request as
   * @param {*} [options] Override http request option.
   * @throws {@link @zerobias-org/types-core-js#ParameterRequiredError} if any required parameter is not provided
   * @example
   * ```typescript
   * const result = await api.searchConnections('00000000-0000-0000-0000-000000000000', null, 1, 1, null, '00000000-0000-0000-0000-000000000000');
   * ```
   * @openapi operation=searchNodeConnections path=/nodes/{id}/connectionSearch method=POST
   * @memberof NodeApi
   */
  searchConnections(id: UUID, searchNodeConnectionBody: SearchNodeConnectionBody, pageNumber?: number, pageSize?: number, sort?: SortObject, boundaryId?: UUID): Promise<PagedResults<ConnectionListView>>;

  /**
   * Returns options/filters for connections for a given node
   * @param {UUID} id 
   * @param {UUID} [boundaryId] The boundaryId to scope this request as
   * @param {*} [options] Override http request option.
   * @throws {@link @zerobias-org/types-core-js#ParameterRequiredError} if any required parameter is not provided
   * @example
   * ```typescript
   * const result = await api.searchConnectionOptions('00000000-0000-0000-0000-000000000000', '00000000-0000-0000-0000-000000000000');
   * ```
   * @openapi operation=searchNodeConnectionsOptions path=/nodes/{id}/connectionSearch/options method=GET
   * @memberof NodeApi
   */
  searchConnectionOptions(id: UUID, boundaryId?: UUID): Promise<ResultsColumnOptionsWrapper>;

  /**
   * Search nodes
   * @param {SearchNodeBody} searchNodeBody 
   * @param {number} [pageNumber] The requested page. This value is 1-indexed.
   * @param {number} [pageSize] The number of items in each page of data.
   * @param {SortObject} [sort] 
   * @param {*} [options] Override http request option.
   * @throws {@link @zerobias-org/types-core-js#ParameterRequiredError} if any required parameter is not provided
   * @example
   * ```typescript
   * const result = await api.search(null, 1, 1, null);
   * ```
   * @openapi operation=searchNodes path=/nodeSearch method=POST
   * @memberof NodeApi
   */
  search(searchNodeBody: SearchNodeBody, pageNumber?: number, pageSize?: number, sort?: SortObject): Promise<PagedResults<Node>>;

  /**
   * Returns options/filters for nodes
   * @param {*} [options] Override http request option.
   * @throws {@link @zerobias-org/types-core-js#ParameterRequiredError} if any required parameter is not provided
   * @openapi operation=searchNodesOptions path=/nodeSearch/options method=GET
   * @memberof NodeApi
   */
  searchOptions(): Promise<ResultsColumnOptionsWrapper>;

  /**
   * This will set an environment variable for the node service, it must be restarted to take affect
   * @summary Set an env var on a hub node appliance
   * @param {UUID} id Node ID
   * @param {string} key The environment variable key
   * @param {EnvVar} envVar 
   * @param {*} [options] Override http request option.
   * @throws {@link @zerobias-org/types-core-js#ParameterRequiredError} if any required parameter is not provided
   * @example
   * ```typescript
   * const result = await api.setEnvVar('00000000-0000-0000-0000-000000000000', 'key', null);
   * ```
   * @openapi operation=setEnvVar path=/nodes/{id}/appliance/environment/{key} method=PUT
   * @memberof NodeApi
   */
  setEnvVar(id: UUID, key: string, envVar: EnvVar): Promise<void>;

  /**
   * This will signal to the Node that a new version neeeds to be installed. The call will return before the node actually installs this version of the software which will happen in the background.
   * @summary Sets the software version of a given node
   * @param {UUID} id Node ID
   * @param {SetVersionBody} setVersionBody 
   * @param {*} [options] Override http request option.
   * @throws {@link @zerobias-org/types-core-js#ParameterRequiredError} if any required parameter is not provided
   * @example
   * ```typescript
   * const result = await api.setVersion('00000000-0000-0000-0000-000000000000', null);
   * ```
   * @openapi operation=setNodeVersion path=/nodes/{id}/version method=PUT
   * @memberof NodeApi
   */
  setVersion(id: UUID, setVersionBody: SetVersionBody): Promise<void>;

  /**
   * This will unset an environment variable for the node service, it must be restarted to take affect
   * @summary Unset an env var on a hub node appliance
   * @param {UUID} id Node ID
   * @param {string} key The environment variable key
   * @param {*} [options] Override http request option.
   * @throws {@link @zerobias-org/types-core-js#ParameterRequiredError} if any required parameter is not provided
   * @example
   * ```typescript
   * const result = await api.unsetEnvVar('00000000-0000-0000-0000-000000000000', 'key');
   * ```
   * @openapi operation=unsetEnvVar path=/nodes/{id}/appliance/environment/{key} method=DELETE
   * @memberof NodeApi
   */
  unsetEnvVar(id: UUID, key: string): Promise<void>;

  /**
   * Update a node by its identifier
   * @summary Update a node
   * @param {UUID} id Node ID
   * @param {UpdateNode} updateNode 
   * @param {*} [options] Override http request option.
   * @throws {@link @zerobias-org/types-core-js#ParameterRequiredError} if any required parameter is not provided
   * @example
   * ```typescript
   * const result = await api.update('00000000-0000-0000-0000-000000000000', null);
   * ```
   * @openapi operation=update path=/nodes/{id} method=PUT
   * @memberof NodeApi
   */
  update(id: UUID, updateNode: UpdateNode): Promise<Node>;

  /**
   * This will View the latest compliance scan summary
   * @summary View the latest compliance scan summary
   * @param {UUID} id Node ID
   * @param {*} [options] Override http request option.
   * @throws {@link @zerobias-org/types-core-js#ParameterRequiredError} if any required parameter is not provided
   * @example
   * ```typescript
   * const result = await api.viewComplianceReport('00000000-0000-0000-0000-000000000000');
   * ```
   * @openapi operation=viewComplianceReport path=/nodes/{id}/appliance/complianceScan/view method=GET
   * @memberof NodeApi
   */
  viewComplianceReport(id: UUID): Promise<void>;

}

/**
 * NodeProducerApi - interface
 * Producer interface for Node
 * @export
 * @interface NodeProducerApi
 */
export interface NodeProducerApi {
  /**
  * 
  * @summary Adds a new tag to the given Node
  * @param {UUID} id Node ID
  * @param {AddTag} addTag 
  * @param {*} [options] Override http request option.
  * @throws {@link @zerobias-org/types-core-js#ParameterRequiredError} if any required parameter is not provided
  * @openapi operation=addNodeTag path=/nodes/{id}/tags method=POST
  * @memberof Node
  */
  addTag(id: UUID, addTag: AddTag): Promise<void>;
  /**
  * Moves a node from the lost and found to the caller organization
  * @summary Claim a node from lost and found
  * @param {string} code Registration code
  * @param {ClaimNodeBody} claimNodeBody 
  * @param {UUID} [danaOrgId] Organization ID
  * @param {*} [options] Override http request option.
  * @throws {@link @zerobias-org/types-core-js#ParameterRequiredError} if any required parameter is not provided
  * @openapi operation=claimNode path=/registrations/{code}/claim method=PUT
  * @memberof Node
  */
  claimNode(code: string, claimNodeBody: ClaimNodeBody, danaOrgId?: UUID): Promise<Node>;
  /**
  * This operation creates a new node. Nodes are identified by the system by the BIOS UUID of the machine they are running on. The alternate identifier is the MAC address of the machine. During the initial handshake, the MAC address will be used to sync the BIOS UUID number. Once the BIOS UUID is set, it becomes the primary identifier and is then indelible.
This method does not actually create an `Node` model, however - it just stores the registration. The registration is resolved when the node with the given MAC address connects.
  * @summary Create a new Registration
  * @param {CreateRegistration} createRegistration 
  * @param {*} [options] Override http request option.
  * @throws {@link @zerobias-org/types-core-js#ParameterRequiredError} if any required parameter is not provided
  * @openapi operation=createNode path=/nodes method=POST
  * @memberof Node
  */
  create(createRegistration: CreateRegistration): Promise<RegistrationExtended>;
  /**
  * Creates a new deployment
  * @summary Creates a new Deployment on this Node
  * @param {UUID} nodeId Node ID
  * @param {CreateNodeDeployment} createNodeDeployment 
  * @param {*} [options] Override http request option.
  * @throws {@link @zerobias-org/types-core-js#ParameterRequiredError} if any required parameter is not provided
  * @openapi operation=createNodeDeployment path=/nodes/{nodeId}/deployments method=POST
  * @memberof Node
  */
  createNodeDeployment(nodeId: UUID, createNodeDeployment: CreateNodeDeployment): Promise<DeploymentView>;
  /**
  * Deletes a node by its identifier. This will evict the Node if it is currently connected.
  * @summary Deletes an node
  * @param {UUID} id Node ID
  * @param {boolean} [cascadeDeployments] If &#x60;true&#x60;, this operation will also delete all &#x60;Deployments&#x60; on the &#x60;Node&#x60;
  * @param {boolean} [cascadeConnections] If &#x60;true&#x60;, this operation will also delete all &#x60;Connections&#x60; under all &#x60;Deployments&#x60;  on the &#x60;Node&#x60;. Note that if &#x60;cascadeDeployments&#x60; is &#x60;false&#x60;, the value of  &#x60;cascadeConnections&#x60; does not matter
  * @param {*} [options] Override http request option.
  * @throws {@link @zerobias-org/types-core-js#ParameterRequiredError} if any required parameter is not provided
  * @openapi operation=deleteNode path=/nodes/{id} method=DELETE
  * @memberof Node
  */
  delete(id: UUID, cascadeDeployments?: boolean, cascadeConnections?: boolean): Promise<void>;
  /**
  * Deletes a Registration by its identifier
  * @summary Delete an registration by ID or code
  * @param {string} id Registration ID or code
  * @param {*} [options] Override http request option.
  * @throws {@link @zerobias-org/types-core-js#ParameterRequiredError} if any required parameter is not provided
  * @openapi operation=deleteRegistration path=/registrations/{id} method=DELETE
  * @memberof Node
  */
  deleteRegistration(id: string): Promise<void>;
  /**
  * This will download the latest compliance scan summary
  * @summary Download the latest compliance scan summary
  * @param {UUID} id Node ID
  * @param {*} [options] Override http request option.
  * @throws {@link @zerobias-org/types-core-js#ParameterRequiredError} if any required parameter is not provided
  * @openapi operation=downloadComplianceReport path=/nodes/{id}/appliance/complianceScan/download method=GET
  * @memberof Node
  */
  downloadComplianceReport(id: UUID): Promise<void>;
  /**
  * Forces a node to ensure it and its child nodes deployments
  * @summary Forces a node to ensure it and its child nodes deployments
  * @param {UUID} nodeId Node ID
  * @param {*} [options] Override http request option.
  * @throws {@link @zerobias-org/types-core-js#ParameterRequiredError} if any required parameter is not provided
  * @openapi operation=ensureDeployments path=/nodes/{nodeId}/ensureDeployments method=POST
  * @memberof Node
  */
  ensureDeployments(nodeId: UUID): Promise<void>;
  /**
  * Retrieves an node's info
  * @summary Retrieve an node's info
  * @param {UUID} id Node ID
  * @param {*} [options] Override http request option.
  * @throws {@link @zerobias-org/types-core-js#ParameterRequiredError} if any required parameter is not provided
  * @openapi operation=getInfo path=/nodes/{id}/info method=GET
  * @memberof Node
  */
  getInfo(id: UUID): Promise<NodeInfo>;
  /**
  * Retrieves a node by its identifier
  * @summary Retrieve an node
  * @param {UUID} id Node ID
  * @param {*} [options] Override http request option.
  * @throws {@link @zerobias-org/types-core-js#ParameterRequiredError} if any required parameter is not provided
  * @openapi operation=getNode path=/nodes/{id} method=GET
  * @memberof Node
  */
  get(id: UUID): Promise<Node>;
  /**
  * Gets latest node version.
  * @summary Gets latest node version
  * @param {UUID} id Node ID
  * @param {*} [options] Override http request option.
  * @throws {@link @zerobias-org/types-core-js#ParameterRequiredError} if any required parameter is not provided
  * @openapi operation=getNodeAvailableLatestVersion path=/nodes/{id}/latestAvailableVersion method=GET
  * @memberof Node
  */
  getNodeAvailableLatestVersion(id: UUID): Promise<Semver>;
  /**
  * Retrieves a Registration by its identifier
  * @summary Retrieve an registration by ID or code
  * @param {string} id Registration ID or code
  * @param {*} [options] Override http request option.
  * @throws {@link @zerobias-org/types-core-js#ParameterRequiredError} if any required parameter is not provided
  * @openapi operation=getRegistration path=/registrations/{id} method=GET
  * @memberof Node
  */
  getRegistration(id: string): Promise<RegistrationExtended>;
  /**
  * Returns the writable secret path from the node
  * @summary Requests the writable secret path from the Node
  * @param {UUID} id Node ID
  * @param {*} [options] Override http request option.
  * @throws {@link @zerobias-org/types-core-js#ParameterRequiredError} if any required parameter is not provided
  * @openapi operation=getWritableSecretPath path=/nodes/{id}/writableSecret method=GET
  * @memberof Node
  */
  getWritableSecretPath(id: UUID): Promise<string>;
  /**
  * Retrieves all the node metadata we can determine from this node via the  `hub-node-metadata` module. If necessary, this will install the module and execute it on  the node, returning all data the module returns
  * @summary Retrieves node metadata
  * @param {UUID} id Node ID
  * @param {*} [options] Override http request option.
  * @throws {@link @zerobias-org/types-core-js#ParameterRequiredError} if any required parameter is not provided
  * @openapi operation=identifyNode path=/nodes/{id}/identify method=GET
  * @memberof Node
  */
  identify(id: UUID): Promise<{ [key: string]: any; }>;
  /**
  * 
  * @summary Returns all the connections on a node using a secret
  * @param {UUID} id Node ID
  * @param {UUID} secretId Return connections that use this secret
  * @param {*} [options] Override http request option.
  * @throws {@link @zerobias-org/types-core-js#ParameterRequiredError} if any required parameter is not provided
  * @openapi operation=listConnectionsBySecretId path=/nodes/{id}/secrets/{secretId}/connections method=GET
  * @memberof Node
  */
  listConnectionsBySecretId(results: PagedResults<ConnectionListView>, id: UUID, secretId: UUID): Promise<void>;
  /**
  * 
  * @summary Retrieves all connections for this Node
  * @param {UUID} id Node ID
  * @param {*} [options] Override http request option.
  * @throws {@link @zerobias-org/types-core-js#ParameterRequiredError} if any required parameter is not provided
  * @openapi operation=listConnectionsForNode path=/nodes/{id}/connections method=GET
  * @memberof Node
  */
  listConnections(results: PagedResults<ConnectionListView>, id: UUID): Promise<void>;
  /**
  * 
  * @summary Returns all the deployments on a node using a secret
  * @param {UUID} id Node ID
  * @param {UUID} secretId Return deployments that use this secret
  * @param {*} [options] Override http request option.
  * @throws {@link @zerobias-org/types-core-js#ParameterRequiredError} if any required parameter is not provided
  * @openapi operation=listDeploymentsBySecretId path=/nodes/{id}/secrets/{secretId}/deployments method=GET
  * @memberof Node
  */
  listDeploymentsBySecretId(results: PagedResults<DeploymentView>, id: UUID, secretId: UUID): Promise<void>;
  /**
  * Lists all deployments for this Node
  * @summary Lists deployments for this node
  * @param {UUID} nodeId Node ID
  * @param {string} [filter] An optional filter to search tags by name. This is a case-insensitive filter
  * @param {*} [options] Override http request option.
  * @throws {@link @zerobias-org/types-core-js#ParameterRequiredError} if any required parameter is not provided
  * @openapi operation=listDeploymentsForNode path=/nodes/{nodeId}/deployments method=GET
  * @memberof Node
  */
  listDeployments(results: PagedResults<DeploymentView>, nodeId: UUID, filter?: string): Promise<void>;
  /**
  * Lists all deployments for this Node
  * @summary Lists deployments for this node
  * @param {UUID} nodeId Node ID
  * @param {string} [filter] An optional filter to search tags by name. This is a case-insensitive filter
  * @param {*} [options] Override http request option.
  * @throws {@link @zerobias-org/types-core-js#ParameterRequiredError} if any required parameter is not provided
  * @openapi operation=listDeploymentsSlimForNode path=/nodes/{nodeId}/slimDeployments method=GET
  * @memberof Node
  */
  listDeploymentsSlim(results: PagedResults<DeploymentSlimView>, nodeId: UUID, filter?: string): Promise<void>;
  /**
  * Lists node versions.
  * @summary Lists node versions
  * @param {UUID} id Node ID
  * @param {*} [options] Override http request option.
  * @throws {@link @zerobias-org/types-core-js#ParameterRequiredError} if any required parameter is not provided
  * @openapi operation=listNodeAvailableVersions path=/nodes/{id}/availableVersions method=GET
  * @memberof Node
  */
  listNodeAvailableVersions(id: UUID): Promise<Array<Semver>>;
  /**
  * Lists all nodes that the current caller has access to.
  * @summary Lists all Nodes
  * @param {string} [filter] An optional filter to search tags by name. This is a case-insensitive filter
  * @param {OperationalStatus} [status] Optional status filter
  * @param {*} [options] Override http request option.
  * @throws {@link @zerobias-org/types-core-js#ParameterRequiredError} if any required parameter is not provided
  * @openapi operation=listNodes path=/nodes method=GET
  * @memberof Node
  */
  list(results: PagedResults<Node>, filter?: string, status?: OperationalStatusDef): Promise<void>;
  /**
  * 
  * @summary Lists all unresolved Node registrations
  * @param {*} [options] Override http request option.
  * @throws {@link @zerobias-org/types-core-js#ParameterRequiredError} if any required parameter is not provided
  * @openapi operation=listRegistrations path=/registrations method=GET
  * @memberof Node
  */
  listRegistrations(results: PagedResults<RegistrationExtended>): Promise<void>;
  /**
  * 
  * @summary Returns all Nodes root secret keys if path not given or all Nodes secret keys
  * @param {UUID} id Node ID
  * @param {string} [path] The optional secret path
  * @param {*} [options] Override http request option.
  * @throws {@link @zerobias-org/types-core-js#ParameterRequiredError} if any required parameter is not provided
  * @openapi operation=listSecretNodes path=/nodes/{id}/secretNodes method=GET
  * @memberof Node
  */
  listSecretNodes(id: UUID, path?: string): Promise<Array<SecretNode>>;
  /**
  * 
  * @summary Returns all the shared secrets the node is using
  * @param {UUID} id Node ID
  * @param {UUID} [connectionProfileId] Filters Secrets to only those matching the given connectionProfileId
  * @param {*} [options] Override http request option.
  * @throws {@link @zerobias-org/types-core-js#ParameterRequiredError} if any required parameter is not provided
  * @openapi operation=listSharedSecrets path=/nodes/{id}/secrets method=GET
  * @memberof Node
  */
  listSharedSecrets(results: PagedResults<Secret>, id: UUID, connectionProfileId?: UUID): Promise<void>;
  /**
  * Migrate deployments from node to node
  * @summary Migrate deployments from node to node
  * @param {UUID} nodeId Node ID
  * @param {MigrateNodeBody} migrateNodeBody 
  * @param {*} [options] Override http request option.
  * @throws {@link @zerobias-org/types-core-js#ParameterRequiredError} if any required parameter is not provided
  * @openapi operation=migrateNode path=/nodes/{nodeId}/migrate method=POST
  * @memberof Node
  */
  migrate(nodeId: UUID, migrateNodeBody: MigrateNodeBody): Promise<void>;
  /**
  * Check if migrate node will have any complications
  * @summary Check if migrate node will have any complications
  * @param {UUID} nodeId Node ID
  * @param {MigrateNodeCheckBody} migrateNodeCheckBody 
  * @param {*} [options] Override http request option.
  * @throws {@link @zerobias-org/types-core-js#ParameterRequiredError} if any required parameter is not provided
  * @openapi operation=migrateNodeCheck path=/nodes/{nodeId}/migrateCheck method=POST
  * @memberof Node
  */
  migrateCheck(nodeId: UUID, migrateNodeCheckBody: MigrateNodeCheckBody): Promise<MigrateNodeCheckResponse>;
  /**
  * This will signal to the node it should run a compliance scan
  * @summary Request the node run a compliance scan and return the results file
  * @param {UUID} id Node ID
  * @param {*} [options] Override http request option.
  * @throws {@link @zerobias-org/types-core-js#ParameterRequiredError} if any required parameter is not provided
  * @openapi operation=requestComplianceScan path=/nodes/{id}/appliance/complianceScan/run method=GET
  * @memberof Node
  */
  requestComplianceScan(id: UUID): Promise<void>;
  /**
  * This will signal to the Node that it should restart. This operation will return before  the node actually installs this version of the software which will happen in the  background.
  * @summary Requests that the Node process restart
  * @param {UUID} id Node ID
  * @param {*} [options] Override http request option.
  * @throws {@link @zerobias-org/types-core-js#ParameterRequiredError} if any required parameter is not provided
  * @openapi operation=requestNodeRestart path=/nodes/{id}/restart method=PUT
  * @memberof Node
  */
  requestRestart(id: UUID): Promise<void>;
  /**
  * Search connections for a given node
  * @param {UUID} id 
  * @param {SearchNodeConnectionBody} searchNodeConnectionBody 
  * @param {SortObject} [sort] 
  * @param {UUID} [boundaryId] The boundaryId to scope this request as
  * @param {*} [options] Override http request option.
  * @throws {@link @zerobias-org/types-core-js#ParameterRequiredError} if any required parameter is not provided
  * @openapi operation=searchNodeConnections path=/nodes/{id}/connectionSearch method=POST
  * @memberof Node
  */
  searchConnections(results: PagedResults<ConnectionListView>, id: UUID, searchNodeConnectionBody: SearchNodeConnectionBody, sort?: SortObject, boundaryId?: UUID): Promise<void>;
  /**
  * Returns options/filters for connections for a given node
  * @param {UUID} id 
  * @param {UUID} [boundaryId] The boundaryId to scope this request as
  * @param {*} [options] Override http request option.
  * @throws {@link @zerobias-org/types-core-js#ParameterRequiredError} if any required parameter is not provided
  * @openapi operation=searchNodeConnectionsOptions path=/nodes/{id}/connectionSearch/options method=GET
  * @memberof Node
  */
  searchConnectionOptions(id: UUID, boundaryId?: UUID): Promise<ResultsColumnOptionsWrapper>;
  /**
  * Search nodes
  * @param {SearchNodeBody} searchNodeBody 
  * @param {SortObject} [sort] 
  * @param {*} [options] Override http request option.
  * @throws {@link @zerobias-org/types-core-js#ParameterRequiredError} if any required parameter is not provided
  * @openapi operation=searchNodes path=/nodeSearch method=POST
  * @memberof Node
  */
  search(results: PagedResults<Node>, searchNodeBody: SearchNodeBody, sort?: SortObject): Promise<void>;
  /**
  * Returns options/filters for nodes
  * @param {*} [options] Override http request option.
  * @throws {@link @zerobias-org/types-core-js#ParameterRequiredError} if any required parameter is not provided
  * @openapi operation=searchNodesOptions path=/nodeSearch/options method=GET
  * @memberof Node
  */
  searchOptions(): Promise<ResultsColumnOptionsWrapper>;
  /**
  * This will set an environment variable for the node service, it must be restarted to take affect
  * @summary Set an env var on a hub node appliance
  * @param {UUID} id Node ID
  * @param {string} key The environment variable key
  * @param {EnvVar} envVar 
  * @param {*} [options] Override http request option.
  * @throws {@link @zerobias-org/types-core-js#ParameterRequiredError} if any required parameter is not provided
  * @openapi operation=setEnvVar path=/nodes/{id}/appliance/environment/{key} method=PUT
  * @memberof Node
  */
  setEnvVar(id: UUID, key: string, envVar: EnvVar): Promise<void>;
  /**
  * This will signal to the Node that a new version neeeds to be installed. The call will return before the node actually installs this version of the software which will happen in the background.
  * @summary Sets the software version of a given node
  * @param {UUID} id Node ID
  * @param {SetVersionBody} setVersionBody 
  * @param {*} [options] Override http request option.
  * @throws {@link @zerobias-org/types-core-js#ParameterRequiredError} if any required parameter is not provided
  * @openapi operation=setNodeVersion path=/nodes/{id}/version method=PUT
  * @memberof Node
  */
  setVersion(id: UUID, setVersionBody: SetVersionBody): Promise<void>;
  /**
  * This will unset an environment variable for the node service, it must be restarted to take affect
  * @summary Unset an env var on a hub node appliance
  * @param {UUID} id Node ID
  * @param {string} key The environment variable key
  * @param {*} [options] Override http request option.
  * @throws {@link @zerobias-org/types-core-js#ParameterRequiredError} if any required parameter is not provided
  * @openapi operation=unsetEnvVar path=/nodes/{id}/appliance/environment/{key} method=DELETE
  * @memberof Node
  */
  unsetEnvVar(id: UUID, key: string): Promise<void>;
  /**
  * Update a node by its identifier
  * @summary Update a node
  * @param {UUID} id Node ID
  * @param {UpdateNode} updateNode 
  * @param {*} [options] Override http request option.
  * @throws {@link @zerobias-org/types-core-js#ParameterRequiredError} if any required parameter is not provided
  * @openapi operation=update path=/nodes/{id} method=PUT
  * @memberof Node
  */
  update(id: UUID, updateNode: UpdateNode): Promise<Node>;
  /**
  * This will View the latest compliance scan summary
  * @summary View the latest compliance scan summary
  * @param {UUID} id Node ID
  * @param {*} [options] Override http request option.
  * @throws {@link @zerobias-org/types-core-js#ParameterRequiredError} if any required parameter is not provided
  * @openapi operation=viewComplianceReport path=/nodes/{id}/appliance/complianceScan/view method=GET
  * @memberof Node
  */
  viewComplianceReport(id: UUID): Promise<void>;
}

export class NodeApiMappingImpl implements NodeApi {
  private producer: NodeProducerApi;
  constructor(producer: NodeProducerApi) {
    this.producer = producer;
  }

  /**
   * 
   * @summary Adds a new tag to the given Node
   * @param id Node ID
   * @param addTag 
   * @openapi operation=addNodeTag path=/nodes/{id}/tags method=POST
   */
  public async addTag(id: UUID, addTag: AddTag): Promise<void> {
    // verify required parameter 'id' is not null or undefined
    if (id === null || id === undefined) {
      throw new ParameterRequiredError('id');
    }
    // verify required parameter 'addTag' is not null or undefined
    if (addTag === null || addTag === undefined) {
      throw new ParameterRequiredError('addTag');
    }
    return this.producer.addTag(id, addTag);
  }
  /**
   * Moves a node from the lost and found to the caller organization
   * @summary Claim a node from lost and found
   * @param code Registration code
   * @param claimNodeBody 
   * @param danaOrgId Organization ID
   * @openapi operation=claimNode path=/registrations/{code}/claim method=PUT
   */
  public async claimNode(code: string, claimNodeBody: ClaimNodeBody, danaOrgId?: UUID): Promise<Node> {
    // verify required parameter 'code' is not null or undefined
    if (code === null || code === undefined || code === '') {
      throw new ParameterRequiredError('code');
    }
    // verify required parameter 'claimNodeBody' is not null or undefined
    if (claimNodeBody === null || claimNodeBody === undefined) {
      throw new ParameterRequiredError('claimNodeBody');
    }
    return this.producer.claimNode(code, claimNodeBody, danaOrgId);
  }
  /**
   * This operation creates a new node. Nodes are identified by the system by the BIOS UUID of the machine they are running on. The alternate identifier is the MAC address of the machine. During the initial handshake, the MAC address will be used to sync the BIOS UUID number. Once the BIOS UUID is set, it becomes the primary identifier and is then indelible.
This method does not actually create an `Node` model, however - it just stores the registration. The registration is resolved when the node with the given MAC address connects.
   * @summary Create a new Registration
   * @param createRegistration 
   * @openapi operation=createNode path=/nodes method=POST
   */
  public async create(createRegistration: CreateRegistration): Promise<RegistrationExtended> {
    // verify required parameter 'createRegistration' is not null or undefined
    if (createRegistration === null || createRegistration === undefined) {
      throw new ParameterRequiredError('createRegistration');
    }
    return this.producer.create(createRegistration);
  }
  /**
   * Creates a new deployment
   * @summary Creates a new Deployment on this Node
   * @param nodeId Node ID
   * @param createNodeDeployment 
   * @openapi operation=createNodeDeployment path=/nodes/{nodeId}/deployments method=POST
   */
  public async createNodeDeployment(nodeId: UUID, createNodeDeployment: CreateNodeDeployment): Promise<DeploymentView> {
    // verify required parameter 'nodeId' is not null or undefined
    if (nodeId === null || nodeId === undefined) {
      throw new ParameterRequiredError('nodeId');
    }
    // verify required parameter 'createNodeDeployment' is not null or undefined
    if (createNodeDeployment === null || createNodeDeployment === undefined) {
      throw new ParameterRequiredError('createNodeDeployment');
    }
    return this.producer.createNodeDeployment(nodeId, createNodeDeployment);
  }
  /**
   * Deletes a node by its identifier. This will evict the Node if it is currently connected.
   * @summary Deletes an node
   * @param id Node ID
   * @param cascadeDeployments If &#x60;true&#x60;, this operation will also delete all &#x60;Deployments&#x60; on the &#x60;Node&#x60;
   * @param cascadeConnections If &#x60;true&#x60;, this operation will also delete all &#x60;Connections&#x60; under all &#x60;Deployments&#x60;  on the &#x60;Node&#x60;. Note that if &#x60;cascadeDeployments&#x60; is &#x60;false&#x60;, the value of  &#x60;cascadeConnections&#x60; does not matter
   * @openapi operation=deleteNode path=/nodes/{id} method=DELETE
   */
  public async delete(id: UUID, cascadeDeployments: boolean = false, cascadeConnections: boolean = false): Promise<void> {
    // verify required parameter 'id' is not null or undefined
    if (id === null || id === undefined) {
      throw new ParameterRequiredError('id');
    }
    return this.producer.delete(id, cascadeDeployments, cascadeConnections);
  }
  /**
   * Deletes a Registration by its identifier
   * @summary Delete an registration by ID or code
   * @param id Registration ID or code
   * @openapi operation=deleteRegistration path=/registrations/{id} method=DELETE
   */
  public async deleteRegistration(id: string): Promise<void> {
    // verify required parameter 'id' is not null or undefined
    if (id === null || id === undefined || id === '') {
      throw new ParameterRequiredError('id');
    }
    return this.producer.deleteRegistration(id);
  }
  /**
   * This will download the latest compliance scan summary
   * @summary Download the latest compliance scan summary
   * @param id Node ID
   * @openapi operation=downloadComplianceReport path=/nodes/{id}/appliance/complianceScan/download method=GET
   */
  public async downloadComplianceReport(id: UUID): Promise<void> {
    // verify required parameter 'id' is not null or undefined
    if (id === null || id === undefined) {
      throw new ParameterRequiredError('id');
    }
    return this.producer.downloadComplianceReport(id);
  }
  /**
   * Forces a node to ensure it and its child nodes deployments
   * @summary Forces a node to ensure it and its child nodes deployments
   * @param nodeId Node ID
   * @openapi operation=ensureDeployments path=/nodes/{nodeId}/ensureDeployments method=POST
   */
  public async ensureDeployments(nodeId: UUID): Promise<void> {
    // verify required parameter 'nodeId' is not null or undefined
    if (nodeId === null || nodeId === undefined) {
      throw new ParameterRequiredError('nodeId');
    }
    return this.producer.ensureDeployments(nodeId);
  }
  /**
   * Retrieves an node's info
   * @summary Retrieve an node's info
   * @param id Node ID
   * @openapi operation=getInfo path=/nodes/{id}/info method=GET
   */
  public async getInfo(id: UUID): Promise<NodeInfo> {
    // verify required parameter 'id' is not null or undefined
    if (id === null || id === undefined) {
      throw new ParameterRequiredError('id');
    }
    return this.producer.getInfo(id);
  }
  /**
   * Retrieves a node by its identifier
   * @summary Retrieve an node
   * @param id Node ID
   * @openapi operation=getNode path=/nodes/{id} method=GET
   */
  public async get(id: UUID): Promise<Node> {
    // verify required parameter 'id' is not null or undefined
    if (id === null || id === undefined) {
      throw new ParameterRequiredError('id');
    }
    return this.producer.get(id);
  }
  /**
   * Gets latest node version.
   * @summary Gets latest node version
   * @param id Node ID
   * @openapi operation=getNodeAvailableLatestVersion path=/nodes/{id}/latestAvailableVersion method=GET
   */
  public async getNodeAvailableLatestVersion(id: UUID): Promise<Semver> {
    // verify required parameter 'id' is not null or undefined
    if (id === null || id === undefined) {
      throw new ParameterRequiredError('id');
    }
    return this.producer.getNodeAvailableLatestVersion(id);
  }
  /**
   * Retrieves a Registration by its identifier
   * @summary Retrieve an registration by ID or code
   * @param id Registration ID or code
   * @openapi operation=getRegistration path=/registrations/{id} method=GET
   */
  public async getRegistration(id: string): Promise<RegistrationExtended> {
    // verify required parameter 'id' is not null or undefined
    if (id === null || id === undefined || id === '') {
      throw new ParameterRequiredError('id');
    }
    return this.producer.getRegistration(id);
  }
  /**
   * Returns the writable secret path from the node
   * @summary Requests the writable secret path from the Node
   * @param id Node ID
   * @openapi operation=getWritableSecretPath path=/nodes/{id}/writableSecret method=GET
   */
  public async getWritableSecretPath(id: UUID): Promise<string> {
    // verify required parameter 'id' is not null or undefined
    if (id === null || id === undefined) {
      throw new ParameterRequiredError('id');
    }
    return this.producer.getWritableSecretPath(id);
  }
  /**
   * Retrieves all the node metadata we can determine from this node via the  `hub-node-metadata` module. If necessary, this will install the module and execute it on  the node, returning all data the module returns
   * @summary Retrieves node metadata
   * @param id Node ID
   * @openapi operation=identifyNode path=/nodes/{id}/identify method=GET
   */
  public async identify(id: UUID): Promise<{ [key: string]: any; }> {
    // verify required parameter 'id' is not null or undefined
    if (id === null || id === undefined) {
      throw new ParameterRequiredError('id');
    }
    return this.producer.identify(id);
  }
  /**
   * 
   * @summary Returns all the connections on a node using a secret
   * @param id Node ID
   * @param secretId Return connections that use this secret
   * @param pageNumber The requested page. This value is 1-indexed.
   * @param pageSize The number of items in each page of data.
   * @openapi operation=listConnectionsBySecretId path=/nodes/{id}/secrets/{secretId}/connections method=GET
   */
  public async listConnectionsBySecretId(id: UUID, secretId: UUID, pageNumber: number = 1, pageSize: number = 50): Promise<PagedResults<ConnectionListView>> {
    // verify required parameter 'id' is not null or undefined
    if (id === null || id === undefined) {
      throw new ParameterRequiredError('id');
    }
    // verify required parameter 'secretId' is not null or undefined
    if (secretId === null || secretId === undefined) {
      throw new ParameterRequiredError('secretId');
    }
    if (pageNumber) {
      await Int32.parse(pageNumber);
    }
    if (pageSize) {
      await Int32.parse(pageSize);
    }
    const bag = new PagedResults<ConnectionListView>();
    bag.pageNumber = pageNumber;
    bag.pageSize = pageSize;
    await this.producer.listConnectionsBySecretId(bag, id, secretId);
    if (bag.items === null || bag.items === undefined) {
      throw new UnexpectedError("Producers must return 'items' for PagedResults queries");
    }
    return bag;
  }
  /**
   * 
   * @summary Retrieves all connections for this Node
   * @param id Node ID
   * @param pageNumber The requested page. This value is 1-indexed.
   * @param pageSize The number of items in each page of data.
   * @openapi operation=listConnectionsForNode path=/nodes/{id}/connections method=GET
   */
  public async listConnections(id: UUID, pageNumber: number = 1, pageSize: number = 50): Promise<PagedResults<ConnectionListView>> {
    // verify required parameter 'id' is not null or undefined
    if (id === null || id === undefined) {
      throw new ParameterRequiredError('id');
    }
    if (pageNumber) {
      await Int32.parse(pageNumber);
    }
    if (pageSize) {
      await Int32.parse(pageSize);
    }
    const bag = new PagedResults<ConnectionListView>();
    bag.pageNumber = pageNumber;
    bag.pageSize = pageSize;
    await this.producer.listConnections(bag, id);
    if (bag.items === null || bag.items === undefined) {
      throw new UnexpectedError("Producers must return 'items' for PagedResults queries");
    }
    return bag;
  }
  /**
   * 
   * @summary Returns all the deployments on a node using a secret
   * @param id Node ID
   * @param secretId Return deployments that use this secret
   * @param pageNumber The requested page. This value is 1-indexed.
   * @param pageSize The number of items in each page of data.
   * @openapi operation=listDeploymentsBySecretId path=/nodes/{id}/secrets/{secretId}/deployments method=GET
   */
  public async listDeploymentsBySecretId(id: UUID, secretId: UUID, pageNumber: number = 1, pageSize: number = 50): Promise<PagedResults<DeploymentView>> {
    // verify required parameter 'id' is not null or undefined
    if (id === null || id === undefined) {
      throw new ParameterRequiredError('id');
    }
    // verify required parameter 'secretId' is not null or undefined
    if (secretId === null || secretId === undefined) {
      throw new ParameterRequiredError('secretId');
    }
    if (pageNumber) {
      await Int32.parse(pageNumber);
    }
    if (pageSize) {
      await Int32.parse(pageSize);
    }
    const bag = new PagedResults<DeploymentView>();
    bag.pageNumber = pageNumber;
    bag.pageSize = pageSize;
    await this.producer.listDeploymentsBySecretId(bag, id, secretId);
    if (bag.items === null || bag.items === undefined) {
      throw new UnexpectedError("Producers must return 'items' for PagedResults queries");
    }
    return bag;
  }
  /**
   * Lists all deployments for this Node
   * @summary Lists deployments for this node
   * @param nodeId Node ID
   * @param pageNumber The requested page. This value is 1-indexed.
   * @param pageSize The number of items in each page of data.
   * @param filter An optional filter to search tags by name. This is a case-insensitive filter
   * @openapi operation=listDeploymentsForNode path=/nodes/{nodeId}/deployments method=GET
   */
  public async listDeployments(nodeId: UUID, pageNumber: number = 1, pageSize: number = 50, filter?: string): Promise<PagedResults<DeploymentView>> {
    // verify required parameter 'nodeId' is not null or undefined
    if (nodeId === null || nodeId === undefined) {
      throw new ParameterRequiredError('nodeId');
    }
    if (pageNumber) {
      await Int32.parse(pageNumber);
    }
    if (pageSize) {
      await Int32.parse(pageSize);
    }
    const bag = new PagedResults<DeploymentView>();
    bag.pageNumber = pageNumber;
    bag.pageSize = pageSize;
    await this.producer.listDeployments(bag, nodeId, filter);
    if (bag.items === null || bag.items === undefined) {
      throw new UnexpectedError("Producers must return 'items' for PagedResults queries");
    }
    return bag;
  }
  /**
   * Lists all deployments for this Node
   * @summary Lists deployments for this node
   * @param nodeId Node ID
   * @param pageNumber The requested page. This value is 1-indexed.
   * @param pageSize The number of items in each page of data.
   * @param filter An optional filter to search tags by name. This is a case-insensitive filter
   * @openapi operation=listDeploymentsSlimForNode path=/nodes/{nodeId}/slimDeployments method=GET
   */
  public async listDeploymentsSlim(nodeId: UUID, pageNumber: number = 1, pageSize: number = 50, filter?: string): Promise<PagedResults<DeploymentSlimView>> {
    // verify required parameter 'nodeId' is not null or undefined
    if (nodeId === null || nodeId === undefined) {
      throw new ParameterRequiredError('nodeId');
    }
    if (pageNumber) {
      await Int32.parse(pageNumber);
    }
    if (pageSize) {
      await Int32.parse(pageSize);
    }
    const bag = new PagedResults<DeploymentSlimView>();
    bag.pageNumber = pageNumber;
    bag.pageSize = pageSize;
    await this.producer.listDeploymentsSlim(bag, nodeId, filter);
    if (bag.items === null || bag.items === undefined) {
      throw new UnexpectedError("Producers must return 'items' for PagedResults queries");
    }
    return bag;
  }
  /**
   * Lists node versions.
   * @summary Lists node versions
   * @param id Node ID
   * @openapi operation=listNodeAvailableVersions path=/nodes/{id}/availableVersions method=GET
   */
  public async listNodeAvailableVersions(id: UUID): Promise<Array<Semver>> {
    // verify required parameter 'id' is not null or undefined
    if (id === null || id === undefined) {
      throw new ParameterRequiredError('id');
    }
    return this.producer.listNodeAvailableVersions(id);
  }
  /**
   * Lists all nodes that the current caller has access to.
   * @summary Lists all Nodes
   * @param pageNumber The requested page. This value is 1-indexed.
   * @param pageSize The number of items in each page of data.
   * @param filter An optional filter to search tags by name. This is a case-insensitive filter
   * @param status Optional status filter
   * @openapi operation=listNodes path=/nodes method=GET
   */
  public async list(pageNumber: number = 1, pageSize: number = 50, filter?: string, status?: OperationalStatusDef): Promise<PagedResults<Node>> {
    if (pageNumber) {
      await Int32.parse(pageNumber);
    }
    if (pageSize) {
      await Int32.parse(pageSize);
    }
    const bag = new PagedResults<Node>();
    bag.pageNumber = pageNumber;
    bag.pageSize = pageSize;
    await this.producer.list(bag, filter, status);
    if (bag.items === null || bag.items === undefined) {
      throw new UnexpectedError("Producers must return 'items' for PagedResults queries");
    }
    return bag;
  }
  /**
   * 
   * @summary Lists all unresolved Node registrations
   * @param pageNumber The requested page. This value is 1-indexed.
   * @param pageSize The number of items in each page of data.
   * @openapi operation=listRegistrations path=/registrations method=GET
   */
  public async listRegistrations(pageNumber: number = 1, pageSize: number = 50): Promise<PagedResults<RegistrationExtended>> {
    if (pageNumber) {
      await Int32.parse(pageNumber);
    }
    if (pageSize) {
      await Int32.parse(pageSize);
    }
    const bag = new PagedResults<RegistrationExtended>();
    bag.pageNumber = pageNumber;
    bag.pageSize = pageSize;
    await this.producer.listRegistrations(bag);
    if (bag.items === null || bag.items === undefined) {
      throw new UnexpectedError("Producers must return 'items' for PagedResults queries");
    }
    return bag;
  }
  /**
   * 
   * @summary Returns all Nodes root secret keys if path not given or all Nodes secret keys
   * @param id Node ID
   * @param path The optional secret path
   * @openapi operation=listSecretNodes path=/nodes/{id}/secretNodes method=GET
   */
  public async listSecretNodes(id: UUID, path?: string): Promise<Array<SecretNode>> {
    // verify required parameter 'id' is not null or undefined
    if (id === null || id === undefined) {
      throw new ParameterRequiredError('id');
    }
    return this.producer.listSecretNodes(id, path);
  }
  /**
   * 
   * @summary Returns all the shared secrets the node is using
   * @param id Node ID
   * @param pageNumber The requested page. This value is 1-indexed.
   * @param pageSize The number of items in each page of data.
   * @param connectionProfileId Filters Secrets to only those matching the given connectionProfileId
   * @openapi operation=listSharedSecrets path=/nodes/{id}/secrets method=GET
   */
  public async listSharedSecrets(id: UUID, pageNumber: number = 1, pageSize: number = 50, connectionProfileId?: UUID): Promise<PagedResults<Secret>> {
    // verify required parameter 'id' is not null or undefined
    if (id === null || id === undefined) {
      throw new ParameterRequiredError('id');
    }
    if (pageNumber) {
      await Int32.parse(pageNumber);
    }
    if (pageSize) {
      await Int32.parse(pageSize);
    }
    const bag = new PagedResults<Secret>();
    bag.pageNumber = pageNumber;
    bag.pageSize = pageSize;
    await this.producer.listSharedSecrets(bag, id, connectionProfileId);
    if (bag.items === null || bag.items === undefined) {
      throw new UnexpectedError("Producers must return 'items' for PagedResults queries");
    }
    return bag;
  }
  /**
   * Migrate deployments from node to node
   * @summary Migrate deployments from node to node
   * @param nodeId Node ID
   * @param migrateNodeBody 
   * @openapi operation=migrateNode path=/nodes/{nodeId}/migrate method=POST
   */
  public async migrate(nodeId: UUID, migrateNodeBody: MigrateNodeBody): Promise<void> {
    // verify required parameter 'nodeId' is not null or undefined
    if (nodeId === null || nodeId === undefined) {
      throw new ParameterRequiredError('nodeId');
    }
    // verify required parameter 'migrateNodeBody' is not null or undefined
    if (migrateNodeBody === null || migrateNodeBody === undefined) {
      throw new ParameterRequiredError('migrateNodeBody');
    }
    return this.producer.migrate(nodeId, migrateNodeBody);
  }
  /**
   * Check if migrate node will have any complications
   * @summary Check if migrate node will have any complications
   * @param nodeId Node ID
   * @param migrateNodeCheckBody 
   * @openapi operation=migrateNodeCheck path=/nodes/{nodeId}/migrateCheck method=POST
   */
  public async migrateCheck(nodeId: UUID, migrateNodeCheckBody: MigrateNodeCheckBody): Promise<MigrateNodeCheckResponse> {
    // verify required parameter 'nodeId' is not null or undefined
    if (nodeId === null || nodeId === undefined) {
      throw new ParameterRequiredError('nodeId');
    }
    // verify required parameter 'migrateNodeCheckBody' is not null or undefined
    if (migrateNodeCheckBody === null || migrateNodeCheckBody === undefined) {
      throw new ParameterRequiredError('migrateNodeCheckBody');
    }
    return this.producer.migrateCheck(nodeId, migrateNodeCheckBody);
  }
  /**
   * This will signal to the node it should run a compliance scan
   * @summary Request the node run a compliance scan and return the results file
   * @param id Node ID
   * @openapi operation=requestComplianceScan path=/nodes/{id}/appliance/complianceScan/run method=GET
   */
  public async requestComplianceScan(id: UUID): Promise<void> {
    // verify required parameter 'id' is not null or undefined
    if (id === null || id === undefined) {
      throw new ParameterRequiredError('id');
    }
    return this.producer.requestComplianceScan(id);
  }
  /**
   * This will signal to the Node that it should restart. This operation will return before  the node actually installs this version of the software which will happen in the  background.
   * @summary Requests that the Node process restart
   * @param id Node ID
   * @openapi operation=requestNodeRestart path=/nodes/{id}/restart method=PUT
   */
  public async requestRestart(id: UUID): Promise<void> {
    // verify required parameter 'id' is not null or undefined
    if (id === null || id === undefined) {
      throw new ParameterRequiredError('id');
    }
    return this.producer.requestRestart(id);
  }
  /**
   * Search connections for a given node
   * @param id 
   * @param searchNodeConnectionBody 
   * @param pageNumber The requested page. This value is 1-indexed.
   * @param pageSize The number of items in each page of data.
   * @param sort 
   * @param boundaryId The boundaryId to scope this request as
   * @openapi operation=searchNodeConnections path=/nodes/{id}/connectionSearch method=POST
   */
  public async searchConnections(id: UUID, searchNodeConnectionBody: SearchNodeConnectionBody, pageNumber: number = 1, pageSize: number = 50, sort?: SortObject, boundaryId?: UUID): Promise<PagedResults<ConnectionListView>> {
    // verify required parameter 'id' is not null or undefined
    if (id === null || id === undefined) {
      throw new ParameterRequiredError('id');
    }
    // verify required parameter 'searchNodeConnectionBody' is not null or undefined
    if (searchNodeConnectionBody === null || searchNodeConnectionBody === undefined) {
      throw new ParameterRequiredError('searchNodeConnectionBody');
    }
    if (pageNumber) {
      await Int32.parse(pageNumber);
    }
    if (pageSize) {
      await Int32.parse(pageSize);
    }
    const bag = new PagedResults<ConnectionListView>();
    bag.pageNumber = pageNumber;
    bag.pageSize = pageSize;
    await this.producer.searchConnections(bag, id, searchNodeConnectionBody, sort, boundaryId);
    if (bag.items === null || bag.items === undefined) {
      throw new UnexpectedError("Producers must return 'items' for PagedResults queries");
    }
    return bag;
  }
  /**
   * Returns options/filters for connections for a given node
   * @param id 
   * @param boundaryId The boundaryId to scope this request as
   * @openapi operation=searchNodeConnectionsOptions path=/nodes/{id}/connectionSearch/options method=GET
   */
  public async searchConnectionOptions(id: UUID, boundaryId?: UUID): Promise<ResultsColumnOptionsWrapper> {
    // verify required parameter 'id' is not null or undefined
    if (id === null || id === undefined) {
      throw new ParameterRequiredError('id');
    }
    return this.producer.searchConnectionOptions(id, boundaryId);
  }
  /**
   * Search nodes
   * @param searchNodeBody 
   * @param pageNumber The requested page. This value is 1-indexed.
   * @param pageSize The number of items in each page of data.
   * @param sort 
   * @openapi operation=searchNodes path=/nodeSearch method=POST
   */
  public async search(searchNodeBody: SearchNodeBody, pageNumber: number = 1, pageSize: number = 50, sort?: SortObject): Promise<PagedResults<Node>> {
    // verify required parameter 'searchNodeBody' is not null or undefined
    if (searchNodeBody === null || searchNodeBody === undefined) {
      throw new ParameterRequiredError('searchNodeBody');
    }
    if (pageNumber) {
      await Int32.parse(pageNumber);
    }
    if (pageSize) {
      await Int32.parse(pageSize);
    }
    const bag = new PagedResults<Node>();
    bag.pageNumber = pageNumber;
    bag.pageSize = pageSize;
    await this.producer.search(bag, searchNodeBody, sort);
    if (bag.items === null || bag.items === undefined) {
      throw new UnexpectedError("Producers must return 'items' for PagedResults queries");
    }
    return bag;
  }
  /**
   * Returns options/filters for nodes
   * @openapi operation=searchNodesOptions path=/nodeSearch/options method=GET
   */
  public async searchOptions(): Promise<ResultsColumnOptionsWrapper> {
    return this.producer.searchOptions();
  }
  /**
   * This will set an environment variable for the node service, it must be restarted to take affect
   * @summary Set an env var on a hub node appliance
   * @param id Node ID
   * @param key The environment variable key
   * @param envVar 
   * @openapi operation=setEnvVar path=/nodes/{id}/appliance/environment/{key} method=PUT
   */
  public async setEnvVar(id: UUID, key: string, envVar: EnvVar): Promise<void> {
    // verify required parameter 'id' is not null or undefined
    if (id === null || id === undefined) {
      throw new ParameterRequiredError('id');
    }
    // verify required parameter 'key' is not null or undefined
    if (key === null || key === undefined || key === '') {
      throw new ParameterRequiredError('key');
    }
    // verify required parameter 'envVar' is not null or undefined
    if (envVar === null || envVar === undefined) {
      throw new ParameterRequiredError('envVar');
    }
    return this.producer.setEnvVar(id, key, envVar);
  }
  /**
   * This will signal to the Node that a new version neeeds to be installed. The call will return before the node actually installs this version of the software which will happen in the background.
   * @summary Sets the software version of a given node
   * @param id Node ID
   * @param setVersionBody 
   * @openapi operation=setNodeVersion path=/nodes/{id}/version method=PUT
   */
  public async setVersion(id: UUID, setVersionBody: SetVersionBody): Promise<void> {
    // verify required parameter 'id' is not null or undefined
    if (id === null || id === undefined) {
      throw new ParameterRequiredError('id');
    }
    // verify required parameter 'setVersionBody' is not null or undefined
    if (setVersionBody === null || setVersionBody === undefined) {
      throw new ParameterRequiredError('setVersionBody');
    }
    return this.producer.setVersion(id, setVersionBody);
  }
  /**
   * This will unset an environment variable for the node service, it must be restarted to take affect
   * @summary Unset an env var on a hub node appliance
   * @param id Node ID
   * @param key The environment variable key
   * @openapi operation=unsetEnvVar path=/nodes/{id}/appliance/environment/{key} method=DELETE
   */
  public async unsetEnvVar(id: UUID, key: string): Promise<void> {
    // verify required parameter 'id' is not null or undefined
    if (id === null || id === undefined) {
      throw new ParameterRequiredError('id');
    }
    // verify required parameter 'key' is not null or undefined
    if (key === null || key === undefined || key === '') {
      throw new ParameterRequiredError('key');
    }
    return this.producer.unsetEnvVar(id, key);
  }
  /**
   * Update a node by its identifier
   * @summary Update a node
   * @param id Node ID
   * @param updateNode 
   * @openapi operation=update path=/nodes/{id} method=PUT
   */
  public async update(id: UUID, updateNode: UpdateNode): Promise<Node> {
    // verify required parameter 'id' is not null or undefined
    if (id === null || id === undefined) {
      throw new ParameterRequiredError('id');
    }
    // verify required parameter 'updateNode' is not null or undefined
    if (updateNode === null || updateNode === undefined) {
      throw new ParameterRequiredError('updateNode');
    }
    return this.producer.update(id, updateNode);
  }
  /**
   * This will View the latest compliance scan summary
   * @summary View the latest compliance scan summary
   * @param id Node ID
   * @openapi operation=viewComplianceReport path=/nodes/{id}/appliance/complianceScan/view method=GET
   */
  public async viewComplianceReport(id: UUID): Promise<void> {
    // verify required parameter 'id' is not null or undefined
    if (id === null || id === undefined) {
      throw new ParameterRequiredError('id');
    }
    return this.producer.viewComplianceReport(id);
  }
}

/**
 * Wrap producer with mapping implementation
 */
export function wrapNodeProducer(producer: NodeProducerApi): NodeApi {
  return new NodeApiMappingImpl(producer);
}

/**
 * NodeApiHttpImpl - Direct HTTP implementation
 *
 * Makes direct HTTP calls to the API using Axios.
 * Used by SDK clients for platform service access.
 */
export class NodeApiHttpImpl implements NodeProducerApi {
  private client: AxiosInstance;
  private headers: Record<string, string>;

  constructor(client: AxiosInstance, headers: Record<string, string> = {}) {
    this.client = client;
    this.headers = headers;
  }

  async addTag(id: UUID, addTag: AddTag): Promise<void> {
  const _queryParams = {
      
  };
  const _bodyParams = {
      addTag,
  };
  let _path = '/nodes/{id}/tags';
  _path = _path.replace('{id}', encodeURIComponent(String(id)));
  return this.client.post(
    _path,
    _bodyParams)
    .then((response) => {
      // BaseApiClient uses validateStatus: () => true, so we must check status manually
      if (response.status >= 400) {
        throw CoreError.deserialize(response.data);
      }
      return ObjectSerializer.deserialize(response.data, '')
    })
    .catch((error) => {
      if (error.data) {
        throw CoreError.deserialize(error.data);
      } else {
        throw error;
      }
    });
  }
  async claimNode(code: string, claimNodeBody: ClaimNodeBody, danaOrgId?: UUID): Promise<Node> {
  const _queryParams = {
      danaOrgId,
  };
  const _bodyParams = {
      claimNodeBody,
  };
  let _path = '/registrations/{code}/claim';
  _path = _path.replace('{code}', encodeURIComponent(String(code)));
  return this.client.put(
    _path,
    _bodyParams)
    .then((response) => {
      // BaseApiClient uses validateStatus: () => true, so we must check status manually
      if (response.status >= 400) {
        throw CoreError.deserialize(response.data);
      }
      return ObjectSerializer.deserialize(response.data, 'Node')
    })
    .catch((error) => {
      if (error.data) {
        throw CoreError.deserialize(error.data);
      } else {
        throw error;
      }
    });
  }
  async create(createRegistration: CreateRegistration): Promise<RegistrationExtended> {
  const _queryParams = {
      
  };
  const _bodyParams = {
      ...createRegistration,
  };
  let _path = '/nodes';
  return this.client.post(
    _path,
    _bodyParams)
    .then((response) => {
      // BaseApiClient uses validateStatus: () => true, so we must check status manually
      if (response.status >= 400) {
        throw CoreError.deserialize(response.data);
      }
      return ObjectSerializer.deserialize(response.data, 'RegistrationExtended')
    })
    .catch((error) => {
      if (error.data) {
        throw CoreError.deserialize(error.data);
      } else {
        throw error;
      }
    });
  }
  async createNodeDeployment(nodeId: UUID, createNodeDeployment: CreateNodeDeployment): Promise<DeploymentView> {
  const _queryParams = {
      
  };
  const _bodyParams = {
      createNodeDeployment,
  };
  let _path = '/nodes/{nodeId}/deployments';
  _path = _path.replace('{nodeId}', encodeURIComponent(String(nodeId)));
  return this.client.post(
    _path,
    _bodyParams)
    .then((response) => {
      // BaseApiClient uses validateStatus: () => true, so we must check status manually
      if (response.status >= 400) {
        throw CoreError.deserialize(response.data);
      }
      return ObjectSerializer.deserialize(response.data, 'DeploymentView')
    })
    .catch((error) => {
      if (error.data) {
        throw CoreError.deserialize(error.data);
      } else {
        throw error;
      }
    });
  }
  async delete(id: UUID, cascadeDeployments?: boolean, cascadeConnections?: boolean): Promise<void> {
  const _queryParams = {
      cascadeDeployments,cascadeConnections,
  };
  const _bodyParams = {
      
  };
  let _path = '/nodes/{id}';
  _path = _path.replace('{id}', encodeURIComponent(String(id)));
  return this.client.delete(
    _path,
    { params: _queryParams })
    .then((response) => {
      // BaseApiClient uses validateStatus: () => true, so we must check status manually
      if (response.status >= 400) {
        throw CoreError.deserialize(response.data);
      }
      return ObjectSerializer.deserialize(response.data, '')
    })
    .catch((error) => {
      if (error.data) {
        throw CoreError.deserialize(error.data);
      } else {
        throw error;
      }
    });
  }
  async deleteRegistration(id: string): Promise<void> {
  const _queryParams = {
      
  };
  const _bodyParams = {
      
  };
  let _path = '/registrations/{id}';
  _path = _path.replace('{id}', encodeURIComponent(String(id)));
  return this.client.delete(
    _path,
    { params: _queryParams })
    .then((response) => {
      // BaseApiClient uses validateStatus: () => true, so we must check status manually
      if (response.status >= 400) {
        throw CoreError.deserialize(response.data);
      }
      return ObjectSerializer.deserialize(response.data, '')
    })
    .catch((error) => {
      if (error.data) {
        throw CoreError.deserialize(error.data);
      } else {
        throw error;
      }
    });
  }
  async downloadComplianceReport(id: UUID): Promise<void> {
  const _queryParams = {
      
  };
  const _bodyParams = {
      
  };
  let _path = '/nodes/{id}/appliance/complianceScan/download';
  _path = _path.replace('{id}', encodeURIComponent(String(id)));
  return this.client.get(
    _path,
    { params: _queryParams })
    .then((response) => {
      // BaseApiClient uses validateStatus: () => true, so we must check status manually
      if (response.status >= 400) {
        throw CoreError.deserialize(response.data);
      }
      return ObjectSerializer.deserialize(response.data, '')
    })
    .catch((error) => {
      if (error.data) {
        throw CoreError.deserialize(error.data);
      } else {
        throw error;
      }
    });
  }
  async ensureDeployments(nodeId: UUID): Promise<void> {
  const _queryParams = {
      
  };
  const _bodyParams = {
      
  };
  let _path = '/nodes/{nodeId}/ensureDeployments';
  _path = _path.replace('{nodeId}', encodeURIComponent(String(nodeId)));
  return this.client.post(
    _path,
    _bodyParams)
    .then((response) => {
      // BaseApiClient uses validateStatus: () => true, so we must check status manually
      if (response.status >= 400) {
        throw CoreError.deserialize(response.data);
      }
      return ObjectSerializer.deserialize(response.data, '')
    })
    .catch((error) => {
      if (error.data) {
        throw CoreError.deserialize(error.data);
      } else {
        throw error;
      }
    });
  }
  async getInfo(id: UUID): Promise<NodeInfo> {
  const _queryParams = {
      
  };
  const _bodyParams = {
      
  };
  let _path = '/nodes/{id}/info';
  _path = _path.replace('{id}', encodeURIComponent(String(id)));
  return this.client.get(
    _path,
    { params: _queryParams })
    .then((response) => {
      // BaseApiClient uses validateStatus: () => true, so we must check status manually
      if (response.status >= 400) {
        throw CoreError.deserialize(response.data);
      }
      return ObjectSerializer.deserialize(response.data, 'NodeInfo')
    })
    .catch((error) => {
      if (error.data) {
        throw CoreError.deserialize(error.data);
      } else {
        throw error;
      }
    });
  }
  async get(id: UUID): Promise<Node> {
  const _queryParams = {
      
  };
  const _bodyParams = {
      
  };
  let _path = '/nodes/{id}';
  _path = _path.replace('{id}', encodeURIComponent(String(id)));
  return this.client.get(
    _path,
    { params: _queryParams })
    .then((response) => {
      // BaseApiClient uses validateStatus: () => true, so we must check status manually
      if (response.status >= 400) {
        throw CoreError.deserialize(response.data);
      }
      return ObjectSerializer.deserialize(response.data, 'Node')
    })
    .catch((error) => {
      if (error.data) {
        throw CoreError.deserialize(error.data);
      } else {
        throw error;
      }
    });
  }
  async getNodeAvailableLatestVersion(id: UUID): Promise<Semver> {
  const _queryParams = {
      
  };
  const _bodyParams = {
      
  };
  let _path = '/nodes/{id}/latestAvailableVersion';
  _path = _path.replace('{id}', encodeURIComponent(String(id)));
  return this.client.get(
    _path,
    { params: _queryParams })
    .then((response) => {
      // BaseApiClient uses validateStatus: () => true, so we must check status manually
      if (response.status >= 400) {
        throw CoreError.deserialize(response.data);
      }
      return ObjectSerializer.deserialize(response.data, 'Semver')
    })
    .catch((error) => {
      if (error.data) {
        throw CoreError.deserialize(error.data);
      } else {
        throw error;
      }
    });
  }
  async getRegistration(id: string): Promise<RegistrationExtended> {
  const _queryParams = {
      
  };
  const _bodyParams = {
      
  };
  let _path = '/registrations/{id}';
  _path = _path.replace('{id}', encodeURIComponent(String(id)));
  return this.client.get(
    _path,
    { params: _queryParams })
    .then((response) => {
      // BaseApiClient uses validateStatus: () => true, so we must check status manually
      if (response.status >= 400) {
        throw CoreError.deserialize(response.data);
      }
      return ObjectSerializer.deserialize(response.data, 'RegistrationExtended')
    })
    .catch((error) => {
      if (error.data) {
        throw CoreError.deserialize(error.data);
      } else {
        throw error;
      }
    });
  }
  async getWritableSecretPath(id: UUID): Promise<string> {
  const _queryParams = {
      
  };
  const _bodyParams = {
      
  };
  let _path = '/nodes/{id}/writableSecret';
  _path = _path.replace('{id}', encodeURIComponent(String(id)));
  return this.client.get(
    _path,
    { params: _queryParams })
    .then((response) => {
      // BaseApiClient uses validateStatus: () => true, so we must check status manually
      if (response.status >= 400) {
        throw CoreError.deserialize(response.data);
      }
      return ObjectSerializer.deserialize(response.data, 'string')
    })
    .catch((error) => {
      if (error.data) {
        throw CoreError.deserialize(error.data);
      } else {
        throw error;
      }
    });
  }
  async identify(id: UUID): Promise<{ [key: string]: any; }> {
  const _queryParams = {
      
  };
  const _bodyParams = {
      
  };
  let _path = '/nodes/{id}/identify';
  _path = _path.replace('{id}', encodeURIComponent(String(id)));
  return this.client.get(
    _path,
    { params: _queryParams })
    .then((response) => {
      // BaseApiClient uses validateStatus: () => true, so we must check status manually
      if (response.status >= 400) {
        throw CoreError.deserialize(response.data);
      }
      return ObjectSerializer.deserialize(response.data, '{ [key: string]: any; }')
    })
    .catch((error) => {
      if (error.data) {
        throw CoreError.deserialize(error.data);
      } else {
        throw error;
      }
    });
  }
  async listConnectionsBySecretId(results: PagedResults<ConnectionListView>, id: UUID, secretId: UUID): Promise<void> {
  const _body = {
      id,secretId,
  };
  let _path = '/nodes/{id}/secrets/{secretId}/connections';
  _path = _path.replace('{id}', encodeURIComponent(String(id)));
  _path = _path.replace('{secretId}', encodeURIComponent(String(secretId)));
  return this.client.get(
    _path,
    {
      params: {
        ..._body,
        pageNumber: results.pageNumber,
        pageSize: results.pageSize,
      }
    })
    .then((response) => {
      // BaseApiClient uses validateStatus: () => true, so we must check status manually
      if (response.status >= 400) {
        throw CoreError.deserialize(response.data);
      }
      results.items = ObjectSerializer.deserialize(response.data, 'Array<ConnectionListView>');
      results.count = response.headers.count ? Number(response.headers.count) : -1;
      results.pageToken = response.headers.pagetoken ?? response.headers.pageToken;
      results.headers = this.headers;
      results.baseUrl = new URL(`${this.client.getUri()}/nodes/{id}/secrets/{secretId}/connections`);
      results.httpMethod = HttpMethod.Get;
      results.body = _body;
      results.mapper = (obj) => ObjectSerializer.deserialize(obj, 'ConnectionListView');
    })
    .catch((error) => {
      if (error.data) {
        throw CoreError.deserialize(error.data);
      } else {
        throw error;
      }
    });
  }
  async listConnections(results: PagedResults<ConnectionListView>, id: UUID): Promise<void> {
  const _body = {
      id,
  };
  let _path = '/nodes/{id}/connections';
  _path = _path.replace('{id}', encodeURIComponent(String(id)));
  return this.client.get(
    _path,
    {
      params: {
        ..._body,
        pageNumber: results.pageNumber,
        pageSize: results.pageSize,
      }
    })
    .then((response) => {
      // BaseApiClient uses validateStatus: () => true, so we must check status manually
      if (response.status >= 400) {
        throw CoreError.deserialize(response.data);
      }
      results.items = ObjectSerializer.deserialize(response.data, 'Array<ConnectionListView>');
      results.count = response.headers.count ? Number(response.headers.count) : -1;
      results.pageToken = response.headers.pagetoken ?? response.headers.pageToken;
      results.headers = this.headers;
      results.baseUrl = new URL(`${this.client.getUri()}/nodes/{id}/connections`);
      results.httpMethod = HttpMethod.Get;
      results.body = _body;
      results.mapper = (obj) => ObjectSerializer.deserialize(obj, 'ConnectionListView');
    })
    .catch((error) => {
      if (error.data) {
        throw CoreError.deserialize(error.data);
      } else {
        throw error;
      }
    });
  }
  async listDeploymentsBySecretId(results: PagedResults<DeploymentView>, id: UUID, secretId: UUID): Promise<void> {
  const _body = {
      id,secretId,
  };
  let _path = '/nodes/{id}/secrets/{secretId}/deployments';
  _path = _path.replace('{id}', encodeURIComponent(String(id)));
  _path = _path.replace('{secretId}', encodeURIComponent(String(secretId)));
  return this.client.get(
    _path,
    {
      params: {
        ..._body,
        pageNumber: results.pageNumber,
        pageSize: results.pageSize,
      }
    })
    .then((response) => {
      // BaseApiClient uses validateStatus: () => true, so we must check status manually
      if (response.status >= 400) {
        throw CoreError.deserialize(response.data);
      }
      results.items = ObjectSerializer.deserialize(response.data, 'Array<DeploymentView>');
      results.count = response.headers.count ? Number(response.headers.count) : -1;
      results.pageToken = response.headers.pagetoken ?? response.headers.pageToken;
      results.headers = this.headers;
      results.baseUrl = new URL(`${this.client.getUri()}/nodes/{id}/secrets/{secretId}/deployments`);
      results.httpMethod = HttpMethod.Get;
      results.body = _body;
      results.mapper = (obj) => ObjectSerializer.deserialize(obj, 'DeploymentView');
    })
    .catch((error) => {
      if (error.data) {
        throw CoreError.deserialize(error.data);
      } else {
        throw error;
      }
    });
  }
  async listDeployments(results: PagedResults<DeploymentView>, nodeId: UUID, filter?: string): Promise<void> {
  const _body = {
      nodeId,filter,
  };
  let _path = '/nodes/{nodeId}/deployments';
  _path = _path.replace('{nodeId}', encodeURIComponent(String(nodeId)));
  return this.client.get(
    _path,
    {
      params: {
        ..._body,
        pageNumber: results.pageNumber,
        pageSize: results.pageSize,
      }
    })
    .then((response) => {
      // BaseApiClient uses validateStatus: () => true, so we must check status manually
      if (response.status >= 400) {
        throw CoreError.deserialize(response.data);
      }
      results.items = ObjectSerializer.deserialize(response.data, 'Array<DeploymentView>');
      results.count = response.headers.count ? Number(response.headers.count) : -1;
      results.pageToken = response.headers.pagetoken ?? response.headers.pageToken;
      results.headers = this.headers;
      results.baseUrl = new URL(`${this.client.getUri()}/nodes/{nodeId}/deployments`);
      results.httpMethod = HttpMethod.Get;
      results.body = _body;
      results.mapper = (obj) => ObjectSerializer.deserialize(obj, 'DeploymentView');
    })
    .catch((error) => {
      if (error.data) {
        throw CoreError.deserialize(error.data);
      } else {
        throw error;
      }
    });
  }
  async listDeploymentsSlim(results: PagedResults<DeploymentSlimView>, nodeId: UUID, filter?: string): Promise<void> {
  const _body = {
      nodeId,filter,
  };
  let _path = '/nodes/{nodeId}/slimDeployments';
  _path = _path.replace('{nodeId}', encodeURIComponent(String(nodeId)));
  return this.client.get(
    _path,
    {
      params: {
        ..._body,
        pageNumber: results.pageNumber,
        pageSize: results.pageSize,
      }
    })
    .then((response) => {
      // BaseApiClient uses validateStatus: () => true, so we must check status manually
      if (response.status >= 400) {
        throw CoreError.deserialize(response.data);
      }
      results.items = ObjectSerializer.deserialize(response.data, 'Array<DeploymentSlimView>');
      results.count = response.headers.count ? Number(response.headers.count) : -1;
      results.pageToken = response.headers.pagetoken ?? response.headers.pageToken;
      results.headers = this.headers;
      results.baseUrl = new URL(`${this.client.getUri()}/nodes/{nodeId}/slimDeployments`);
      results.httpMethod = HttpMethod.Get;
      results.body = _body;
      results.mapper = (obj) => ObjectSerializer.deserialize(obj, 'DeploymentSlimView');
    })
    .catch((error) => {
      if (error.data) {
        throw CoreError.deserialize(error.data);
      } else {
        throw error;
      }
    });
  }
  async listNodeAvailableVersions(id: UUID): Promise<Array<Semver>> {
  const _queryParams = {
      
  };
  const _bodyParams = {
      
  };
  let _path = '/nodes/{id}/availableVersions';
  _path = _path.replace('{id}', encodeURIComponent(String(id)));
  return this.client.get(
    _path,
    { params: _queryParams })
    .then((response) => {
      // BaseApiClient uses validateStatus: () => true, so we must check status manually
      if (response.status >= 400) {
        throw CoreError.deserialize(response.data);
      }
      return ObjectSerializer.deserialize(response.data, 'Array<Semver>')
    })
    .catch((error) => {
      if (error.data) {
        throw CoreError.deserialize(error.data);
      } else {
        throw error;
      }
    });
  }
  async list(results: PagedResults<Node>, filter?: string, status?: OperationalStatusDef): Promise<void> {
  const _body = {
      filter,status,
  };
  let _path = '/nodes';
  return this.client.get(
    _path,
    {
      params: {
        ..._body,
        pageNumber: results.pageNumber,
        pageSize: results.pageSize,
      }
    })
    .then((response) => {
      // BaseApiClient uses validateStatus: () => true, so we must check status manually
      if (response.status >= 400) {
        throw CoreError.deserialize(response.data);
      }
      results.items = ObjectSerializer.deserialize(response.data, 'Array<Node>');
      results.count = response.headers.count ? Number(response.headers.count) : -1;
      results.pageToken = response.headers.pagetoken ?? response.headers.pageToken;
      results.headers = this.headers;
      results.baseUrl = new URL(`${this.client.getUri()}/nodes`);
      results.httpMethod = HttpMethod.Get;
      results.body = _body;
      results.mapper = (obj) => ObjectSerializer.deserialize(obj, 'Node');
    })
    .catch((error) => {
      if (error.data) {
        throw CoreError.deserialize(error.data);
      } else {
        throw error;
      }
    });
  }
  async listRegistrations(results: PagedResults<RegistrationExtended>): Promise<void> {
  const _body = {
      
  };
  let _path = '/registrations';
  return this.client.get(
    _path,
    {
      params: {
        ..._body,
        pageNumber: results.pageNumber,
        pageSize: results.pageSize,
      }
    })
    .then((response) => {
      // BaseApiClient uses validateStatus: () => true, so we must check status manually
      if (response.status >= 400) {
        throw CoreError.deserialize(response.data);
      }
      results.items = ObjectSerializer.deserialize(response.data, 'Array<RegistrationExtended>');
      results.count = response.headers.count ? Number(response.headers.count) : -1;
      results.pageToken = response.headers.pagetoken ?? response.headers.pageToken;
      results.headers = this.headers;
      results.baseUrl = new URL(`${this.client.getUri()}/registrations`);
      results.httpMethod = HttpMethod.Get;
      results.body = _body;
      results.mapper = (obj) => ObjectSerializer.deserialize(obj, 'RegistrationExtended');
    })
    .catch((error) => {
      if (error.data) {
        throw CoreError.deserialize(error.data);
      } else {
        throw error;
      }
    });
  }
  async listSecretNodes(id: UUID, path?: string): Promise<Array<SecretNode>> {
  const _queryParams = {
      path,
  };
  const _bodyParams = {
      
  };
  let _path = '/nodes/{id}/secretNodes';
  _path = _path.replace('{id}', encodeURIComponent(String(id)));
  return this.client.get(
    _path,
    { params: _queryParams })
    .then((response) => {
      // BaseApiClient uses validateStatus: () => true, so we must check status manually
      if (response.status >= 400) {
        throw CoreError.deserialize(response.data);
      }
      return ObjectSerializer.deserialize(response.data, 'Array<SecretNode>')
    })
    .catch((error) => {
      if (error.data) {
        throw CoreError.deserialize(error.data);
      } else {
        throw error;
      }
    });
  }
  async listSharedSecrets(results: PagedResults<Secret>, id: UUID, connectionProfileId?: UUID): Promise<void> {
  const _body = {
      id,connectionProfileId,
  };
  let _path = '/nodes/{id}/secrets';
  _path = _path.replace('{id}', encodeURIComponent(String(id)));
  return this.client.get(
    _path,
    {
      params: {
        ..._body,
        pageNumber: results.pageNumber,
        pageSize: results.pageSize,
      }
    })
    .then((response) => {
      // BaseApiClient uses validateStatus: () => true, so we must check status manually
      if (response.status >= 400) {
        throw CoreError.deserialize(response.data);
      }
      results.items = ObjectSerializer.deserialize(response.data, 'Array<Secret>');
      results.count = response.headers.count ? Number(response.headers.count) : -1;
      results.pageToken = response.headers.pagetoken ?? response.headers.pageToken;
      results.headers = this.headers;
      results.baseUrl = new URL(`${this.client.getUri()}/nodes/{id}/secrets`);
      results.httpMethod = HttpMethod.Get;
      results.body = _body;
      results.mapper = (obj) => ObjectSerializer.deserialize(obj, 'Secret');
    })
    .catch((error) => {
      if (error.data) {
        throw CoreError.deserialize(error.data);
      } else {
        throw error;
      }
    });
  }
  async migrate(nodeId: UUID, migrateNodeBody: MigrateNodeBody): Promise<void> {
  const _queryParams = {
      
  };
  const _bodyParams = {
      migrateNodeBody,
  };
  let _path = '/nodes/{nodeId}/migrate';
  _path = _path.replace('{nodeId}', encodeURIComponent(String(nodeId)));
  return this.client.post(
    _path,
    _bodyParams)
    .then((response) => {
      // BaseApiClient uses validateStatus: () => true, so we must check status manually
      if (response.status >= 400) {
        throw CoreError.deserialize(response.data);
      }
      return ObjectSerializer.deserialize(response.data, '')
    })
    .catch((error) => {
      if (error.data) {
        throw CoreError.deserialize(error.data);
      } else {
        throw error;
      }
    });
  }
  async migrateCheck(nodeId: UUID, migrateNodeCheckBody: MigrateNodeCheckBody): Promise<MigrateNodeCheckResponse> {
  const _queryParams = {
      
  };
  const _bodyParams = {
      migrateNodeCheckBody,
  };
  let _path = '/nodes/{nodeId}/migrateCheck';
  _path = _path.replace('{nodeId}', encodeURIComponent(String(nodeId)));
  return this.client.post(
    _path,
    _bodyParams)
    .then((response) => {
      // BaseApiClient uses validateStatus: () => true, so we must check status manually
      if (response.status >= 400) {
        throw CoreError.deserialize(response.data);
      }
      return ObjectSerializer.deserialize(response.data, 'MigrateNodeCheckResponse')
    })
    .catch((error) => {
      if (error.data) {
        throw CoreError.deserialize(error.data);
      } else {
        throw error;
      }
    });
  }
  async requestComplianceScan(id: UUID): Promise<void> {
  const _queryParams = {
      
  };
  const _bodyParams = {
      
  };
  let _path = '/nodes/{id}/appliance/complianceScan/run';
  _path = _path.replace('{id}', encodeURIComponent(String(id)));
  return this.client.get(
    _path,
    { params: _queryParams })
    .then((response) => {
      // BaseApiClient uses validateStatus: () => true, so we must check status manually
      if (response.status >= 400) {
        throw CoreError.deserialize(response.data);
      }
      return ObjectSerializer.deserialize(response.data, '')
    })
    .catch((error) => {
      if (error.data) {
        throw CoreError.deserialize(error.data);
      } else {
        throw error;
      }
    });
  }
  async requestRestart(id: UUID): Promise<void> {
  const _queryParams = {
      
  };
  const _bodyParams = {
      
  };
  let _path = '/nodes/{id}/restart';
  _path = _path.replace('{id}', encodeURIComponent(String(id)));
  return this.client.put(
    _path,
    _bodyParams)
    .then((response) => {
      // BaseApiClient uses validateStatus: () => true, so we must check status manually
      if (response.status >= 400) {
        throw CoreError.deserialize(response.data);
      }
      return ObjectSerializer.deserialize(response.data, '')
    })
    .catch((error) => {
      if (error.data) {
        throw CoreError.deserialize(error.data);
      } else {
        throw error;
      }
    });
  }
  async searchConnections(results: PagedResults<ConnectionListView>, id: UUID, searchNodeConnectionBody: SearchNodeConnectionBody, sort?: SortObject, boundaryId?: UUID): Promise<void> {
  const _body = {
      id,searchNodeConnectionBody,sort,boundaryId,
  };
  let _path = '/nodes/{id}/connectionSearch';
  _path = _path.replace('{id}', encodeURIComponent(String(id)));
  return this.client.post(
    _path,
    {
      ..._body,
      pageNumber: results.pageNumber,
      pageSize: results.pageSize,
    })
    .then((response) => {
      // BaseApiClient uses validateStatus: () => true, so we must check status manually
      if (response.status >= 400) {
        throw CoreError.deserialize(response.data);
      }
      results.items = ObjectSerializer.deserialize(response.data, 'Array<ConnectionListView>');
      results.count = response.headers.count ? Number(response.headers.count) : -1;
      results.pageToken = response.headers.pagetoken ?? response.headers.pageToken;
      results.headers = this.headers;
      results.baseUrl = new URL(`${this.client.getUri()}/nodes/{id}/connectionSearch`);
      results.httpMethod = HttpMethod.Post;
      results.body = _body;
      results.mapper = (obj) => ObjectSerializer.deserialize(obj, 'ConnectionListView');
    })
    .catch((error) => {
      if (error.data) {
        throw CoreError.deserialize(error.data);
      } else {
        throw error;
      }
    });
  }
  async searchConnectionOptions(id: UUID, boundaryId?: UUID): Promise<ResultsColumnOptionsWrapper> {
  const _queryParams = {
      boundaryId,
  };
  const _bodyParams = {
      
  };
  let _path = '/nodes/{id}/connectionSearch/options';
  _path = _path.replace('{id}', encodeURIComponent(String(id)));
  return this.client.get(
    _path,
    { params: _queryParams })
    .then((response) => {
      // BaseApiClient uses validateStatus: () => true, so we must check status manually
      if (response.status >= 400) {
        throw CoreError.deserialize(response.data);
      }
      return ObjectSerializer.deserialize(response.data, 'ResultsColumnOptionsWrapper')
    })
    .catch((error) => {
      if (error.data) {
        throw CoreError.deserialize(error.data);
      } else {
        throw error;
      }
    });
  }
  async search(results: PagedResults<Node>, searchNodeBody: SearchNodeBody, sort?: SortObject): Promise<void> {
  const _body = {
      searchNodeBody,sort,
  };
  let _path = '/nodeSearch';
  return this.client.post(
    _path,
    {
      ..._body,
      pageNumber: results.pageNumber,
      pageSize: results.pageSize,
    })
    .then((response) => {
      // BaseApiClient uses validateStatus: () => true, so we must check status manually
      if (response.status >= 400) {
        throw CoreError.deserialize(response.data);
      }
      results.items = ObjectSerializer.deserialize(response.data, 'Array<Node>');
      results.count = response.headers.count ? Number(response.headers.count) : -1;
      results.pageToken = response.headers.pagetoken ?? response.headers.pageToken;
      results.headers = this.headers;
      results.baseUrl = new URL(`${this.client.getUri()}/nodeSearch`);
      results.httpMethod = HttpMethod.Post;
      results.body = _body;
      results.mapper = (obj) => ObjectSerializer.deserialize(obj, 'Node');
    })
    .catch((error) => {
      if (error.data) {
        throw CoreError.deserialize(error.data);
      } else {
        throw error;
      }
    });
  }
  async searchOptions(): Promise<ResultsColumnOptionsWrapper> {
  const _queryParams = {
      
  };
  const _bodyParams = {
      
  };
  let _path = '/nodeSearch/options';
  return this.client.get(
    _path,
    { params: _queryParams })
    .then((response) => {
      // BaseApiClient uses validateStatus: () => true, so we must check status manually
      if (response.status >= 400) {
        throw CoreError.deserialize(response.data);
      }
      return ObjectSerializer.deserialize(response.data, 'ResultsColumnOptionsWrapper')
    })
    .catch((error) => {
      if (error.data) {
        throw CoreError.deserialize(error.data);
      } else {
        throw error;
      }
    });
  }
  async setEnvVar(id: UUID, key: string, envVar: EnvVar): Promise<void> {
  const _queryParams = {
      
  };
  const _bodyParams = {
      envVar,
  };
  let _path = '/nodes/{id}/appliance/environment/{key}';
  _path = _path.replace('{id}', encodeURIComponent(String(id)));
  _path = _path.replace('{key}', encodeURIComponent(String(key)));
  return this.client.put(
    _path,
    _bodyParams)
    .then((response) => {
      // BaseApiClient uses validateStatus: () => true, so we must check status manually
      if (response.status >= 400) {
        throw CoreError.deserialize(response.data);
      }
      return ObjectSerializer.deserialize(response.data, '')
    })
    .catch((error) => {
      if (error.data) {
        throw CoreError.deserialize(error.data);
      } else {
        throw error;
      }
    });
  }
  async setVersion(id: UUID, setVersionBody: SetVersionBody): Promise<void> {
  const _queryParams = {
      
  };
  const _bodyParams = {
      setVersionBody,
  };
  let _path = '/nodes/{id}/version';
  _path = _path.replace('{id}', encodeURIComponent(String(id)));
  return this.client.put(
    _path,
    _bodyParams)
    .then((response) => {
      // BaseApiClient uses validateStatus: () => true, so we must check status manually
      if (response.status >= 400) {
        throw CoreError.deserialize(response.data);
      }
      return ObjectSerializer.deserialize(response.data, '')
    })
    .catch((error) => {
      if (error.data) {
        throw CoreError.deserialize(error.data);
      } else {
        throw error;
      }
    });
  }
  async unsetEnvVar(id: UUID, key: string): Promise<void> {
  const _queryParams = {
      
  };
  const _bodyParams = {
      
  };
  let _path = '/nodes/{id}/appliance/environment/{key}';
  _path = _path.replace('{id}', encodeURIComponent(String(id)));
  _path = _path.replace('{key}', encodeURIComponent(String(key)));
  return this.client.delete(
    _path,
    { params: _queryParams })
    .then((response) => {
      // BaseApiClient uses validateStatus: () => true, so we must check status manually
      if (response.status >= 400) {
        throw CoreError.deserialize(response.data);
      }
      return ObjectSerializer.deserialize(response.data, '')
    })
    .catch((error) => {
      if (error.data) {
        throw CoreError.deserialize(error.data);
      } else {
        throw error;
      }
    });
  }
  async update(id: UUID, updateNode: UpdateNode): Promise<Node> {
  const _queryParams = {
      
  };
  const _bodyParams = {
      updateNode,
  };
  let _path = '/nodes/{id}';
  _path = _path.replace('{id}', encodeURIComponent(String(id)));
  return this.client.put(
    _path,
    _bodyParams)
    .then((response) => {
      // BaseApiClient uses validateStatus: () => true, so we must check status manually
      if (response.status >= 400) {
        throw CoreError.deserialize(response.data);
      }
      return ObjectSerializer.deserialize(response.data, 'Node')
    })
    .catch((error) => {
      if (error.data) {
        throw CoreError.deserialize(error.data);
      } else {
        throw error;
      }
    });
  }
  async viewComplianceReport(id: UUID): Promise<void> {
  const _queryParams = {
      
  };
  const _bodyParams = {
      
  };
  let _path = '/nodes/{id}/appliance/complianceScan/view';
  _path = _path.replace('{id}', encodeURIComponent(String(id)));
  return this.client.get(
    _path,
    { params: _queryParams })
    .then((response) => {
      // BaseApiClient uses validateStatus: () => true, so we must check status manually
      if (response.status >= 400) {
        throw CoreError.deserialize(response.data);
      }
      return ObjectSerializer.deserialize(response.data, '')
    })
    .catch((error) => {
      if (error.data) {
        throw CoreError.deserialize(error.data);
      } else {
        throw error;
      }
    });
  }
}
