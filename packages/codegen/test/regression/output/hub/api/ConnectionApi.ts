/* eslint-disable */
// ===============================================
// This file is autogenerated - Please do not edit
// ===============================================
import { AxiosInstance } from 'axios';
import { ConnectionListView, ConnectionOperationalStatusDef, ConnectionView, ResultsColumnOptionsWrapper, SearchConnectionBody, SortDirectionDef, SortObject, UpdateConnection, UpdateConnectionResults } from '../model/index.js';
import { URL, EnumValue, IllegalArgumentError, PagedResults, Int32, Nmtoken, UUID, CoreError, ParameterRequiredError, UnexpectedError, HttpMethod } from '@zerobias-org/types-core-js';
import { RequestFile, ObjectSerializer } from '../model/index.js';

export namespace ConnectionApi {
}

/**
 * ConnectionApi - interface
 * @export
 * @interface ConnectionApi
 */
export interface ConnectionApi {
  /**
   * 
   * @summary Calls 'connect' on this connection. This method is only valid if the connection is manually controlled.
   * @param {UUID} id Connection ID
   * @param {boolean} [oauthRefresh] Trigger an oauth refresh on connect
   * @param {*} [options] Override http request option.
   * @throws {@link @zerobias-org/types-core-js#ParameterRequiredError} if any required parameter is not provided
   * @example
   * ```typescript
   * const result = await api.connect('00000000-0000-0000-0000-000000000000', true);
   * ```
   * @openapi operation=connect path=/connections/{id}/connect method=PUT
   * @memberof ConnectionApi
   */
  connect(id: UUID, oauthRefresh?: boolean): Promise<void>;

  /**
   * 
   * @summary Deletes a connection by ID
   * @param {UUID} id Connection ID
   * @param {*} [options] Override http request option.
   * @throws {@link @zerobias-org/types-core-js#ParameterRequiredError} if any required parameter is not provided
   * @example
   * ```typescript
   * const result = await api.delete('00000000-0000-0000-0000-000000000000');
   * ```
   * @openapi operation=deleteConnection path=/connections/{id} method=DELETE
   * @memberof ConnectionApi
   */
  delete(id: UUID): Promise<void>;

  /**
   * 
   * @summary Calls 'disconnect' on this connection. This method is only valid if the connection is manually controlled.
   * @param {UUID} id Connection ID
   * @param {*} [options] Override http request option.
   * @throws {@link @zerobias-org/types-core-js#ParameterRequiredError} if any required parameter is not provided
   * @example
   * ```typescript
   * const result = await api.disconnect('00000000-0000-0000-0000-000000000000');
   * ```
   * @openapi operation=disconnect path=/connections/{id}/disconnect method=PUT
   * @memberof ConnectionApi
   */
  disconnect(id: UUID): Promise<void>;

  /**
   * 
   * @summary Retrieves a connection by ID
   * @param {UUID} id Connection ID
   * @param {*} [options] Override http request option.
   * @throws {@link @zerobias-org/types-core-js#ParameterRequiredError} if any required parameter is not provided
   * @example
   * ```typescript
   * const result = await api.get('00000000-0000-0000-0000-000000000000');
   * ```
   * @openapi operation=getConnection path=/connections/{id} method=GET
   * @memberof ConnectionApi
   */
  get(id: UUID): Promise<ConnectionView>;

  /**
   * 
   * @summary Lists all connections
   * @param {number} [pageNumber] The requested page. This value is 1-indexed.
   * @param {number} [pageSize] The number of items in each page of data.
   * @param {string} [filter] An optional filter to search tags by name. This is a case-insensitive filter
   * @param {Array<SortDirection>} [sortDir] Array of directions to sort by. Must correspond with &#x60;sortBy&#x60;
   * @param {Array<string>} [sortBy] Array of columns to sort by, in order
   * @param {ConnectionOperationalStatus} [status] An optional parameter to filter on connection status
   * @param {boolean} [fileSupport] List only connections with modules file support active or inactive.
   * @param {boolean} [dataSupport] List only connections with modules data producer support active or inactive.
   * @param {Nmtoken} [tag] List only connections with specific tag type.
   * @param {UUID} [boundaryId] Filters executions by boundary id
   * @param {*} [options] Override http request option.
   * @throws {@link @zerobias-org/types-core-js#ParameterRequiredError} if any required parameter is not provided
   * @example
   * ```typescript
   * const result = await api.list(1, 1, 'filter', null, null, null, true, true, null, '00000000-0000-0000-0000-000000000000');
   * ```
   * @openapi operation=listAllConnections path=/connections method=GET
   * @memberof ConnectionApi
   */
  list(pageNumber?: number, pageSize?: number, filter?: string, sortDir?: Array<SortDirectionDef>, sortBy?: Array<string>, status?: ConnectionOperationalStatusDef, fileSupport?: boolean, dataSupport?: boolean, tag?: Nmtoken, boundaryId?: UUID): Promise<PagedResults<ConnectionListView>>;

  /**
   * Re-verifies the ConnectionProfile that is stored. This is for when the ConnectionProfile  is correct, but the external system was misconfigured, resulting in the Connection landing in `error` status.
   * @summary Attempts to verify the currently-stored ConnectionProfile
   * @param {UUID} id Connection ID
   * @param {*} [options] Override http request option.
   * @throws {@link @zerobias-org/types-core-js#ParameterRequiredError} if any required parameter is not provided
   * @example
   * ```typescript
   * const result = await api.reverify('00000000-0000-0000-0000-000000000000');
   * ```
   * @openapi operation=reverify path=/connections/{id}/reverify method=PUT
   * @memberof ConnectionApi
   */
  reverify(id: UUID): Promise<UpdateConnectionResults>;

  /**
   * Search connections
   * @param {SearchConnectionBody} searchConnectionBody 
   * @param {number} [pageNumber] The requested page. This value is 1-indexed.
   * @param {number} [pageSize] The number of items in each page of data.
   * @param {SortObject} [sort] 
   * @param {UUID} [boundaryId] Filters executions by boundary id
   * @param {*} [options] Override http request option.
   * @throws {@link @zerobias-org/types-core-js#ParameterRequiredError} if any required parameter is not provided
   * @example
   * ```typescript
   * const result = await api.search(null, 1, 1, null, '00000000-0000-0000-0000-000000000000');
   * ```
   * @openapi operation=searchConnections path=/connectionSearch method=POST
   * @memberof ConnectionApi
   */
  search(searchConnectionBody: SearchConnectionBody, pageNumber?: number, pageSize?: number, sort?: SortObject, boundaryId?: UUID): Promise<PagedResults<ConnectionListView>>;

  /**
   * Returns options/filters for connections
   * @param {UUID} [boundaryId] Filters executions by boundary id
   * @param {*} [options] Override http request option.
   * @throws {@link @zerobias-org/types-core-js#ParameterRequiredError} if any required parameter is not provided
   * @example
   * ```typescript
   * const result = await api.searchOptions('00000000-0000-0000-0000-000000000000');
   * ```
   * @openapi operation=searchConnectionsOptions path=/connectionSearch/options method=GET
   * @memberof ConnectionApi
   */
  searchOptions(boundaryId?: UUID): Promise<ResultsColumnOptionsWrapper>;

  /**
   * 
   * @summary Updates the ConnectionProfile for this Connection
   * @param {UUID} id Connection ID
   * @param {UpdateConnection} updateConnection 
   * @param {*} [options] Override http request option.
   * @throws {@link @zerobias-org/types-core-js#ParameterRequiredError} if any required parameter is not provided
   * @example
   * ```typescript
   * const result = await api.update('00000000-0000-0000-0000-000000000000', null);
   * ```
   * @openapi operation=updateConnection path=/connections/{id} method=PUT
   * @memberof ConnectionApi
   */
  update(id: UUID, updateConnection: UpdateConnection): Promise<ConnectionListView>;

  /**
   * This method is deprecated in favor of managing the secret directly.
   * @summary Updates the ConnectionProfile for this Connection
   * @param {UUID} id Connection ID
   * @param {{ [key: string]: any; }} requestBody 
   * @param {*} [options] Override http request option.
   * @throws {@link @zerobias-org/types-core-js#ParameterRequiredError} if any required parameter is not provided
   * @example
   * ```typescript
   * const result = await api.updateConnectionProfile('00000000-0000-0000-0000-000000000000', null);
   * ```
   * @openapi operation=updateConnectionProfile path=/connections/{id}/connectionProfile method=PUT
   * @memberof ConnectionApi
   */
  updateConnectionProfile(id: UUID, requestBody: { [key: string]: any; }): Promise<UpdateConnectionResults>;

  /**
   * This method is deprecated in favor of managing the secret directly.
   * @summary Updates the ConnectionProfile, writing the secrets to the given Secrets Manager
   * @param {UUID} id Connection ID
   * @param {{ [key: string]: any; }} requestBody 
   * @param {string} [rootNode] The root secret node to create the new secret under. Hub Server will attempt to determine which one to use if this is not provided. If there are multiple writable root nodes and  this parameter is not provided, an error will be thrown.
   * @param {*} [options] Override http request option.
   * @throws {@link @zerobias-org/types-core-js#ParameterRequiredError} if any required parameter is not provided
   * @example
   * ```typescript
   * const result = await api.updateConnectionProfileSecrets('00000000-0000-0000-0000-000000000000', null, 'rootNode');
   * ```
   * @openapi operation=updateConnectionProfileSecrets path=/connections/{id}/connectionProfile/secrets method=PUT
   * @memberof ConnectionApi
   */
  updateConnectionProfileSecrets(id: UUID, requestBody: { [key: string]: any; }, rootNode?: string): Promise<UpdateConnectionResults>;

}

/**
 * ConnectionProducerApi - interface
 * Producer interface for Connection
 * @export
 * @interface ConnectionProducerApi
 */
export interface ConnectionProducerApi {
  /**
  * 
  * @summary Calls 'connect' on this connection. This method is only valid if the connection is manually controlled.
  * @param {UUID} id Connection ID
  * @param {boolean} [oauthRefresh] Trigger an oauth refresh on connect
  * @param {*} [options] Override http request option.
  * @throws {@link @zerobias-org/types-core-js#ParameterRequiredError} if any required parameter is not provided
  * @openapi operation=connect path=/connections/{id}/connect method=PUT
  * @memberof Connection
  */
  connect(id: UUID, oauthRefresh?: boolean): Promise<void>;
  /**
  * 
  * @summary Deletes a connection by ID
  * @param {UUID} id Connection ID
  * @param {*} [options] Override http request option.
  * @throws {@link @zerobias-org/types-core-js#ParameterRequiredError} if any required parameter is not provided
  * @openapi operation=deleteConnection path=/connections/{id} method=DELETE
  * @memberof Connection
  */
  delete(id: UUID): Promise<void>;
  /**
  * 
  * @summary Calls 'disconnect' on this connection. This method is only valid if the connection is manually controlled.
  * @param {UUID} id Connection ID
  * @param {*} [options] Override http request option.
  * @throws {@link @zerobias-org/types-core-js#ParameterRequiredError} if any required parameter is not provided
  * @openapi operation=disconnect path=/connections/{id}/disconnect method=PUT
  * @memberof Connection
  */
  disconnect(id: UUID): Promise<void>;
  /**
  * 
  * @summary Retrieves a connection by ID
  * @param {UUID} id Connection ID
  * @param {*} [options] Override http request option.
  * @throws {@link @zerobias-org/types-core-js#ParameterRequiredError} if any required parameter is not provided
  * @openapi operation=getConnection path=/connections/{id} method=GET
  * @memberof Connection
  */
  get(id: UUID): Promise<ConnectionView>;
  /**
  * 
  * @summary Lists all connections
  * @param {string} [filter] An optional filter to search tags by name. This is a case-insensitive filter
  * @param {ConnectionOperationalStatus} [status] An optional parameter to filter on connection status
  * @param {boolean} [fileSupport] List only connections with modules file support active or inactive.
  * @param {boolean} [dataSupport] List only connections with modules data producer support active or inactive.
  * @param {Nmtoken} [tag] List only connections with specific tag type.
  * @param {UUID} [boundaryId] Filters executions by boundary id
  * @param {*} [options] Override http request option.
  * @throws {@link @zerobias-org/types-core-js#ParameterRequiredError} if any required parameter is not provided
  * @openapi operation=listAllConnections path=/connections method=GET
  * @memberof Connection
  */
  list(results: PagedResults<ConnectionListView>, filter?: string, status?: ConnectionOperationalStatusDef, fileSupport?: boolean, dataSupport?: boolean, tag?: Nmtoken, boundaryId?: UUID): Promise<void>;
  /**
  * Re-verifies the ConnectionProfile that is stored. This is for when the ConnectionProfile  is correct, but the external system was misconfigured, resulting in the Connection landing in `error` status.
  * @summary Attempts to verify the currently-stored ConnectionProfile
  * @param {UUID} id Connection ID
  * @param {*} [options] Override http request option.
  * @throws {@link @zerobias-org/types-core-js#ParameterRequiredError} if any required parameter is not provided
  * @openapi operation=reverify path=/connections/{id}/reverify method=PUT
  * @memberof Connection
  */
  reverify(id: UUID): Promise<UpdateConnectionResults>;
  /**
  * Search connections
  * @param {SearchConnectionBody} searchConnectionBody 
  * @param {SortObject} [sort] 
  * @param {UUID} [boundaryId] Filters executions by boundary id
  * @param {*} [options] Override http request option.
  * @throws {@link @zerobias-org/types-core-js#ParameterRequiredError} if any required parameter is not provided
  * @openapi operation=searchConnections path=/connectionSearch method=POST
  * @memberof Connection
  */
  search(results: PagedResults<ConnectionListView>, searchConnectionBody: SearchConnectionBody, sort?: SortObject, boundaryId?: UUID): Promise<void>;
  /**
  * Returns options/filters for connections
  * @param {UUID} [boundaryId] Filters executions by boundary id
  * @param {*} [options] Override http request option.
  * @throws {@link @zerobias-org/types-core-js#ParameterRequiredError} if any required parameter is not provided
  * @openapi operation=searchConnectionsOptions path=/connectionSearch/options method=GET
  * @memberof Connection
  */
  searchOptions(boundaryId?: UUID): Promise<ResultsColumnOptionsWrapper>;
  /**
  * 
  * @summary Updates the ConnectionProfile for this Connection
  * @param {UUID} id Connection ID
  * @param {UpdateConnection} updateConnection 
  * @param {*} [options] Override http request option.
  * @throws {@link @zerobias-org/types-core-js#ParameterRequiredError} if any required parameter is not provided
  * @openapi operation=updateConnection path=/connections/{id} method=PUT
  * @memberof Connection
  */
  update(id: UUID, updateConnection: UpdateConnection): Promise<ConnectionListView>;
  /**
  * This method is deprecated in favor of managing the secret directly.
  * @summary Updates the ConnectionProfile for this Connection
  * @param {UUID} id Connection ID
  * @param {{ [key: string]: any; }} requestBody 
  * @param {*} [options] Override http request option.
  * @throws {@link @zerobias-org/types-core-js#ParameterRequiredError} if any required parameter is not provided
  * @openapi operation=updateConnectionProfile path=/connections/{id}/connectionProfile method=PUT
  * @memberof Connection
  */
  updateConnectionProfile(id: UUID, requestBody: { [key: string]: any; }): Promise<UpdateConnectionResults>;
  /**
  * This method is deprecated in favor of managing the secret directly.
  * @summary Updates the ConnectionProfile, writing the secrets to the given Secrets Manager
  * @param {UUID} id Connection ID
  * @param {{ [key: string]: any; }} requestBody 
  * @param {string} [rootNode] The root secret node to create the new secret under. Hub Server will attempt to determine which one to use if this is not provided. If there are multiple writable root nodes and  this parameter is not provided, an error will be thrown.
  * @param {*} [options] Override http request option.
  * @throws {@link @zerobias-org/types-core-js#ParameterRequiredError} if any required parameter is not provided
  * @openapi operation=updateConnectionProfileSecrets path=/connections/{id}/connectionProfile/secrets method=PUT
  * @memberof Connection
  */
  updateConnectionProfileSecrets(id: UUID, requestBody: { [key: string]: any; }, rootNode?: string): Promise<UpdateConnectionResults>;
}

export class ConnectionApiMappingImpl implements ConnectionApi {
  private producer: ConnectionProducerApi;
  constructor(producer: ConnectionProducerApi) {
    this.producer = producer;
  }

  /**
   * 
   * @summary Calls 'connect' on this connection. This method is only valid if the connection is manually controlled.
   * @param id Connection ID
   * @param oauthRefresh Trigger an oauth refresh on connect
   * @openapi operation=connect path=/connections/{id}/connect method=PUT
   */
  public async connect(id: UUID, oauthRefresh: boolean = false): Promise<void> {
    // verify required parameter 'id' is not null or undefined
    if (id === null || id === undefined) {
      throw new ParameterRequiredError('id');
    }
    return this.producer.connect(id, oauthRefresh);
  }
  /**
   * 
   * @summary Deletes a connection by ID
   * @param id Connection ID
   * @openapi operation=deleteConnection path=/connections/{id} method=DELETE
   */
  public async delete(id: UUID): Promise<void> {
    // verify required parameter 'id' is not null or undefined
    if (id === null || id === undefined) {
      throw new ParameterRequiredError('id');
    }
    return this.producer.delete(id);
  }
  /**
   * 
   * @summary Calls 'disconnect' on this connection. This method is only valid if the connection is manually controlled.
   * @param id Connection ID
   * @openapi operation=disconnect path=/connections/{id}/disconnect method=PUT
   */
  public async disconnect(id: UUID): Promise<void> {
    // verify required parameter 'id' is not null or undefined
    if (id === null || id === undefined) {
      throw new ParameterRequiredError('id');
    }
    return this.producer.disconnect(id);
  }
  /**
   * 
   * @summary Retrieves a connection by ID
   * @param id Connection ID
   * @openapi operation=getConnection path=/connections/{id} method=GET
   */
  public async get(id: UUID): Promise<ConnectionView> {
    // verify required parameter 'id' is not null or undefined
    if (id === null || id === undefined) {
      throw new ParameterRequiredError('id');
    }
    return this.producer.get(id);
  }
  /**
   * 
   * @summary Lists all connections
   * @param pageNumber The requested page. This value is 1-indexed.
   * @param pageSize The number of items in each page of data.
   * @param filter An optional filter to search tags by name. This is a case-insensitive filter
   * @param sortDir Array of directions to sort by. Must correspond with &#x60;sortBy&#x60;
   * @param sortBy Array of columns to sort by, in order
   * @param status An optional parameter to filter on connection status
   * @param fileSupport List only connections with modules file support active or inactive.
   * @param dataSupport List only connections with modules data producer support active or inactive.
   * @param tag List only connections with specific tag type.
   * @param boundaryId Filters executions by boundary id
   * @openapi operation=listAllConnections path=/connections method=GET
   */
  public async list(pageNumber: number = 1, pageSize: number = 50, filter?: string, sortDir?: Array<SortDirectionDef>, sortBy?: Array<string>, status?: ConnectionOperationalStatusDef, fileSupport?: boolean, dataSupport?: boolean, tag?: Nmtoken, boundaryId?: UUID): Promise<PagedResults<ConnectionListView>> {
    if (pageNumber) {
      await Int32.parse(pageNumber);
    }
    if (pageSize) {
      await Int32.parse(pageSize);
    }
    const bag = new PagedResults<ConnectionListView>();
    bag.pageNumber = pageNumber;
    bag.pageSize = pageSize;
    if (sortBy && sortDir) {
      bag.sort(sortBy, sortDir);
    }
    await this.producer.list(bag, filter, status, fileSupport, dataSupport, tag, boundaryId);
    if (bag.items === null || bag.items === undefined) {
      throw new UnexpectedError("Producers must return 'items' for PagedResults queries");
    }
    return bag;
  }
  /**
   * Re-verifies the ConnectionProfile that is stored. This is for when the ConnectionProfile  is correct, but the external system was misconfigured, resulting in the Connection landing in `error` status.
   * @summary Attempts to verify the currently-stored ConnectionProfile
   * @param id Connection ID
   * @openapi operation=reverify path=/connections/{id}/reverify method=PUT
   */
  public async reverify(id: UUID): Promise<UpdateConnectionResults> {
    // verify required parameter 'id' is not null or undefined
    if (id === null || id === undefined) {
      throw new ParameterRequiredError('id');
    }
    return this.producer.reverify(id);
  }
  /**
   * Search connections
   * @param searchConnectionBody 
   * @param pageNumber The requested page. This value is 1-indexed.
   * @param pageSize The number of items in each page of data.
   * @param sort 
   * @param boundaryId Filters executions by boundary id
   * @openapi operation=searchConnections path=/connectionSearch method=POST
   */
  public async search(searchConnectionBody: SearchConnectionBody, pageNumber: number = 1, pageSize: number = 50, sort?: SortObject, boundaryId?: UUID): Promise<PagedResults<ConnectionListView>> {
    // verify required parameter 'searchConnectionBody' is not null or undefined
    if (searchConnectionBody === null || searchConnectionBody === undefined) {
      throw new ParameterRequiredError('searchConnectionBody');
    }
    if (pageNumber) {
      await Int32.parse(pageNumber);
    }
    if (pageSize) {
      await Int32.parse(pageSize);
    }
    const bag = new PagedResults<ConnectionListView>();
    bag.pageNumber = pageNumber;
    bag.pageSize = pageSize;
    await this.producer.search(bag, searchConnectionBody, sort, boundaryId);
    if (bag.items === null || bag.items === undefined) {
      throw new UnexpectedError("Producers must return 'items' for PagedResults queries");
    }
    return bag;
  }
  /**
   * Returns options/filters for connections
   * @param boundaryId Filters executions by boundary id
   * @openapi operation=searchConnectionsOptions path=/connectionSearch/options method=GET
   */
  public async searchOptions(boundaryId?: UUID): Promise<ResultsColumnOptionsWrapper> {
    return this.producer.searchOptions(boundaryId);
  }
  /**
   * 
   * @summary Updates the ConnectionProfile for this Connection
   * @param id Connection ID
   * @param updateConnection 
   * @openapi operation=updateConnection path=/connections/{id} method=PUT
   */
  public async update(id: UUID, updateConnection: UpdateConnection): Promise<ConnectionListView> {
    // verify required parameter 'id' is not null or undefined
    if (id === null || id === undefined) {
      throw new ParameterRequiredError('id');
    }
    // verify required parameter 'updateConnection' is not null or undefined
    if (updateConnection === null || updateConnection === undefined) {
      throw new ParameterRequiredError('updateConnection');
    }
    return this.producer.update(id, updateConnection);
  }
  /**
   * This method is deprecated in favor of managing the secret directly.
   * @summary Updates the ConnectionProfile for this Connection
   * @param id Connection ID
   * @param requestBody 
   * @openapi operation=updateConnectionProfile path=/connections/{id}/connectionProfile method=PUT
   */
  public async updateConnectionProfile(id: UUID, requestBody: { [key: string]: any; }): Promise<UpdateConnectionResults> {
    // verify required parameter 'id' is not null or undefined
    if (id === null || id === undefined) {
      throw new ParameterRequiredError('id');
    }
    // verify required parameter 'requestBody' is not null or undefined
    if (requestBody === null || requestBody === undefined) {
      throw new ParameterRequiredError('requestBody');
    }
    return this.producer.updateConnectionProfile(id, requestBody);
  }
  /**
   * This method is deprecated in favor of managing the secret directly.
   * @summary Updates the ConnectionProfile, writing the secrets to the given Secrets Manager
   * @param id Connection ID
   * @param requestBody 
   * @param rootNode The root secret node to create the new secret under. Hub Server will attempt to determine which one to use if this is not provided. If there are multiple writable root nodes and  this parameter is not provided, an error will be thrown.
   * @openapi operation=updateConnectionProfileSecrets path=/connections/{id}/connectionProfile/secrets method=PUT
   */
  public async updateConnectionProfileSecrets(id: UUID, requestBody: { [key: string]: any; }, rootNode?: string): Promise<UpdateConnectionResults> {
    // verify required parameter 'id' is not null or undefined
    if (id === null || id === undefined) {
      throw new ParameterRequiredError('id');
    }
    // verify required parameter 'requestBody' is not null or undefined
    if (requestBody === null || requestBody === undefined) {
      throw new ParameterRequiredError('requestBody');
    }
    return this.producer.updateConnectionProfileSecrets(id, requestBody, rootNode);
  }
}

/**
 * Wrap producer with mapping implementation
 */
export function wrapConnectionProducer(producer: ConnectionProducerApi): ConnectionApi {
  return new ConnectionApiMappingImpl(producer);
}

/**
 * ConnectionApiHttpImpl - Direct HTTP implementation
 *
 * Makes direct HTTP calls to the API using Axios.
 * Used by SDK clients for platform service access.
 */
export class ConnectionApiHttpImpl implements ConnectionProducerApi {
  private client: AxiosInstance;
  private headers: Record<string, string>;

  constructor(client: AxiosInstance, headers: Record<string, string> = {}) {
    this.client = client;
    this.headers = headers;
  }

  async connect(id: UUID, oauthRefresh?: boolean): Promise<void> {
  const _queryParams = {
      oauthRefresh,
  };
  const _bodyParams = {
      
  };
  let _path = '/connections/{id}/connect';
  _path = _path.replace('{id}', encodeURIComponent(String(id)));
  return this.client.put(
    _path,
    _bodyParams)
    .then((response) => {
      // BaseApiClient uses validateStatus: () => true, so we must check status manually
      if (response.status >= 400) {
        throw CoreError.deserialize(response.data);
      }
      return ObjectSerializer.deserialize(response.data, '')
    })
    .catch((error) => {
      if (error.data) {
        throw CoreError.deserialize(error.data);
      } else {
        throw error;
      }
    });
  }
  async delete(id: UUID): Promise<void> {
  const _queryParams = {
      
  };
  const _bodyParams = {
      
  };
  let _path = '/connections/{id}';
  _path = _path.replace('{id}', encodeURIComponent(String(id)));
  return this.client.delete(
    _path,
    { params: _queryParams })
    .then((response) => {
      // BaseApiClient uses validateStatus: () => true, so we must check status manually
      if (response.status >= 400) {
        throw CoreError.deserialize(response.data);
      }
      return ObjectSerializer.deserialize(response.data, '')
    })
    .catch((error) => {
      if (error.data) {
        throw CoreError.deserialize(error.data);
      } else {
        throw error;
      }
    });
  }
  async disconnect(id: UUID): Promise<void> {
  const _queryParams = {
      
  };
  const _bodyParams = {
      
  };
  let _path = '/connections/{id}/disconnect';
  _path = _path.replace('{id}', encodeURIComponent(String(id)));
  return this.client.put(
    _path,
    _bodyParams)
    .then((response) => {
      // BaseApiClient uses validateStatus: () => true, so we must check status manually
      if (response.status >= 400) {
        throw CoreError.deserialize(response.data);
      }
      return ObjectSerializer.deserialize(response.data, '')
    })
    .catch((error) => {
      if (error.data) {
        throw CoreError.deserialize(error.data);
      } else {
        throw error;
      }
    });
  }
  async get(id: UUID): Promise<ConnectionView> {
  const _queryParams = {
      
  };
  const _bodyParams = {
      
  };
  let _path = '/connections/{id}';
  _path = _path.replace('{id}', encodeURIComponent(String(id)));
  return this.client.get(
    _path,
    { params: _queryParams })
    .then((response) => {
      // BaseApiClient uses validateStatus: () => true, so we must check status manually
      if (response.status >= 400) {
        throw CoreError.deserialize(response.data);
      }
      return ObjectSerializer.deserialize(response.data, 'ConnectionView')
    })
    .catch((error) => {
      if (error.data) {
        throw CoreError.deserialize(error.data);
      } else {
        throw error;
      }
    });
  }
  async list(results: PagedResults<ConnectionListView>, filter?: string, status?: ConnectionOperationalStatusDef, fileSupport?: boolean, dataSupport?: boolean, tag?: Nmtoken, boundaryId?: UUID): Promise<void> {
  const _body = {
      filter,status,fileSupport,dataSupport,tag,boundaryId,
  };
  let _path = '/connections';
  return this.client.get(
    _path,
    {
      params: {
        ..._body,
        pageNumber: results.pageNumber,
        pageSize: results.pageSize,
      }
    })
    .then((response) => {
      // BaseApiClient uses validateStatus: () => true, so we must check status manually
      if (response.status >= 400) {
        throw CoreError.deserialize(response.data);
      }
      results.items = ObjectSerializer.deserialize(response.data, 'Array<ConnectionListView>');
      results.count = response.headers.count ? Number(response.headers.count) : -1;
      results.pageToken = response.headers.pagetoken ?? response.headers.pageToken;
      results.headers = this.headers;
      results.baseUrl = new URL(`${this.client.getUri()}/connections`);
      results.httpMethod = HttpMethod.Get;
      results.body = _body;
      results.mapper = (obj) => ObjectSerializer.deserialize(obj, 'ConnectionListView');
    })
    .catch((error) => {
      if (error.data) {
        throw CoreError.deserialize(error.data);
      } else {
        throw error;
      }
    });
  }
  async reverify(id: UUID): Promise<UpdateConnectionResults> {
  const _queryParams = {
      
  };
  const _bodyParams = {
      
  };
  let _path = '/connections/{id}/reverify';
  _path = _path.replace('{id}', encodeURIComponent(String(id)));
  return this.client.put(
    _path,
    _bodyParams)
    .then((response) => {
      // BaseApiClient uses validateStatus: () => true, so we must check status manually
      if (response.status >= 400) {
        throw CoreError.deserialize(response.data);
      }
      return ObjectSerializer.deserialize(response.data, 'UpdateConnectionResults')
    })
    .catch((error) => {
      if (error.data) {
        throw CoreError.deserialize(error.data);
      } else {
        throw error;
      }
    });
  }
  async search(results: PagedResults<ConnectionListView>, searchConnectionBody: SearchConnectionBody, sort?: SortObject, boundaryId?: UUID): Promise<void> {
  const _body = {
      searchConnectionBody,sort,boundaryId,
  };
  let _path = '/connectionSearch';
  return this.client.post(
    _path,
    {
      ..._body,
      pageNumber: results.pageNumber,
      pageSize: results.pageSize,
    })
    .then((response) => {
      // BaseApiClient uses validateStatus: () => true, so we must check status manually
      if (response.status >= 400) {
        throw CoreError.deserialize(response.data);
      }
      results.items = ObjectSerializer.deserialize(response.data, 'Array<ConnectionListView>');
      results.count = response.headers.count ? Number(response.headers.count) : -1;
      results.pageToken = response.headers.pagetoken ?? response.headers.pageToken;
      results.headers = this.headers;
      results.baseUrl = new URL(`${this.client.getUri()}/connectionSearch`);
      results.httpMethod = HttpMethod.Post;
      results.body = _body;
      results.mapper = (obj) => ObjectSerializer.deserialize(obj, 'ConnectionListView');
    })
    .catch((error) => {
      if (error.data) {
        throw CoreError.deserialize(error.data);
      } else {
        throw error;
      }
    });
  }
  async searchOptions(boundaryId?: UUID): Promise<ResultsColumnOptionsWrapper> {
  const _queryParams = {
      boundaryId,
  };
  const _bodyParams = {
      
  };
  let _path = '/connectionSearch/options';
  return this.client.get(
    _path,
    { params: _queryParams })
    .then((response) => {
      // BaseApiClient uses validateStatus: () => true, so we must check status manually
      if (response.status >= 400) {
        throw CoreError.deserialize(response.data);
      }
      return ObjectSerializer.deserialize(response.data, 'ResultsColumnOptionsWrapper')
    })
    .catch((error) => {
      if (error.data) {
        throw CoreError.deserialize(error.data);
      } else {
        throw error;
      }
    });
  }
  async update(id: UUID, updateConnection: UpdateConnection): Promise<ConnectionListView> {
  const _queryParams = {
      
  };
  const _bodyParams = {
      updateConnection,
  };
  let _path = '/connections/{id}';
  _path = _path.replace('{id}', encodeURIComponent(String(id)));
  return this.client.put(
    _path,
    _bodyParams)
    .then((response) => {
      // BaseApiClient uses validateStatus: () => true, so we must check status manually
      if (response.status >= 400) {
        throw CoreError.deserialize(response.data);
      }
      return ObjectSerializer.deserialize(response.data, 'ConnectionListView')
    })
    .catch((error) => {
      if (error.data) {
        throw CoreError.deserialize(error.data);
      } else {
        throw error;
      }
    });
  }
  async updateConnectionProfile(id: UUID, requestBody: { [key: string]: any; }): Promise<UpdateConnectionResults> {
  const _queryParams = {
      
  };
  const _bodyParams = {
      requestBody,
  };
  let _path = '/connections/{id}/connectionProfile';
  _path = _path.replace('{id}', encodeURIComponent(String(id)));
  return this.client.put(
    _path,
    _bodyParams)
    .then((response) => {
      // BaseApiClient uses validateStatus: () => true, so we must check status manually
      if (response.status >= 400) {
        throw CoreError.deserialize(response.data);
      }
      return ObjectSerializer.deserialize(response.data, 'UpdateConnectionResults')
    })
    .catch((error) => {
      if (error.data) {
        throw CoreError.deserialize(error.data);
      } else {
        throw error;
      }
    });
  }
  async updateConnectionProfileSecrets(id: UUID, requestBody: { [key: string]: any; }, rootNode?: string): Promise<UpdateConnectionResults> {
  const _queryParams = {
      rootNode,
  };
  const _bodyParams = {
      requestBody,
  };
  let _path = '/connections/{id}/connectionProfile/secrets';
  _path = _path.replace('{id}', encodeURIComponent(String(id)));
  return this.client.put(
    _path,
    _bodyParams)
    .then((response) => {
      // BaseApiClient uses validateStatus: () => true, so we must check status manually
      if (response.status >= 400) {
        throw CoreError.deserialize(response.data);
      }
      return ObjectSerializer.deserialize(response.data, 'UpdateConnectionResults')
    })
    .catch((error) => {
      if (error.data) {
        throw CoreError.deserialize(error.data);
      } else {
        throw error;
      }
    });
  }
}
