/* eslint-disable */
// ===============================================
// This file is autogenerated - Please do not edit
// ===============================================
import { EnumValue, IllegalArgumentError } from '@zerobias-org/types-core-js';
import { ObjectSerializer, RequestFile } from './index.js';

/**
* Schema for Start/Stop options
*/
export class SsOptions {
  /**
  * The action to perform over the record
  */
  'action': SsOptions.ActionEnumDef;
  'previewCount'?: number | null;

  static readonly discriminator: string | undefined = undefined;

  static attributeTypeMap: ReadonlyArray<{name: string, baseName: string, type: string, format: string}> = [
    {
      "name": "action",
      "baseName": "action",
      // true
      // SsOptions.ActionEnum
      // SsOptions.ActionEnumDef
      "type": "SsOptions.ActionEnum",
      "format": ""
    },
    {
      "name": "previewCount",
      "baseName": "previewCount",
      // false
      // number
      // number
      "type": "number",
      "format": "int32"
    }  ];

  static getAttributeTypeMap() {
    return SsOptions.attributeTypeMap;
  }

  static newInstance(obj: any): SsOptions {
    return ObjectSerializer.deserialize(obj, 'SsOptions');
  }

  constructor(action: SsOptions.ActionEnumDef, previewCount?: number) {
    this.action = action;
    this.previewCount = previewCount;
  }
}

export namespace SsOptions {
  export const ActionEnum = {
    /**  */
    Start: EnumValue.instance('SsOptions.ActionEnum', 'Start', 'start'),
    /**  */
    Stop: EnumValue.instance('SsOptions.ActionEnum', 'Stop', 'stop'),
    /**  */
    RunOnce: EnumValue.instance('SsOptions.ActionEnum', 'RunOnce', 'runOnce'),
    /**  */
    Preview: EnumValue.instance('SsOptions.ActionEnum', 'Preview', 'preview'),

    from(val: string | number): EnumValue {
      if (ActionEnum[val]) {
        return ActionEnum[val];
      }
      const byValue = ActionEnum.values.find((v) => v.value === val);
      if (byValue) {
        return byValue;
      }
      throw new IllegalArgumentError(`${val} is not a valid ActionEnum`);
    },

    get values(): EnumValue[] {
      return Object
        .keys(ActionEnum)
        .filter((k) => k !== 'values' && k !== 'from')
        .map((t) => ActionEnum[t]);
    }
  } as const;

  export type ActionEnumDef = typeof ActionEnum[keyof typeof ActionEnum];
}
