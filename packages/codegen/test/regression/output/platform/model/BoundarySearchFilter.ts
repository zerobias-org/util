/* eslint-disable */
// ===============================================
// This file is autogenerated - Please do not edit
// ===============================================
import { EnumValue, Nmtoken, IllegalArgumentError } from '@zerobias-org/types-core-js';
import { ObjectSerializer, RequestFile } from './index.js';

/**
* Filters to apply when searching for entities in a boundary
*/
export class BoundarySearchFilter {
  /**
  * Type of search we are performing which dictates what resources we see
  */
  'searchType': BoundarySearchFilter.SearchTypeEnumDef;
  /**
  * Super Type of objects to search for.
  */
  'kind'?: Array<BoundarySearchFilter.KindEnumDef>;
  /**
  * Keywords to search by. These will be combined as an `or`
  */
  'keywords'?: Array<string>;
  /**
  * Names of tags to search for. These will be combined as an `or`
  */
  'tags'?: Array<Nmtoken>;

  static readonly discriminator: string | undefined = undefined;

  static attributeTypeMap: ReadonlyArray<{name: string, baseName: string, type: string, format: string}> = [
    {
      "name": "searchType",
      "baseName": "searchType",
      // true
      // BoundarySearchFilter.SearchTypeEnum
      // BoundarySearchFilter.SearchTypeEnumDef
      "type": "BoundarySearchFilter.SearchTypeEnum",
      "format": ""
    },
    {
      "name": "kind",
      "baseName": "kind",
      // true
      // Array&lt;BoundarySearchFilter.KindEnum&gt;
      // Array&lt;BoundarySearchFilter.KindEnumDef&gt;
      "type": "Array<BoundarySearchFilter.KindEnum>",
      "format": ""
    },
    {
      "name": "keywords",
      "baseName": "keywords",
      // false
      // Array&lt;string&gt;
      // Array&lt;string&gt;
      "type": "Array<string>",
      "format": ""
    },
    {
      "name": "tags",
      "baseName": "tags",
      // false
      // Array&lt;Nmtoken&gt;
      // Array&lt;Nmtoken&gt;
      "type": "Array<Nmtoken>",
      "format": "nmtoken"
    }  ];

  static getAttributeTypeMap() {
    return BoundarySearchFilter.attributeTypeMap;
  }

  static newInstance(obj: any): BoundarySearchFilter {
    return ObjectSerializer.deserialize(obj, 'BoundarySearchFilter');
  }

  constructor(searchType: BoundarySearchFilter.SearchTypeEnumDef, kind?: Array<BoundarySearchFilter.KindEnumDef>, keywords?: Array<string>, tags?: Array<Nmtoken>) {
    this.searchType = searchType;
    this.kind = kind;
    this.keywords = keywords;
    this.tags = tags;
  }
}

export namespace BoundarySearchFilter {
  export const SearchTypeEnum = {
    /**  */
    Nav: EnumValue.instance('BoundarySearchFilter.SearchTypeEnum', 'Nav', 'nav'),
    /**  */
    Auditgraph: EnumValue.instance('BoundarySearchFilter.SearchTypeEnum', 'Auditgraph', 'auditgraph'),

    from(val: string | number): EnumValue {
      if (SearchTypeEnum[val]) {
        return SearchTypeEnum[val];
      }
      const byValue = SearchTypeEnum.values.find((v) => v.value === val);
      if (byValue) {
        return byValue;
      }
      throw new IllegalArgumentError(`${val} is not a valid SearchTypeEnum`);
    },

    get values(): EnumValue[] {
      return Object
        .keys(SearchTypeEnum)
        .filter((k) => k !== 'values' && k !== 'from')
        .map((t) => SearchTypeEnum[t]);
    }
  } as const;

  export type SearchTypeEnumDef = typeof SearchTypeEnum[keyof typeof SearchTypeEnum];
  export const KindEnum = {
    /**  */
    Object: EnumValue.instance('BoundarySearchFilter.KindEnum', 'Object', 'object'),
    /**  */
    Resource: EnumValue.instance('BoundarySearchFilter.KindEnum', 'Resource', 'resource'),
    /**  */
    Tag: EnumValue.instance('BoundarySearchFilter.KindEnum', 'Tag', 'tag'),

    from(val: string | number): EnumValue {
      if (KindEnum[val]) {
        return KindEnum[val];
      }
      const byValue = KindEnum.values.find((v) => v.value === val);
      if (byValue) {
        return byValue;
      }
      throw new IllegalArgumentError(`${val} is not a valid KindEnum`);
    },

    get values(): EnumValue[] {
      return Object
        .keys(KindEnum)
        .filter((k) => k !== 'values' && k !== 'from')
        .map((t) => KindEnum[t]);
    }
  } as const;

  export type KindEnumDef = typeof KindEnum[keyof typeof KindEnum];
}
