/* eslint-disable */
// ===============================================
// This file is autogenerated - Please do not edit
// ===============================================
import { EnumValue, IllegalArgumentError, UUID } from '@zerobias-org/types-core-js';
import { ObjectSerializer, RequestFile } from './index.js';

/**
* Request body for suggest resource link api call
*/
export class SuggestResourceLinkBody {
  'linkSide': SuggestResourceLinkBody.LinkSideEnumDef;
  'linkTypeId': UUID;
  'resourceId': UUID;

  static readonly discriminator: string | undefined = undefined;

  static attributeTypeMap: ReadonlyArray<{name: string, baseName: string, type: string, format: string}> = [
    {
      "name": "linkSide",
      "baseName": "linkSide",
      // true
      // SuggestResourceLinkBody.LinkSideEnum
      // SuggestResourceLinkBody.LinkSideEnumDef
      "type": "SuggestResourceLinkBody.LinkSideEnum",
      "format": ""
    },
    {
      "name": "linkTypeId",
      "baseName": "linkTypeId",
      // false
      // UUID
      // UUID
      "type": "UUID",
      "format": "uuid"
    },
    {
      "name": "resourceId",
      "baseName": "resourceId",
      // false
      // UUID
      // UUID
      "type": "UUID",
      "format": "uuid"
    }  ];

  static getAttributeTypeMap() {
    return SuggestResourceLinkBody.attributeTypeMap;
  }

  static newInstance(obj: any): SuggestResourceLinkBody {
    return ObjectSerializer.deserialize(obj, 'SuggestResourceLinkBody');
  }

  constructor(linkSide: SuggestResourceLinkBody.LinkSideEnumDef, linkTypeId: UUID, resourceId: UUID, ) {
    this.linkSide = linkSide;
    this.linkTypeId = linkTypeId;
    this.resourceId = resourceId;
  }
}

export namespace SuggestResourceLinkBody {
  export const LinkSideEnum = {
    /**  */
    FromSide: EnumValue.instance('SuggestResourceLinkBody.LinkSideEnum', 'FromSide', 'from_side'),
    /**  */
    ToSide: EnumValue.instance('SuggestResourceLinkBody.LinkSideEnum', 'ToSide', 'to_side'),

    from(val: string | number): EnumValue {
      if (LinkSideEnum[val]) {
        return LinkSideEnum[val];
      }
      const byValue = LinkSideEnum.values.find((v) => v.value === val);
      if (byValue) {
        return byValue;
      }
      throw new IllegalArgumentError(`${val} is not a valid LinkSideEnum`);
    },

    get values(): EnumValue[] {
      return Object
        .keys(LinkSideEnum)
        .filter((k) => k !== 'values' && k !== 'from')
        .map((t) => LinkSideEnum[t]);
    }
  } as const;

  export type LinkSideEnumDef = typeof LinkSideEnum[keyof typeof LinkSideEnum];
}
