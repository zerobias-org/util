/* eslint-disable */
// ===============================================
// This file is autogenerated - Please do not edit
// ===============================================
import { EnumValue, IllegalArgumentError, UUID } from '@zerobias-org/types-core-js';
import { ObjectSerializer, RequestFile } from './index.js';

/**
* Extended update information for artifact
*/
export class LoadTask {
  'status': LoadTask.StatusEnumDef;
  'action': LoadTask.ActionEnumDef;
  'txId': UUID;
  'artifact': string;
  'forced': boolean;
  'startTime': Date;
  'errorMessage'?: string | null;
  'errorStack'?: string | null;
  'endTime'?: Date | null;

  static readonly discriminator: string | undefined = undefined;

  static attributeTypeMap: ReadonlyArray<{name: string, baseName: string, type: string, format: string}> = [
    {
      "name": "status",
      "baseName": "status",
      // true
      // LoadTask.StatusEnum
      // LoadTask.StatusEnumDef
      "type": "LoadTask.StatusEnum",
      "format": ""
    },
    {
      "name": "action",
      "baseName": "action",
      // true
      // LoadTask.ActionEnum
      // LoadTask.ActionEnumDef
      "type": "LoadTask.ActionEnum",
      "format": ""
    },
    {
      "name": "txId",
      "baseName": "txId",
      // false
      // UUID
      // UUID
      "type": "UUID",
      "format": "uuid"
    },
    {
      "name": "artifact",
      "baseName": "artifact",
      // false
      // string
      // string
      "type": "string",
      "format": ""
    },
    {
      "name": "forced",
      "baseName": "forced",
      // false
      // boolean
      // boolean
      "type": "boolean",
      "format": ""
    },
    {
      "name": "startTime",
      "baseName": "startTime",
      // false
      // Date
      // Date
      "type": "Date",
      "format": "date-time"
    },
    {
      "name": "errorMessage",
      "baseName": "errorMessage",
      // false
      // string
      // string
      "type": "string",
      "format": ""
    },
    {
      "name": "errorStack",
      "baseName": "errorStack",
      // false
      // string
      // string
      "type": "string",
      "format": ""
    },
    {
      "name": "endTime",
      "baseName": "endTime",
      // false
      // Date
      // Date
      "type": "Date",
      "format": "date-time"
    }  ];

  static getAttributeTypeMap() {
    return LoadTask.attributeTypeMap;
  }

  static newInstance(obj: any): LoadTask {
    return ObjectSerializer.deserialize(obj, 'LoadTask');
  }

  constructor(status: LoadTask.StatusEnumDef, action: LoadTask.ActionEnumDef, txId: UUID, artifact: string, forced: boolean, startTime: Date, errorMessage?: string, errorStack?: string, endTime?: Date) {
    this.status = status;
    this.action = action;
    this.txId = txId;
    this.artifact = artifact;
    this.forced = forced;
    this.startTime = startTime;
    this.errorMessage = errorMessage;
    this.errorStack = errorStack;
    this.endTime = endTime;
  }
}

export namespace LoadTask {
  export const StatusEnum = {
    /**  */
    Starting: EnumValue.instance('LoadTask.StatusEnum', 'Starting', 'starting'),
    /**  */
    Running: EnumValue.instance('LoadTask.StatusEnum', 'Running', 'running'),
    /**  */
    Failed: EnumValue.instance('LoadTask.StatusEnum', 'Failed', 'failed'),
    /**  */
    Finished: EnumValue.instance('LoadTask.StatusEnum', 'Finished', 'finished'),

    from(val: string | number): EnumValue {
      if (StatusEnum[val]) {
        return StatusEnum[val];
      }
      const byValue = StatusEnum.values.find((v) => v.value === val);
      if (byValue) {
        return byValue;
      }
      throw new IllegalArgumentError(`${val} is not a valid StatusEnum`);
    },

    get values(): EnumValue[] {
      return Object
        .keys(StatusEnum)
        .filter((k) => k !== 'values' && k !== 'from')
        .map((t) => StatusEnum[t]);
    }
  } as const;

  export type StatusEnumDef = typeof StatusEnum[keyof typeof StatusEnum];
  export const ActionEnum = {
    /**  */
    LoadArtifact: EnumValue.instance('LoadTask.ActionEnum', 'LoadArtifact', 'load-artifact'),

    from(val: string | number): EnumValue {
      if (ActionEnum[val]) {
        return ActionEnum[val];
      }
      const byValue = ActionEnum.values.find((v) => v.value === val);
      if (byValue) {
        return byValue;
      }
      throw new IllegalArgumentError(`${val} is not a valid ActionEnum`);
    },

    get values(): EnumValue[] {
      return Object
        .keys(ActionEnum)
        .filter((k) => k !== 'values' && k !== 'from')
        .map((t) => ActionEnum[t]);
    }
  } as const;

  export type ActionEnumDef = typeof ActionEnum[keyof typeof ActionEnum];
}
