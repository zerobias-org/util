/* eslint-disable */
// ===============================================
// This file is autogenerated - Please do not edit
// ===============================================
import { EnumValue, IllegalArgumentError } from '@zerobias-org/types-core-js';
import { ObjectSerializer, RequestFile } from './index.js';

/**
* Schema for Publish/Retire options
*/
export class PROptions {
  /**
  * The action to perform over the record should be `publish` or `retire`
  */
  'action': PROptions.ActionEnumDef;

  static readonly discriminator: string | undefined = undefined;

  static attributeTypeMap: ReadonlyArray<{name: string, baseName: string, type: string, format: string}> = [
    {
      "name": "action",
      "baseName": "action",
      // true
      // PROptions.ActionEnum
      // PROptions.ActionEnumDef
      "type": "PROptions.ActionEnum",
      "format": ""
    }  ];

  static getAttributeTypeMap() {
    return PROptions.attributeTypeMap;
  }

  static newInstance(obj: any): PROptions {
    return ObjectSerializer.deserialize(obj, 'PROptions');
  }

  constructor(action: PROptions.ActionEnumDef, ) {
    this.action = action;
  }
}

export namespace PROptions {
  export const ActionEnum = {
    /**  */
    Publish: EnumValue.instance('PROptions.ActionEnum', 'Publish', 'publish'),
    /**  */
    Retire: EnumValue.instance('PROptions.ActionEnum', 'Retire', 'retire'),

    from(val: string | number): EnumValue {
      if (ActionEnum[val]) {
        return ActionEnum[val];
      }
      const byValue = ActionEnum.values.find((v) => v.value === val);
      if (byValue) {
        return byValue;
      }
      throw new IllegalArgumentError(`${val} is not a valid ActionEnum`);
    },

    get values(): EnumValue[] {
      return Object
        .keys(ActionEnum)
        .filter((k) => k !== 'values' && k !== 'from')
        .map((t) => ActionEnum[t]);
    }
  } as const;

  export type ActionEnumDef = typeof ActionEnum[keyof typeof ActionEnum];
}
