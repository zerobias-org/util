/* eslint-disable */
// ===============================================
// This file is autogenerated - Please do not edit
// ===============================================
import { AxiosInstance } from 'axios';
import { ActivityExtended, ActivityTypeEnumDef, SchemasLinkType, SortObject } from '../model/index.js';
import { URL, EnumValue, IllegalArgumentError, PagedResults, Int32, UUID, CoreError, ParameterRequiredError, UnexpectedError, HttpMethod } from '@zerobias-org/types-core-js';
import { RequestFile, ObjectSerializer } from '../model/index.js';

export namespace ActivityApi {
}

/**
 * ActivityApi - interface
 * @export
 * @interface ActivityApi
 */
export interface ActivityApi {
  /**
   * Get activity by id
   * @summary Get activity by id
   * @param {string} idOrCode 
   * @param {*} [options] Override http request option.
   * @throws {@link @zerobias-org/types-core-js#ParameterRequiredError} if any required parameter is not provided
   * @example
   * ```typescript
   * const result = await api.get('idOrCode');
   * ```
   * @openapi operation=getActivity path=/catalog/activities/{idOrCode} method=GET
   * @memberof ActivityApi
   */
  get(idOrCode: string): Promise<ActivityExtended>;

  /**
   * list all activities
   * @summary list all activities
   * @param {number} [pageNumber] The requested page. This value is 1-indexed.
   * @param {number} [pageSize] The number of items in each page of data.
   * @param {SortObject} [sort] Sort object
   * @param {string} [search] 
   * @param {Array<string>} [resourceType] Filter by resource type. This will filter out any activity that is incompatible with the given resource types. When provding multiple resource types, filter behaves like an OR and will return activities compatible with &#x60;any&#x60; of those types. Activities that do not provide any link requirements will always be returned.
   * @param {ActivityTypeEnum} [activityType] Filter by activity type
   * @param {*} [options] Override http request option.
   * @throws {@link @zerobias-org/types-core-js#ParameterRequiredError} if any required parameter is not provided
   * @example
   * ```typescript
   * const result = await api.list(1, 1, null, 'search', null, null);
   * ```
   * @openapi operation=listActivities path=/catalog/activities method=GET
   * @memberof ActivityApi
   */
  list(pageNumber?: number, pageSize?: number, sort?: SortObject, search?: string, resourceType?: Array<string>, activityType?: ActivityTypeEnumDef): Promise<PagedResults<ActivityExtended>>;

  /**
   * list all link types available for this activity
   * @summary list all link types available for this activity
   * @param {UUID} id 
   * @param {number} [pageNumber] The requested page. This value is 1-indexed.
   * @param {number} [pageSize] The number of items in each page of data.
   * @param {*} [options] Override http request option.
   * @throws {@link @zerobias-org/types-core-js#ParameterRequiredError} if any required parameter is not provided
   * @example
   * ```typescript
   * const result = await api.listLinkTypes('00000000-0000-0000-0000-000000000000', 1, 1);
   * ```
   * @openapi operation=listActivityLinkTypes path=/catalog/activities/{id}/linkTypes method=GET
   * @memberof ActivityApi
   */
  listLinkTypes(id: UUID, pageNumber?: number, pageSize?: number): Promise<PagedResults<SchemasLinkType>>;

}

/**
 * ActivityProducerApi - interface
 * Producer interface for Activity
 * @export
 * @interface ActivityProducerApi
 */
export interface ActivityProducerApi {
  /**
  * Get activity by id
  * @summary Get activity by id
  * @param {string} idOrCode 
  * @param {*} [options] Override http request option.
  * @throws {@link @zerobias-org/types-core-js#ParameterRequiredError} if any required parameter is not provided
  * @openapi operation=getActivity path=/catalog/activities/{idOrCode} method=GET
  * @memberof Activity
  */
  get(idOrCode: string): Promise<ActivityExtended>;
  /**
  * list all activities
  * @summary list all activities
  * @param {SortObject} [sort] Sort object
  * @param {string} [search] 
  * @param {Array<string>} [resourceType] Filter by resource type. This will filter out any activity that is incompatible with the given resource types. When provding multiple resource types, filter behaves like an OR and will return activities compatible with &#x60;any&#x60; of those types. Activities that do not provide any link requirements will always be returned.
  * @param {ActivityTypeEnum} [activityType] Filter by activity type
  * @param {*} [options] Override http request option.
  * @throws {@link @zerobias-org/types-core-js#ParameterRequiredError} if any required parameter is not provided
  * @openapi operation=listActivities path=/catalog/activities method=GET
  * @memberof Activity
  */
  list(results: PagedResults<ActivityExtended>, sort?: SortObject, search?: string, resourceType?: Array<string>, activityType?: ActivityTypeEnumDef): Promise<void>;
  /**
  * list all link types available for this activity
  * @summary list all link types available for this activity
  * @param {UUID} id 
  * @param {*} [options] Override http request option.
  * @throws {@link @zerobias-org/types-core-js#ParameterRequiredError} if any required parameter is not provided
  * @openapi operation=listActivityLinkTypes path=/catalog/activities/{id}/linkTypes method=GET
  * @memberof Activity
  */
  listLinkTypes(results: PagedResults<SchemasLinkType>, id: UUID): Promise<void>;
}

export class ActivityApiMappingImpl implements ActivityApi {
  private producer: ActivityProducerApi;
  constructor(producer: ActivityProducerApi) {
    this.producer = producer;
  }

  /**
   * Get activity by id
   * @summary Get activity by id
   * @param idOrCode 
   * @openapi operation=getActivity path=/catalog/activities/{idOrCode} method=GET
   */
  public async get(idOrCode: string): Promise<ActivityExtended> {
    // verify required parameter 'idOrCode' is not null or undefined
    if (idOrCode === null || idOrCode === undefined || idOrCode === '') {
      throw new ParameterRequiredError('idOrCode');
    }
    return this.producer.get(idOrCode);
  }
  /**
   * list all activities
   * @summary list all activities
   * @param pageNumber The requested page. This value is 1-indexed.
   * @param pageSize The number of items in each page of data.
   * @param sort Sort object
   * @param search 
   * @param resourceType Filter by resource type. This will filter out any activity that is incompatible with the given resource types. When provding multiple resource types, filter behaves like an OR and will return activities compatible with &#x60;any&#x60; of those types. Activities that do not provide any link requirements will always be returned.
   * @param activityType Filter by activity type
   * @openapi operation=listActivities path=/catalog/activities method=GET
   */
  public async list(pageNumber: number = 1, pageSize: number = 50, sort?: SortObject, search?: string, resourceType?: Array<string>, activityType?: ActivityTypeEnumDef): Promise<PagedResults<ActivityExtended>> {
    if (pageNumber) {
      await Int32.parse(pageNumber);
    }
    if (pageSize) {
      await Int32.parse(pageSize);
    }
    const bag = new PagedResults<ActivityExtended>();
    bag.pageNumber = pageNumber;
    bag.pageSize = pageSize;
    await this.producer.list(bag, sort, search, resourceType, activityType);
    if (bag.items === null || bag.items === undefined) {
      throw new UnexpectedError("Producers must return 'items' for PagedResults queries");
    }
    return bag;
  }
  /**
   * list all link types available for this activity
   * @summary list all link types available for this activity
   * @param id 
   * @param pageNumber The requested page. This value is 1-indexed.
   * @param pageSize The number of items in each page of data.
   * @openapi operation=listActivityLinkTypes path=/catalog/activities/{id}/linkTypes method=GET
   */
  public async listLinkTypes(id: UUID, pageNumber: number = 1, pageSize: number = 50): Promise<PagedResults<SchemasLinkType>> {
    // verify required parameter 'id' is not null or undefined
    if (id === null || id === undefined) {
      throw new ParameterRequiredError('id');
    }
    if (pageNumber) {
      await Int32.parse(pageNumber);
    }
    if (pageSize) {
      await Int32.parse(pageSize);
    }
    const bag = new PagedResults<SchemasLinkType>();
    bag.pageNumber = pageNumber;
    bag.pageSize = pageSize;
    await this.producer.listLinkTypes(bag, id);
    if (bag.items === null || bag.items === undefined) {
      throw new UnexpectedError("Producers must return 'items' for PagedResults queries");
    }
    return bag;
  }
}

/**
 * Wrap producer with mapping implementation
 */
export function wrapActivityProducer(producer: ActivityProducerApi): ActivityApi {
  return new ActivityApiMappingImpl(producer);
}

/**
 * ActivityApiHttpImpl - Direct HTTP implementation
 *
 * Makes direct HTTP calls to the API using Axios.
 * Used by SDK clients for platform service access.
 */
export class ActivityApiHttpImpl implements ActivityProducerApi {
  private client: AxiosInstance;
  private headers: Record<string, string>;

  constructor(client: AxiosInstance, headers: Record<string, string> = {}) {
    this.client = client;
    this.headers = headers;
  }

  async get(idOrCode: string): Promise<ActivityExtended> {
  const _queryParams = {
      
  };
  const _bodyParams = {
      
  };
  let _path = '/catalog/activities/{idOrCode}';
  _path = _path.replace('{idOrCode}', encodeURIComponent(String(idOrCode)));
  return this.client.get(
    _path,
    { params: _queryParams })
    .then((response) => {
      // BaseApiClient uses validateStatus: () => true, so we must check status manually
      if (response.status >= 400) {
        throw CoreError.deserialize(response.data);
      }
      return ObjectSerializer.deserialize(response.data, 'ActivityExtended')
    })
    .catch((error) => {
      if (error.data) {
        throw CoreError.deserialize(error.data);
      } else {
        throw error;
      }
    });
  }
  async list(results: PagedResults<ActivityExtended>, sort?: SortObject, search?: string, resourceType?: Array<string>, activityType?: ActivityTypeEnumDef): Promise<void> {
  const _body = {
      sort,search,resourceType,activityType,
  };
  let _path = '/catalog/activities';
  return this.client.get(
    _path,
    {
      params: {
        ..._body,
        pageNumber: results.pageNumber,
        pageSize: results.pageSize,
      }
    })
    .then((response) => {
      // BaseApiClient uses validateStatus: () => true, so we must check status manually
      if (response.status >= 400) {
        throw CoreError.deserialize(response.data);
      }
      results.items = ObjectSerializer.deserialize(response.data, 'Array<ActivityExtended>');
      results.count = response.headers.count ? Number(response.headers.count) : -1;
      results.pageToken = response.headers.pagetoken ?? response.headers.pageToken;
      results.headers = this.headers;
      results.baseUrl = new URL(`${this.client.getUri()}/catalog/activities`);
      results.httpMethod = HttpMethod.Get;
      results.body = _body;
      results.mapper = (obj) => ObjectSerializer.deserialize(obj, 'ActivityExtended');
    })
    .catch((error) => {
      if (error.data) {
        throw CoreError.deserialize(error.data);
      } else {
        throw error;
      }
    });
  }
  async listLinkTypes(results: PagedResults<SchemasLinkType>, id: UUID): Promise<void> {
  const _body = {
      id,
  };
  let _path = '/catalog/activities/{id}/linkTypes';
  _path = _path.replace('{id}', encodeURIComponent(String(id)));
  return this.client.get(
    _path,
    {
      params: {
        ..._body,
        pageNumber: results.pageNumber,
        pageSize: results.pageSize,
      }
    })
    .then((response) => {
      // BaseApiClient uses validateStatus: () => true, so we must check status manually
      if (response.status >= 400) {
        throw CoreError.deserialize(response.data);
      }
      results.items = ObjectSerializer.deserialize(response.data, 'Array<SchemasLinkType>');
      results.count = response.headers.count ? Number(response.headers.count) : -1;
      results.pageToken = response.headers.pagetoken ?? response.headers.pageToken;
      results.headers = this.headers;
      results.baseUrl = new URL(`${this.client.getUri()}/catalog/activities/{id}/linkTypes`);
      results.httpMethod = HttpMethod.Get;
      results.body = _body;
      results.mapper = (obj) => ObjectSerializer.deserialize(obj, 'SchemasLinkType');
    })
    .catch((error) => {
      if (error.data) {
        throw CoreError.deserialize(error.data);
      } else {
        throw error;
      }
    });
  }
}
