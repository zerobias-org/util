/* eslint-disable */
// ===============================================
// This file is autogenerated - Please do not edit
// ===============================================
import { AxiosInstance } from 'axios';
import { BaselineBenchmarkElementExtended, BaselineElementExtended, BaselineExtended, BenchmarkElementExtended, BenchmarkExtended, SeverityDef, SortObject, StandardStatusDef, TestCaseExtended } from '../model/index.js';
import { URL, EnumValue, IllegalArgumentError, PagedResults, Int32, UUID, CoreError, ParameterRequiredError, UnexpectedError, HttpMethod } from '@zerobias-org/types-core-js';
import { RequestFile, ObjectSerializer } from '../model/index.js';

export namespace BenchmarkApi {
}

/**
 * BenchmarkApi - interface
 * @export
 * @interface BenchmarkApi
 */
export interface BenchmarkApi {
  /**
   * Browse benchmark baseline element
   * @summary Browse benchmark baseline element
   * @param {string} benchmarkCode 
   * @param {string} baselineCode 
   * @param {string} elementCode 
   * @param {*} [options] Override http request option.
   * @throws {@link @zerobias-org/types-core-js#ParameterRequiredError} if any required parameter is not provided
   * @example
   * ```typescript
   * const result = await api.browseBenchmarkBaselineElement('benchmarkCode', 'baselineCode', 'elementCode');
   * ```
   * @openapi operation=browseBenchmarkBaselineElement path=/benchmarkBrowser/{benchmarkCode}/{baselineCode}/{elementCode} method=GET
   * @memberof BenchmarkApi
   */
  browseBenchmarkBaselineElement(benchmarkCode: string, baselineCode: string, elementCode: string): Promise<BaselineElementExtended>;

  /**
   * Browse benchmark baseline elements
   * @summary Browse benchmark baseline elements
   * @param {string} benchmarkCode 
   * @param {string} baselineCode 
   * @param {number} [pageNumber] The requested page. This value is 1-indexed.
   * @param {number} [pageSize] The number of items in each page of data.
   * @param {*} [options] Override http request option.
   * @throws {@link @zerobias-org/types-core-js#ParameterRequiredError} if any required parameter is not provided
   * @example
   * ```typescript
   * const result = await api.browseBenchmarkBaselineElements('benchmarkCode', 'baselineCode', 1, 1);
   * ```
   * @openapi operation=browseBenchmarkBaselineElements path=/benchmarkBrowser/{benchmarkCode}/{baselineCode} method=GET
   * @memberof BenchmarkApi
   */
  browseBenchmarkBaselineElements(benchmarkCode: string, baselineCode: string, pageNumber?: number, pageSize?: number): Promise<PagedResults<BaselineElementExtended>>;

  /**
   * Browse benchmark baselines
   * @summary Browse benchmark baselines
   * @param {string} benchmarkCode 
   * @param {number} [pageNumber] The requested page. This value is 1-indexed.
   * @param {number} [pageSize] The number of items in each page of data.
   * @param {*} [options] Override http request option.
   * @throws {@link @zerobias-org/types-core-js#ParameterRequiredError} if any required parameter is not provided
   * @example
   * ```typescript
   * const result = await api.browseBenchmarkBaselines('benchmarkCode', 1, 1);
   * ```
   * @openapi operation=browseBenchmarkBaselines path=/benchmarkBrowser/{benchmarkCode} method=GET
   * @memberof BenchmarkApi
   */
  browseBenchmarkBaselines(benchmarkCode: string, pageNumber?: number, pageSize?: number): Promise<PagedResults<BaselineExtended>>;

  /**
   * Browse benchmarks
   * @summary Browse benchmarks
   * @param {number} [pageNumber] The requested page. This value is 1-indexed.
   * @param {number} [pageSize] The number of items in each page of data.
   * @param {*} [options] Override http request option.
   * @throws {@link @zerobias-org/types-core-js#ParameterRequiredError} if any required parameter is not provided
   * @example
   * ```typescript
   * const result = await api.browseBenchmarks(1, 1);
   * ```
   * @openapi operation=browseBenchmarks path=/benchmarkBrowser method=GET
   * @memberof BenchmarkApi
   */
  browseBenchmarks(pageNumber?: number, pageSize?: number): Promise<PagedResults<BenchmarkExtended>>;

  /**
   * Get benchmark by id
   * @summary Get benchmark by id
   * @param {UUID} benchmarkId 
   * @param {*} [options] Override http request option.
   * @throws {@link @zerobias-org/types-core-js#ParameterRequiredError} if any required parameter is not provided
   * @example
   * ```typescript
   * const result = await api.get('00000000-0000-0000-0000-000000000000');
   * ```
   * @openapi operation=getBenchmark path=/benchmarks/{benchmarkId} method=GET
   * @memberof BenchmarkApi
   */
  get(benchmarkId: UUID): Promise<BenchmarkExtended>;

  /**
   * Get baseline by benchmark and baseline id
   * @summary Get baseline by benchmark and baseline id
   * @param {UUID} benchmarkId 
   * @param {UUID} baselineId 
   * @param {*} [options] Override http request option.
   * @throws {@link @zerobias-org/types-core-js#ParameterRequiredError} if any required parameter is not provided
   * @example
   * ```typescript
   * const result = await api.getBaseline('00000000-0000-0000-0000-000000000000', '00000000-0000-0000-0000-000000000000');
   * ```
   * @openapi operation=getBenchmarkBaseline path=/benchmarks/{benchmarkId}/baselines/{baselineId} method=GET
   * @memberof BenchmarkApi
   */
  getBaseline(benchmarkId: UUID, baselineId: UUID): Promise<BaselineExtended>;

  /**
   * Get element by benchmark and baseline and element id
   * @summary Get element by benchmark and baseline and element id
   * @param {UUID} benchmarkId 
   * @param {UUID} baselineId 
   * @param {UUID} elementId 
   * @param {*} [options] Override http request option.
   * @throws {@link @zerobias-org/types-core-js#ParameterRequiredError} if any required parameter is not provided
   * @example
   * ```typescript
   * const result = await api.getBaselineElement('00000000-0000-0000-0000-000000000000', '00000000-0000-0000-0000-000000000000', '00000000-0000-0000-0000-000000000000');
   * ```
   * @openapi operation=getBenchmarkBaselineElement path=/benchmarks/{benchmarkId}/baselines/{baselineId}/elements/{elementId} method=GET
   * @memberof BenchmarkApi
   */
  getBaselineElement(benchmarkId: UUID, baselineId: UUID, elementId: UUID): Promise<BaselineBenchmarkElementExtended>;

  /**
   * Get element by benchmark and element id
   * @summary Get element by benchmark and element id
   * @param {UUID} benchmarkId 
   * @param {UUID} elementId 
   * @param {*} [options] Override http request option.
   * @throws {@link @zerobias-org/types-core-js#ParameterRequiredError} if any required parameter is not provided
   * @example
   * ```typescript
   * const result = await api.getElement('00000000-0000-0000-0000-000000000000', '00000000-0000-0000-0000-000000000000');
   * ```
   * @openapi operation=getBenchmarkElement path=/benchmarks/{benchmarkId}/elements/{elementId} method=GET
   * @memberof BenchmarkApi
   */
  getElement(benchmarkId: UUID, elementId: UUID): Promise<BenchmarkElementExtended>;

  /**
   * Get test case by benchmark and test case id
   * @summary Get test case by benchmark and test case id
   * @param {UUID} benchmarkId 
   * @param {UUID} testCaseId 
   * @param {*} [options] Override http request option.
   * @throws {@link @zerobias-org/types-core-js#ParameterRequiredError} if any required parameter is not provided
   * @example
   * ```typescript
   * const result = await api.getTestCase('00000000-0000-0000-0000-000000000000', '00000000-0000-0000-0000-000000000000');
   * ```
   * @openapi operation=getBenchmarkTestCase path=/benchmarks/{benchmarkId}/testCases/{testCaseId} method=GET
   * @memberof BenchmarkApi
   */
  getTestCase(benchmarkId: UUID, testCaseId: UUID): Promise<TestCaseExtended>;

  /**
   * list all benchmark baseline elements
   * @summary list all benchmark baseline elements
   * @param {UUID} benchmarkId 
   * @param {UUID} baselineId 
   * @param {number} [pageNumber] The requested page. This value is 1-indexed.
   * @param {number} [pageSize] The number of items in each page of data.
   * @param {UUID} [elementTypeId] 
   * @param {string} [search] 
   * @param {SortObject} [sort] Sort object
   * @param {*} [options] Override http request option.
   * @throws {@link @zerobias-org/types-core-js#ParameterRequiredError} if any required parameter is not provided
   * @example
   * ```typescript
   * const result = await api.listBaselineElements('00000000-0000-0000-0000-000000000000', '00000000-0000-0000-0000-000000000000', 1, 1, '00000000-0000-0000-0000-000000000000', 'search', null);
   * ```
   * @openapi operation=listBenchmarkBaselineElements path=/benchmarks/{benchmarkId}/baselines/{baselineId}/elements method=GET
   * @memberof BenchmarkApi
   */
  listBaselineElements(benchmarkId: UUID, baselineId: UUID, pageNumber?: number, pageSize?: number, elementTypeId?: UUID, search?: string, sort?: SortObject): Promise<PagedResults<BaselineBenchmarkElementExtended>>;

  /**
   * list all benchmark baselines
   * @summary list all benchmark baselines
   * @param {UUID} benchmarkId 
   * @param {number} [pageNumber] The requested page. This value is 1-indexed.
   * @param {number} [pageSize] The number of items in each page of data.
   * @param {string} [search] 
   * @param {SortObject} [sort] Sort object
   * @param {*} [options] Override http request option.
   * @throws {@link @zerobias-org/types-core-js#ParameterRequiredError} if any required parameter is not provided
   * @example
   * ```typescript
   * const result = await api.listBaselines('00000000-0000-0000-0000-000000000000', 1, 1, 'search', null);
   * ```
   * @openapi operation=listBenchmarkBaselines path=/benchmarks/{benchmarkId}/baselines method=GET
   * @memberof BenchmarkApi
   */
  listBaselines(benchmarkId: UUID, pageNumber?: number, pageSize?: number, search?: string, sort?: SortObject): Promise<PagedResults<BaselineExtended>>;

  /**
   * list all benchmark elements
   * @summary list all benchmark elements
   * @param {UUID} benchmarkId 
   * @param {number} [pageNumber] The requested page. This value is 1-indexed.
   * @param {number} [pageSize] The number of items in each page of data.
   * @param {UUID} [elementTypeId] 
   * @param {string} [search] 
   * @param {string} [packageCode] 
   * @param {Severity} [severity] 
   * @param {SortObject} [sort] Sort object
   * @param {*} [options] Override http request option.
   * @throws {@link @zerobias-org/types-core-js#ParameterRequiredError} if any required parameter is not provided
   * @example
   * ```typescript
   * const result = await api.listElements('00000000-0000-0000-0000-000000000000', 1, 1, '00000000-0000-0000-0000-000000000000', 'search', 'packageCode', null, null);
   * ```
   * @openapi operation=listBenchmarkElements path=/benchmarks/{benchmarkId}/elements method=GET
   * @memberof BenchmarkApi
   */
  listElements(benchmarkId: UUID, pageNumber?: number, pageSize?: number, elementTypeId?: UUID, search?: string, packageCode?: string, severity?: SeverityDef, sort?: SortObject): Promise<PagedResults<BenchmarkElementExtended>>;

  /**
   * list all benchmark test cases
   * @summary list all benchmark test cases
   * @param {UUID} benchmarkId 
   * @param {number} [pageNumber] The requested page. This value is 1-indexed.
   * @param {number} [pageSize] The number of items in each page of data.
   * @param {string} [search] 
   * @param {SortObject} [sort] Sort object
   * @param {*} [options] Override http request option.
   * @throws {@link @zerobias-org/types-core-js#ParameterRequiredError} if any required parameter is not provided
   * @example
   * ```typescript
   * const result = await api.listTestCases('00000000-0000-0000-0000-000000000000', 1, 1, 'search', null);
   * ```
   * @openapi operation=listBenchmarkTestCases path=/benchmarks/{benchmarkId}/testCases method=GET
   * @memberof BenchmarkApi
   */
  listTestCases(benchmarkId: UUID, pageNumber?: number, pageSize?: number, search?: string, sort?: SortObject): Promise<PagedResults<TestCaseExtended>>;

  /**
   * list all benchmarks
   * @summary list all benchmarks
   * @param {number} [pageNumber] The requested page. This value is 1-indexed.
   * @param {number} [pageSize] The number of items in each page of data.
   * @param {StandardStatus} [status] 
   * @param {string} [search] 
   * @param {string} [packageCode] 
   * @param {UUID} [vspId] 
   * @param {SortObject} [sort] Sort object
   * @param {*} [options] Override http request option.
   * @throws {@link @zerobias-org/types-core-js#ParameterRequiredError} if any required parameter is not provided
   * @example
   * ```typescript
   * const result = await api.list(1, 1, null, 'search', 'packageCode', '00000000-0000-0000-0000-000000000000', null);
   * ```
   * @openapi operation=listBenchmarks path=/benchmarks method=GET
   * @memberof BenchmarkApi
   */
  list(pageNumber?: number, pageSize?: number, status?: StandardStatusDef, search?: string, packageCode?: string, vspId?: UUID, sort?: SortObject): Promise<PagedResults<BenchmarkExtended>>;

}

/**
 * BenchmarkProducerApi - interface
 * Producer interface for Benchmark
 * @export
 * @interface BenchmarkProducerApi
 */
export interface BenchmarkProducerApi {
  /**
  * Browse benchmark baseline element
  * @summary Browse benchmark baseline element
  * @param {string} benchmarkCode 
  * @param {string} baselineCode 
  * @param {string} elementCode 
  * @param {*} [options] Override http request option.
  * @throws {@link @zerobias-org/types-core-js#ParameterRequiredError} if any required parameter is not provided
  * @openapi operation=browseBenchmarkBaselineElement path=/benchmarkBrowser/{benchmarkCode}/{baselineCode}/{elementCode} method=GET
  * @memberof Benchmark
  */
  browseBenchmarkBaselineElement(benchmarkCode: string, baselineCode: string, elementCode: string): Promise<BaselineElementExtended>;
  /**
  * Browse benchmark baseline elements
  * @summary Browse benchmark baseline elements
  * @param {string} benchmarkCode 
  * @param {string} baselineCode 
  * @param {*} [options] Override http request option.
  * @throws {@link @zerobias-org/types-core-js#ParameterRequiredError} if any required parameter is not provided
  * @openapi operation=browseBenchmarkBaselineElements path=/benchmarkBrowser/{benchmarkCode}/{baselineCode} method=GET
  * @memberof Benchmark
  */
  browseBenchmarkBaselineElements(results: PagedResults<BaselineElementExtended>, benchmarkCode: string, baselineCode: string): Promise<void>;
  /**
  * Browse benchmark baselines
  * @summary Browse benchmark baselines
  * @param {string} benchmarkCode 
  * @param {*} [options] Override http request option.
  * @throws {@link @zerobias-org/types-core-js#ParameterRequiredError} if any required parameter is not provided
  * @openapi operation=browseBenchmarkBaselines path=/benchmarkBrowser/{benchmarkCode} method=GET
  * @memberof Benchmark
  */
  browseBenchmarkBaselines(results: PagedResults<BaselineExtended>, benchmarkCode: string): Promise<void>;
  /**
  * Browse benchmarks
  * @summary Browse benchmarks
  * @param {*} [options] Override http request option.
  * @throws {@link @zerobias-org/types-core-js#ParameterRequiredError} if any required parameter is not provided
  * @openapi operation=browseBenchmarks path=/benchmarkBrowser method=GET
  * @memberof Benchmark
  */
  browseBenchmarks(results: PagedResults<BenchmarkExtended>): Promise<void>;
  /**
  * Get benchmark by id
  * @summary Get benchmark by id
  * @param {UUID} benchmarkId 
  * @param {*} [options] Override http request option.
  * @throws {@link @zerobias-org/types-core-js#ParameterRequiredError} if any required parameter is not provided
  * @openapi operation=getBenchmark path=/benchmarks/{benchmarkId} method=GET
  * @memberof Benchmark
  */
  get(benchmarkId: UUID): Promise<BenchmarkExtended>;
  /**
  * Get baseline by benchmark and baseline id
  * @summary Get baseline by benchmark and baseline id
  * @param {UUID} benchmarkId 
  * @param {UUID} baselineId 
  * @param {*} [options] Override http request option.
  * @throws {@link @zerobias-org/types-core-js#ParameterRequiredError} if any required parameter is not provided
  * @openapi operation=getBenchmarkBaseline path=/benchmarks/{benchmarkId}/baselines/{baselineId} method=GET
  * @memberof Benchmark
  */
  getBaseline(benchmarkId: UUID, baselineId: UUID): Promise<BaselineExtended>;
  /**
  * Get element by benchmark and baseline and element id
  * @summary Get element by benchmark and baseline and element id
  * @param {UUID} benchmarkId 
  * @param {UUID} baselineId 
  * @param {UUID} elementId 
  * @param {*} [options] Override http request option.
  * @throws {@link @zerobias-org/types-core-js#ParameterRequiredError} if any required parameter is not provided
  * @openapi operation=getBenchmarkBaselineElement path=/benchmarks/{benchmarkId}/baselines/{baselineId}/elements/{elementId} method=GET
  * @memberof Benchmark
  */
  getBaselineElement(benchmarkId: UUID, baselineId: UUID, elementId: UUID): Promise<BaselineBenchmarkElementExtended>;
  /**
  * Get element by benchmark and element id
  * @summary Get element by benchmark and element id
  * @param {UUID} benchmarkId 
  * @param {UUID} elementId 
  * @param {*} [options] Override http request option.
  * @throws {@link @zerobias-org/types-core-js#ParameterRequiredError} if any required parameter is not provided
  * @openapi operation=getBenchmarkElement path=/benchmarks/{benchmarkId}/elements/{elementId} method=GET
  * @memberof Benchmark
  */
  getElement(benchmarkId: UUID, elementId: UUID): Promise<BenchmarkElementExtended>;
  /**
  * Get test case by benchmark and test case id
  * @summary Get test case by benchmark and test case id
  * @param {UUID} benchmarkId 
  * @param {UUID} testCaseId 
  * @param {*} [options] Override http request option.
  * @throws {@link @zerobias-org/types-core-js#ParameterRequiredError} if any required parameter is not provided
  * @openapi operation=getBenchmarkTestCase path=/benchmarks/{benchmarkId}/testCases/{testCaseId} method=GET
  * @memberof Benchmark
  */
  getTestCase(benchmarkId: UUID, testCaseId: UUID): Promise<TestCaseExtended>;
  /**
  * list all benchmark baseline elements
  * @summary list all benchmark baseline elements
  * @param {UUID} benchmarkId 
  * @param {UUID} baselineId 
  * @param {UUID} [elementTypeId] 
  * @param {string} [search] 
  * @param {SortObject} [sort] Sort object
  * @param {*} [options] Override http request option.
  * @throws {@link @zerobias-org/types-core-js#ParameterRequiredError} if any required parameter is not provided
  * @openapi operation=listBenchmarkBaselineElements path=/benchmarks/{benchmarkId}/baselines/{baselineId}/elements method=GET
  * @memberof Benchmark
  */
  listBaselineElements(results: PagedResults<BaselineBenchmarkElementExtended>, benchmarkId: UUID, baselineId: UUID, elementTypeId?: UUID, search?: string, sort?: SortObject): Promise<void>;
  /**
  * list all benchmark baselines
  * @summary list all benchmark baselines
  * @param {UUID} benchmarkId 
  * @param {string} [search] 
  * @param {SortObject} [sort] Sort object
  * @param {*} [options] Override http request option.
  * @throws {@link @zerobias-org/types-core-js#ParameterRequiredError} if any required parameter is not provided
  * @openapi operation=listBenchmarkBaselines path=/benchmarks/{benchmarkId}/baselines method=GET
  * @memberof Benchmark
  */
  listBaselines(results: PagedResults<BaselineExtended>, benchmarkId: UUID, search?: string, sort?: SortObject): Promise<void>;
  /**
  * list all benchmark elements
  * @summary list all benchmark elements
  * @param {UUID} benchmarkId 
  * @param {UUID} [elementTypeId] 
  * @param {string} [search] 
  * @param {string} [packageCode] 
  * @param {Severity} [severity] 
  * @param {SortObject} [sort] Sort object
  * @param {*} [options] Override http request option.
  * @throws {@link @zerobias-org/types-core-js#ParameterRequiredError} if any required parameter is not provided
  * @openapi operation=listBenchmarkElements path=/benchmarks/{benchmarkId}/elements method=GET
  * @memberof Benchmark
  */
  listElements(results: PagedResults<BenchmarkElementExtended>, benchmarkId: UUID, elementTypeId?: UUID, search?: string, packageCode?: string, severity?: SeverityDef, sort?: SortObject): Promise<void>;
  /**
  * list all benchmark test cases
  * @summary list all benchmark test cases
  * @param {UUID} benchmarkId 
  * @param {string} [search] 
  * @param {SortObject} [sort] Sort object
  * @param {*} [options] Override http request option.
  * @throws {@link @zerobias-org/types-core-js#ParameterRequiredError} if any required parameter is not provided
  * @openapi operation=listBenchmarkTestCases path=/benchmarks/{benchmarkId}/testCases method=GET
  * @memberof Benchmark
  */
  listTestCases(results: PagedResults<TestCaseExtended>, benchmarkId: UUID, search?: string, sort?: SortObject): Promise<void>;
  /**
  * list all benchmarks
  * @summary list all benchmarks
  * @param {StandardStatus} [status] 
  * @param {string} [search] 
  * @param {string} [packageCode] 
  * @param {UUID} [vspId] 
  * @param {SortObject} [sort] Sort object
  * @param {*} [options] Override http request option.
  * @throws {@link @zerobias-org/types-core-js#ParameterRequiredError} if any required parameter is not provided
  * @openapi operation=listBenchmarks path=/benchmarks method=GET
  * @memberof Benchmark
  */
  list(results: PagedResults<BenchmarkExtended>, status?: StandardStatusDef, search?: string, packageCode?: string, vspId?: UUID, sort?: SortObject): Promise<void>;
}

export class BenchmarkApiMappingImpl implements BenchmarkApi {
  private producer: BenchmarkProducerApi;
  constructor(producer: BenchmarkProducerApi) {
    this.producer = producer;
  }

  /**
   * Browse benchmark baseline element
   * @summary Browse benchmark baseline element
   * @param benchmarkCode 
   * @param baselineCode 
   * @param elementCode 
   * @openapi operation=browseBenchmarkBaselineElement path=/benchmarkBrowser/{benchmarkCode}/{baselineCode}/{elementCode} method=GET
   */
  public async browseBenchmarkBaselineElement(benchmarkCode: string, baselineCode: string, elementCode: string): Promise<BaselineElementExtended> {
    // verify required parameter 'benchmarkCode' is not null or undefined
    if (benchmarkCode === null || benchmarkCode === undefined || benchmarkCode === '') {
      throw new ParameterRequiredError('benchmarkCode');
    }
    // verify required parameter 'baselineCode' is not null or undefined
    if (baselineCode === null || baselineCode === undefined || baselineCode === '') {
      throw new ParameterRequiredError('baselineCode');
    }
    // verify required parameter 'elementCode' is not null or undefined
    if (elementCode === null || elementCode === undefined || elementCode === '') {
      throw new ParameterRequiredError('elementCode');
    }
    return this.producer.browseBenchmarkBaselineElement(benchmarkCode, baselineCode, elementCode);
  }
  /**
   * Browse benchmark baseline elements
   * @summary Browse benchmark baseline elements
   * @param benchmarkCode 
   * @param baselineCode 
   * @param pageNumber The requested page. This value is 1-indexed.
   * @param pageSize The number of items in each page of data.
   * @openapi operation=browseBenchmarkBaselineElements path=/benchmarkBrowser/{benchmarkCode}/{baselineCode} method=GET
   */
  public async browseBenchmarkBaselineElements(benchmarkCode: string, baselineCode: string, pageNumber: number = 1, pageSize: number = 50): Promise<PagedResults<BaselineElementExtended>> {
    // verify required parameter 'benchmarkCode' is not null or undefined
    if (benchmarkCode === null || benchmarkCode === undefined || benchmarkCode === '') {
      throw new ParameterRequiredError('benchmarkCode');
    }
    // verify required parameter 'baselineCode' is not null or undefined
    if (baselineCode === null || baselineCode === undefined || baselineCode === '') {
      throw new ParameterRequiredError('baselineCode');
    }
    if (pageNumber) {
      await Int32.parse(pageNumber);
    }
    if (pageSize) {
      await Int32.parse(pageSize);
    }
    const bag = new PagedResults<BaselineElementExtended>();
    bag.pageNumber = pageNumber;
    bag.pageSize = pageSize;
    await this.producer.browseBenchmarkBaselineElements(bag, benchmarkCode, baselineCode);
    if (bag.items === null || bag.items === undefined) {
      throw new UnexpectedError("Producers must return 'items' for PagedResults queries");
    }
    return bag;
  }
  /**
   * Browse benchmark baselines
   * @summary Browse benchmark baselines
   * @param benchmarkCode 
   * @param pageNumber The requested page. This value is 1-indexed.
   * @param pageSize The number of items in each page of data.
   * @openapi operation=browseBenchmarkBaselines path=/benchmarkBrowser/{benchmarkCode} method=GET
   */
  public async browseBenchmarkBaselines(benchmarkCode: string, pageNumber: number = 1, pageSize: number = 50): Promise<PagedResults<BaselineExtended>> {
    // verify required parameter 'benchmarkCode' is not null or undefined
    if (benchmarkCode === null || benchmarkCode === undefined || benchmarkCode === '') {
      throw new ParameterRequiredError('benchmarkCode');
    }
    if (pageNumber) {
      await Int32.parse(pageNumber);
    }
    if (pageSize) {
      await Int32.parse(pageSize);
    }
    const bag = new PagedResults<BaselineExtended>();
    bag.pageNumber = pageNumber;
    bag.pageSize = pageSize;
    await this.producer.browseBenchmarkBaselines(bag, benchmarkCode);
    if (bag.items === null || bag.items === undefined) {
      throw new UnexpectedError("Producers must return 'items' for PagedResults queries");
    }
    return bag;
  }
  /**
   * Browse benchmarks
   * @summary Browse benchmarks
   * @param pageNumber The requested page. This value is 1-indexed.
   * @param pageSize The number of items in each page of data.
   * @openapi operation=browseBenchmarks path=/benchmarkBrowser method=GET
   */
  public async browseBenchmarks(pageNumber: number = 1, pageSize: number = 50): Promise<PagedResults<BenchmarkExtended>> {
    if (pageNumber) {
      await Int32.parse(pageNumber);
    }
    if (pageSize) {
      await Int32.parse(pageSize);
    }
    const bag = new PagedResults<BenchmarkExtended>();
    bag.pageNumber = pageNumber;
    bag.pageSize = pageSize;
    await this.producer.browseBenchmarks(bag);
    if (bag.items === null || bag.items === undefined) {
      throw new UnexpectedError("Producers must return 'items' for PagedResults queries");
    }
    return bag;
  }
  /**
   * Get benchmark by id
   * @summary Get benchmark by id
   * @param benchmarkId 
   * @openapi operation=getBenchmark path=/benchmarks/{benchmarkId} method=GET
   */
  public async get(benchmarkId: UUID): Promise<BenchmarkExtended> {
    // verify required parameter 'benchmarkId' is not null or undefined
    if (benchmarkId === null || benchmarkId === undefined) {
      throw new ParameterRequiredError('benchmarkId');
    }
    return this.producer.get(benchmarkId);
  }
  /**
   * Get baseline by benchmark and baseline id
   * @summary Get baseline by benchmark and baseline id
   * @param benchmarkId 
   * @param baselineId 
   * @openapi operation=getBenchmarkBaseline path=/benchmarks/{benchmarkId}/baselines/{baselineId} method=GET
   */
  public async getBaseline(benchmarkId: UUID, baselineId: UUID): Promise<BaselineExtended> {
    // verify required parameter 'benchmarkId' is not null or undefined
    if (benchmarkId === null || benchmarkId === undefined) {
      throw new ParameterRequiredError('benchmarkId');
    }
    // verify required parameter 'baselineId' is not null or undefined
    if (baselineId === null || baselineId === undefined) {
      throw new ParameterRequiredError('baselineId');
    }
    return this.producer.getBaseline(benchmarkId, baselineId);
  }
  /**
   * Get element by benchmark and baseline and element id
   * @summary Get element by benchmark and baseline and element id
   * @param benchmarkId 
   * @param baselineId 
   * @param elementId 
   * @openapi operation=getBenchmarkBaselineElement path=/benchmarks/{benchmarkId}/baselines/{baselineId}/elements/{elementId} method=GET
   */
  public async getBaselineElement(benchmarkId: UUID, baselineId: UUID, elementId: UUID): Promise<BaselineBenchmarkElementExtended> {
    // verify required parameter 'benchmarkId' is not null or undefined
    if (benchmarkId === null || benchmarkId === undefined) {
      throw new ParameterRequiredError('benchmarkId');
    }
    // verify required parameter 'baselineId' is not null or undefined
    if (baselineId === null || baselineId === undefined) {
      throw new ParameterRequiredError('baselineId');
    }
    // verify required parameter 'elementId' is not null or undefined
    if (elementId === null || elementId === undefined) {
      throw new ParameterRequiredError('elementId');
    }
    return this.producer.getBaselineElement(benchmarkId, baselineId, elementId);
  }
  /**
   * Get element by benchmark and element id
   * @summary Get element by benchmark and element id
   * @param benchmarkId 
   * @param elementId 
   * @openapi operation=getBenchmarkElement path=/benchmarks/{benchmarkId}/elements/{elementId} method=GET
   */
  public async getElement(benchmarkId: UUID, elementId: UUID): Promise<BenchmarkElementExtended> {
    // verify required parameter 'benchmarkId' is not null or undefined
    if (benchmarkId === null || benchmarkId === undefined) {
      throw new ParameterRequiredError('benchmarkId');
    }
    // verify required parameter 'elementId' is not null or undefined
    if (elementId === null || elementId === undefined) {
      throw new ParameterRequiredError('elementId');
    }
    return this.producer.getElement(benchmarkId, elementId);
  }
  /**
   * Get test case by benchmark and test case id
   * @summary Get test case by benchmark and test case id
   * @param benchmarkId 
   * @param testCaseId 
   * @openapi operation=getBenchmarkTestCase path=/benchmarks/{benchmarkId}/testCases/{testCaseId} method=GET
   */
  public async getTestCase(benchmarkId: UUID, testCaseId: UUID): Promise<TestCaseExtended> {
    // verify required parameter 'benchmarkId' is not null or undefined
    if (benchmarkId === null || benchmarkId === undefined) {
      throw new ParameterRequiredError('benchmarkId');
    }
    // verify required parameter 'testCaseId' is not null or undefined
    if (testCaseId === null || testCaseId === undefined) {
      throw new ParameterRequiredError('testCaseId');
    }
    return this.producer.getTestCase(benchmarkId, testCaseId);
  }
  /**
   * list all benchmark baseline elements
   * @summary list all benchmark baseline elements
   * @param benchmarkId 
   * @param baselineId 
   * @param pageNumber The requested page. This value is 1-indexed.
   * @param pageSize The number of items in each page of data.
   * @param elementTypeId 
   * @param search 
   * @param sort Sort object
   * @openapi operation=listBenchmarkBaselineElements path=/benchmarks/{benchmarkId}/baselines/{baselineId}/elements method=GET
   */
  public async listBaselineElements(benchmarkId: UUID, baselineId: UUID, pageNumber: number = 1, pageSize: number = 50, elementTypeId?: UUID, search?: string, sort?: SortObject): Promise<PagedResults<BaselineBenchmarkElementExtended>> {
    // verify required parameter 'benchmarkId' is not null or undefined
    if (benchmarkId === null || benchmarkId === undefined) {
      throw new ParameterRequiredError('benchmarkId');
    }
    // verify required parameter 'baselineId' is not null or undefined
    if (baselineId === null || baselineId === undefined) {
      throw new ParameterRequiredError('baselineId');
    }
    if (pageNumber) {
      await Int32.parse(pageNumber);
    }
    if (pageSize) {
      await Int32.parse(pageSize);
    }
    const bag = new PagedResults<BaselineBenchmarkElementExtended>();
    bag.pageNumber = pageNumber;
    bag.pageSize = pageSize;
    await this.producer.listBaselineElements(bag, benchmarkId, baselineId, elementTypeId, search, sort);
    if (bag.items === null || bag.items === undefined) {
      throw new UnexpectedError("Producers must return 'items' for PagedResults queries");
    }
    return bag;
  }
  /**
   * list all benchmark baselines
   * @summary list all benchmark baselines
   * @param benchmarkId 
   * @param pageNumber The requested page. This value is 1-indexed.
   * @param pageSize The number of items in each page of data.
   * @param search 
   * @param sort Sort object
   * @openapi operation=listBenchmarkBaselines path=/benchmarks/{benchmarkId}/baselines method=GET
   */
  public async listBaselines(benchmarkId: UUID, pageNumber: number = 1, pageSize: number = 50, search?: string, sort?: SortObject): Promise<PagedResults<BaselineExtended>> {
    // verify required parameter 'benchmarkId' is not null or undefined
    if (benchmarkId === null || benchmarkId === undefined) {
      throw new ParameterRequiredError('benchmarkId');
    }
    if (pageNumber) {
      await Int32.parse(pageNumber);
    }
    if (pageSize) {
      await Int32.parse(pageSize);
    }
    const bag = new PagedResults<BaselineExtended>();
    bag.pageNumber = pageNumber;
    bag.pageSize = pageSize;
    await this.producer.listBaselines(bag, benchmarkId, search, sort);
    if (bag.items === null || bag.items === undefined) {
      throw new UnexpectedError("Producers must return 'items' for PagedResults queries");
    }
    return bag;
  }
  /**
   * list all benchmark elements
   * @summary list all benchmark elements
   * @param benchmarkId 
   * @param pageNumber The requested page. This value is 1-indexed.
   * @param pageSize The number of items in each page of data.
   * @param elementTypeId 
   * @param search 
   * @param packageCode 
   * @param severity 
   * @param sort Sort object
   * @openapi operation=listBenchmarkElements path=/benchmarks/{benchmarkId}/elements method=GET
   */
  public async listElements(benchmarkId: UUID, pageNumber: number = 1, pageSize: number = 50, elementTypeId?: UUID, search?: string, packageCode?: string, severity?: SeverityDef, sort?: SortObject): Promise<PagedResults<BenchmarkElementExtended>> {
    // verify required parameter 'benchmarkId' is not null or undefined
    if (benchmarkId === null || benchmarkId === undefined) {
      throw new ParameterRequiredError('benchmarkId');
    }
    if (pageNumber) {
      await Int32.parse(pageNumber);
    }
    if (pageSize) {
      await Int32.parse(pageSize);
    }
    const bag = new PagedResults<BenchmarkElementExtended>();
    bag.pageNumber = pageNumber;
    bag.pageSize = pageSize;
    await this.producer.listElements(bag, benchmarkId, elementTypeId, search, packageCode, severity, sort);
    if (bag.items === null || bag.items === undefined) {
      throw new UnexpectedError("Producers must return 'items' for PagedResults queries");
    }
    return bag;
  }
  /**
   * list all benchmark test cases
   * @summary list all benchmark test cases
   * @param benchmarkId 
   * @param pageNumber The requested page. This value is 1-indexed.
   * @param pageSize The number of items in each page of data.
   * @param search 
   * @param sort Sort object
   * @openapi operation=listBenchmarkTestCases path=/benchmarks/{benchmarkId}/testCases method=GET
   */
  public async listTestCases(benchmarkId: UUID, pageNumber: number = 1, pageSize: number = 50, search?: string, sort?: SortObject): Promise<PagedResults<TestCaseExtended>> {
    // verify required parameter 'benchmarkId' is not null or undefined
    if (benchmarkId === null || benchmarkId === undefined) {
      throw new ParameterRequiredError('benchmarkId');
    }
    if (pageNumber) {
      await Int32.parse(pageNumber);
    }
    if (pageSize) {
      await Int32.parse(pageSize);
    }
    const bag = new PagedResults<TestCaseExtended>();
    bag.pageNumber = pageNumber;
    bag.pageSize = pageSize;
    await this.producer.listTestCases(bag, benchmarkId, search, sort);
    if (bag.items === null || bag.items === undefined) {
      throw new UnexpectedError("Producers must return 'items' for PagedResults queries");
    }
    return bag;
  }
  /**
   * list all benchmarks
   * @summary list all benchmarks
   * @param pageNumber The requested page. This value is 1-indexed.
   * @param pageSize The number of items in each page of data.
   * @param status 
   * @param search 
   * @param packageCode 
   * @param vspId 
   * @param sort Sort object
   * @openapi operation=listBenchmarks path=/benchmarks method=GET
   */
  public async list(pageNumber: number = 1, pageSize: number = 50, status?: StandardStatusDef, search?: string, packageCode?: string, vspId?: UUID, sort?: SortObject): Promise<PagedResults<BenchmarkExtended>> {
    if (pageNumber) {
      await Int32.parse(pageNumber);
    }
    if (pageSize) {
      await Int32.parse(pageSize);
    }
    const bag = new PagedResults<BenchmarkExtended>();
    bag.pageNumber = pageNumber;
    bag.pageSize = pageSize;
    await this.producer.list(bag, status, search, packageCode, vspId, sort);
    if (bag.items === null || bag.items === undefined) {
      throw new UnexpectedError("Producers must return 'items' for PagedResults queries");
    }
    return bag;
  }
}

/**
 * Wrap producer with mapping implementation
 */
export function wrapBenchmarkProducer(producer: BenchmarkProducerApi): BenchmarkApi {
  return new BenchmarkApiMappingImpl(producer);
}

/**
 * BenchmarkApiHttpImpl - Direct HTTP implementation
 *
 * Makes direct HTTP calls to the API using Axios.
 * Used by SDK clients for platform service access.
 */
export class BenchmarkApiHttpImpl implements BenchmarkProducerApi {
  private client: AxiosInstance;
  private headers: Record<string, string>;

  constructor(client: AxiosInstance, headers: Record<string, string> = {}) {
    this.client = client;
    this.headers = headers;
  }

  async browseBenchmarkBaselineElement(benchmarkCode: string, baselineCode: string, elementCode: string): Promise<BaselineElementExtended> {
  const _queryParams = {
      
  };
  const _bodyParams = {
      
  };
  let _path = '/benchmarkBrowser/{benchmarkCode}/{baselineCode}/{elementCode}';
  _path = _path.replace('{benchmarkCode}', encodeURIComponent(String(benchmarkCode)));
  _path = _path.replace('{baselineCode}', encodeURIComponent(String(baselineCode)));
  _path = _path.replace('{elementCode}', encodeURIComponent(String(elementCode)));
  return this.client.get(
    _path,
    { params: _queryParams })
    .then((response) => {
      // BaseApiClient uses validateStatus: () => true, so we must check status manually
      if (response.status >= 400) {
        throw CoreError.deserialize(response.data);
      }
      return ObjectSerializer.deserialize(response.data, 'BaselineElementExtended')
    })
    .catch((error) => {
      if (error.data) {
        throw CoreError.deserialize(error.data);
      } else {
        throw error;
      }
    });
  }
  async browseBenchmarkBaselineElements(results: PagedResults<BaselineElementExtended>, benchmarkCode: string, baselineCode: string): Promise<void> {
  const _body = {
      benchmarkCode,baselineCode,
  };
  let _path = '/benchmarkBrowser/{benchmarkCode}/{baselineCode}';
  _path = _path.replace('{benchmarkCode}', encodeURIComponent(String(benchmarkCode)));
  _path = _path.replace('{baselineCode}', encodeURIComponent(String(baselineCode)));
  return this.client.get(
    _path,
    {
      params: {
        ..._body,
        pageNumber: results.pageNumber,
        pageSize: results.pageSize,
      }
    })
    .then((response) => {
      // BaseApiClient uses validateStatus: () => true, so we must check status manually
      if (response.status >= 400) {
        throw CoreError.deserialize(response.data);
      }
      results.items = ObjectSerializer.deserialize(response.data, 'Array<BaselineElementExtended>');
      results.count = response.headers.count ? Number(response.headers.count) : -1;
      results.pageToken = response.headers.pagetoken ?? response.headers.pageToken;
      results.headers = this.headers;
      results.baseUrl = new URL(`${this.client.getUri()}/benchmarkBrowser/{benchmarkCode}/{baselineCode}`);
      results.httpMethod = HttpMethod.Get;
      results.body = _body;
      results.mapper = (obj) => ObjectSerializer.deserialize(obj, 'BaselineElementExtended');
    })
    .catch((error) => {
      if (error.data) {
        throw CoreError.deserialize(error.data);
      } else {
        throw error;
      }
    });
  }
  async browseBenchmarkBaselines(results: PagedResults<BaselineExtended>, benchmarkCode: string): Promise<void> {
  const _body = {
      benchmarkCode,
  };
  let _path = '/benchmarkBrowser/{benchmarkCode}';
  _path = _path.replace('{benchmarkCode}', encodeURIComponent(String(benchmarkCode)));
  return this.client.get(
    _path,
    {
      params: {
        ..._body,
        pageNumber: results.pageNumber,
        pageSize: results.pageSize,
      }
    })
    .then((response) => {
      // BaseApiClient uses validateStatus: () => true, so we must check status manually
      if (response.status >= 400) {
        throw CoreError.deserialize(response.data);
      }
      results.items = ObjectSerializer.deserialize(response.data, 'Array<BaselineExtended>');
      results.count = response.headers.count ? Number(response.headers.count) : -1;
      results.pageToken = response.headers.pagetoken ?? response.headers.pageToken;
      results.headers = this.headers;
      results.baseUrl = new URL(`${this.client.getUri()}/benchmarkBrowser/{benchmarkCode}`);
      results.httpMethod = HttpMethod.Get;
      results.body = _body;
      results.mapper = (obj) => ObjectSerializer.deserialize(obj, 'BaselineExtended');
    })
    .catch((error) => {
      if (error.data) {
        throw CoreError.deserialize(error.data);
      } else {
        throw error;
      }
    });
  }
  async browseBenchmarks(results: PagedResults<BenchmarkExtended>): Promise<void> {
  const _body = {
      
  };
  let _path = '/benchmarkBrowser';
  return this.client.get(
    _path,
    {
      params: {
        ..._body,
        pageNumber: results.pageNumber,
        pageSize: results.pageSize,
      }
    })
    .then((response) => {
      // BaseApiClient uses validateStatus: () => true, so we must check status manually
      if (response.status >= 400) {
        throw CoreError.deserialize(response.data);
      }
      results.items = ObjectSerializer.deserialize(response.data, 'Array<BenchmarkExtended>');
      results.count = response.headers.count ? Number(response.headers.count) : -1;
      results.pageToken = response.headers.pagetoken ?? response.headers.pageToken;
      results.headers = this.headers;
      results.baseUrl = new URL(`${this.client.getUri()}/benchmarkBrowser`);
      results.httpMethod = HttpMethod.Get;
      results.body = _body;
      results.mapper = (obj) => ObjectSerializer.deserialize(obj, 'BenchmarkExtended');
    })
    .catch((error) => {
      if (error.data) {
        throw CoreError.deserialize(error.data);
      } else {
        throw error;
      }
    });
  }
  async get(benchmarkId: UUID): Promise<BenchmarkExtended> {
  const _queryParams = {
      
  };
  const _bodyParams = {
      
  };
  let _path = '/benchmarks/{benchmarkId}';
  _path = _path.replace('{benchmarkId}', encodeURIComponent(String(benchmarkId)));
  return this.client.get(
    _path,
    { params: _queryParams })
    .then((response) => {
      // BaseApiClient uses validateStatus: () => true, so we must check status manually
      if (response.status >= 400) {
        throw CoreError.deserialize(response.data);
      }
      return ObjectSerializer.deserialize(response.data, 'BenchmarkExtended')
    })
    .catch((error) => {
      if (error.data) {
        throw CoreError.deserialize(error.data);
      } else {
        throw error;
      }
    });
  }
  async getBaseline(benchmarkId: UUID, baselineId: UUID): Promise<BaselineExtended> {
  const _queryParams = {
      
  };
  const _bodyParams = {
      
  };
  let _path = '/benchmarks/{benchmarkId}/baselines/{baselineId}';
  _path = _path.replace('{benchmarkId}', encodeURIComponent(String(benchmarkId)));
  _path = _path.replace('{baselineId}', encodeURIComponent(String(baselineId)));
  return this.client.get(
    _path,
    { params: _queryParams })
    .then((response) => {
      // BaseApiClient uses validateStatus: () => true, so we must check status manually
      if (response.status >= 400) {
        throw CoreError.deserialize(response.data);
      }
      return ObjectSerializer.deserialize(response.data, 'BaselineExtended')
    })
    .catch((error) => {
      if (error.data) {
        throw CoreError.deserialize(error.data);
      } else {
        throw error;
      }
    });
  }
  async getBaselineElement(benchmarkId: UUID, baselineId: UUID, elementId: UUID): Promise<BaselineBenchmarkElementExtended> {
  const _queryParams = {
      
  };
  const _bodyParams = {
      
  };
  let _path = '/benchmarks/{benchmarkId}/baselines/{baselineId}/elements/{elementId}';
  _path = _path.replace('{benchmarkId}', encodeURIComponent(String(benchmarkId)));
  _path = _path.replace('{baselineId}', encodeURIComponent(String(baselineId)));
  _path = _path.replace('{elementId}', encodeURIComponent(String(elementId)));
  return this.client.get(
    _path,
    { params: _queryParams })
    .then((response) => {
      // BaseApiClient uses validateStatus: () => true, so we must check status manually
      if (response.status >= 400) {
        throw CoreError.deserialize(response.data);
      }
      return ObjectSerializer.deserialize(response.data, 'BaselineBenchmarkElementExtended')
    })
    .catch((error) => {
      if (error.data) {
        throw CoreError.deserialize(error.data);
      } else {
        throw error;
      }
    });
  }
  async getElement(benchmarkId: UUID, elementId: UUID): Promise<BenchmarkElementExtended> {
  const _queryParams = {
      
  };
  const _bodyParams = {
      
  };
  let _path = '/benchmarks/{benchmarkId}/elements/{elementId}';
  _path = _path.replace('{benchmarkId}', encodeURIComponent(String(benchmarkId)));
  _path = _path.replace('{elementId}', encodeURIComponent(String(elementId)));
  return this.client.get(
    _path,
    { params: _queryParams })
    .then((response) => {
      // BaseApiClient uses validateStatus: () => true, so we must check status manually
      if (response.status >= 400) {
        throw CoreError.deserialize(response.data);
      }
      return ObjectSerializer.deserialize(response.data, 'BenchmarkElementExtended')
    })
    .catch((error) => {
      if (error.data) {
        throw CoreError.deserialize(error.data);
      } else {
        throw error;
      }
    });
  }
  async getTestCase(benchmarkId: UUID, testCaseId: UUID): Promise<TestCaseExtended> {
  const _queryParams = {
      
  };
  const _bodyParams = {
      
  };
  let _path = '/benchmarks/{benchmarkId}/testCases/{testCaseId}';
  _path = _path.replace('{benchmarkId}', encodeURIComponent(String(benchmarkId)));
  _path = _path.replace('{testCaseId}', encodeURIComponent(String(testCaseId)));
  return this.client.get(
    _path,
    { params: _queryParams })
    .then((response) => {
      // BaseApiClient uses validateStatus: () => true, so we must check status manually
      if (response.status >= 400) {
        throw CoreError.deserialize(response.data);
      }
      return ObjectSerializer.deserialize(response.data, 'TestCaseExtended')
    })
    .catch((error) => {
      if (error.data) {
        throw CoreError.deserialize(error.data);
      } else {
        throw error;
      }
    });
  }
  async listBaselineElements(results: PagedResults<BaselineBenchmarkElementExtended>, benchmarkId: UUID, baselineId: UUID, elementTypeId?: UUID, search?: string, sort?: SortObject): Promise<void> {
  const _body = {
      benchmarkId,baselineId,elementTypeId,search,sort,
  };
  let _path = '/benchmarks/{benchmarkId}/baselines/{baselineId}/elements';
  _path = _path.replace('{benchmarkId}', encodeURIComponent(String(benchmarkId)));
  _path = _path.replace('{baselineId}', encodeURIComponent(String(baselineId)));
  return this.client.get(
    _path,
    {
      params: {
        ..._body,
        pageNumber: results.pageNumber,
        pageSize: results.pageSize,
      }
    })
    .then((response) => {
      // BaseApiClient uses validateStatus: () => true, so we must check status manually
      if (response.status >= 400) {
        throw CoreError.deserialize(response.data);
      }
      results.items = ObjectSerializer.deserialize(response.data, 'Array<BaselineBenchmarkElementExtended>');
      results.count = response.headers.count ? Number(response.headers.count) : -1;
      results.pageToken = response.headers.pagetoken ?? response.headers.pageToken;
      results.headers = this.headers;
      results.baseUrl = new URL(`${this.client.getUri()}/benchmarks/{benchmarkId}/baselines/{baselineId}/elements`);
      results.httpMethod = HttpMethod.Get;
      results.body = _body;
      results.mapper = (obj) => ObjectSerializer.deserialize(obj, 'BaselineBenchmarkElementExtended');
    })
    .catch((error) => {
      if (error.data) {
        throw CoreError.deserialize(error.data);
      } else {
        throw error;
      }
    });
  }
  async listBaselines(results: PagedResults<BaselineExtended>, benchmarkId: UUID, search?: string, sort?: SortObject): Promise<void> {
  const _body = {
      benchmarkId,search,sort,
  };
  let _path = '/benchmarks/{benchmarkId}/baselines';
  _path = _path.replace('{benchmarkId}', encodeURIComponent(String(benchmarkId)));
  return this.client.get(
    _path,
    {
      params: {
        ..._body,
        pageNumber: results.pageNumber,
        pageSize: results.pageSize,
      }
    })
    .then((response) => {
      // BaseApiClient uses validateStatus: () => true, so we must check status manually
      if (response.status >= 400) {
        throw CoreError.deserialize(response.data);
      }
      results.items = ObjectSerializer.deserialize(response.data, 'Array<BaselineExtended>');
      results.count = response.headers.count ? Number(response.headers.count) : -1;
      results.pageToken = response.headers.pagetoken ?? response.headers.pageToken;
      results.headers = this.headers;
      results.baseUrl = new URL(`${this.client.getUri()}/benchmarks/{benchmarkId}/baselines`);
      results.httpMethod = HttpMethod.Get;
      results.body = _body;
      results.mapper = (obj) => ObjectSerializer.deserialize(obj, 'BaselineExtended');
    })
    .catch((error) => {
      if (error.data) {
        throw CoreError.deserialize(error.data);
      } else {
        throw error;
      }
    });
  }
  async listElements(results: PagedResults<BenchmarkElementExtended>, benchmarkId: UUID, elementTypeId?: UUID, search?: string, packageCode?: string, severity?: SeverityDef, sort?: SortObject): Promise<void> {
  const _body = {
      benchmarkId,elementTypeId,search,packageCode,severity,sort,
  };
  let _path = '/benchmarks/{benchmarkId}/elements';
  _path = _path.replace('{benchmarkId}', encodeURIComponent(String(benchmarkId)));
  return this.client.get(
    _path,
    {
      params: {
        ..._body,
        pageNumber: results.pageNumber,
        pageSize: results.pageSize,
      }
    })
    .then((response) => {
      // BaseApiClient uses validateStatus: () => true, so we must check status manually
      if (response.status >= 400) {
        throw CoreError.deserialize(response.data);
      }
      results.items = ObjectSerializer.deserialize(response.data, 'Array<BenchmarkElementExtended>');
      results.count = response.headers.count ? Number(response.headers.count) : -1;
      results.pageToken = response.headers.pagetoken ?? response.headers.pageToken;
      results.headers = this.headers;
      results.baseUrl = new URL(`${this.client.getUri()}/benchmarks/{benchmarkId}/elements`);
      results.httpMethod = HttpMethod.Get;
      results.body = _body;
      results.mapper = (obj) => ObjectSerializer.deserialize(obj, 'BenchmarkElementExtended');
    })
    .catch((error) => {
      if (error.data) {
        throw CoreError.deserialize(error.data);
      } else {
        throw error;
      }
    });
  }
  async listTestCases(results: PagedResults<TestCaseExtended>, benchmarkId: UUID, search?: string, sort?: SortObject): Promise<void> {
  const _body = {
      benchmarkId,search,sort,
  };
  let _path = '/benchmarks/{benchmarkId}/testCases';
  _path = _path.replace('{benchmarkId}', encodeURIComponent(String(benchmarkId)));
  return this.client.get(
    _path,
    {
      params: {
        ..._body,
        pageNumber: results.pageNumber,
        pageSize: results.pageSize,
      }
    })
    .then((response) => {
      // BaseApiClient uses validateStatus: () => true, so we must check status manually
      if (response.status >= 400) {
        throw CoreError.deserialize(response.data);
      }
      results.items = ObjectSerializer.deserialize(response.data, 'Array<TestCaseExtended>');
      results.count = response.headers.count ? Number(response.headers.count) : -1;
      results.pageToken = response.headers.pagetoken ?? response.headers.pageToken;
      results.headers = this.headers;
      results.baseUrl = new URL(`${this.client.getUri()}/benchmarks/{benchmarkId}/testCases`);
      results.httpMethod = HttpMethod.Get;
      results.body = _body;
      results.mapper = (obj) => ObjectSerializer.deserialize(obj, 'TestCaseExtended');
    })
    .catch((error) => {
      if (error.data) {
        throw CoreError.deserialize(error.data);
      } else {
        throw error;
      }
    });
  }
  async list(results: PagedResults<BenchmarkExtended>, status?: StandardStatusDef, search?: string, packageCode?: string, vspId?: UUID, sort?: SortObject): Promise<void> {
  const _body = {
      status,search,packageCode,vspId,sort,
  };
  let _path = '/benchmarks';
  return this.client.get(
    _path,
    {
      params: {
        ..._body,
        pageNumber: results.pageNumber,
        pageSize: results.pageSize,
      }
    })
    .then((response) => {
      // BaseApiClient uses validateStatus: () => true, so we must check status manually
      if (response.status >= 400) {
        throw CoreError.deserialize(response.data);
      }
      results.items = ObjectSerializer.deserialize(response.data, 'Array<BenchmarkExtended>');
      results.count = response.headers.count ? Number(response.headers.count) : -1;
      results.pageToken = response.headers.pagetoken ?? response.headers.pageToken;
      results.headers = this.headers;
      results.baseUrl = new URL(`${this.client.getUri()}/benchmarks`);
      results.httpMethod = HttpMethod.Get;
      results.body = _body;
      results.mapper = (obj) => ObjectSerializer.deserialize(obj, 'BenchmarkExtended');
    })
    .catch((error) => {
      if (error.data) {
        throw CoreError.deserialize(error.data);
      } else {
        throw error;
      }
    });
  }
}
