/* eslint-disable */
// ===============================================
// This file is autogenerated - Please do not edit
// ===============================================
import { AxiosInstance } from 'axios';
import { EvidenceDefinitionFrameworkElementLink, EvidenceDefinitionScfLinkRequiredDef, EvidenceDefinitionScfLinkScopeDef, ExtendedFrameworkVersion, FrameworkElementType, FrameworkVersion, OldFramework, OldFrameworkElement, OldFrameworkElementExtended, ScfControl, ScfDomain, ScfDomainExtended, ScfSearchResult, ScfSearchTypeDef, SortObject } from '../model/index.js';
import { URL, EnumValue, IllegalArgumentError, PagedResults, Int32, UUID, CoreError, ParameterRequiredError, UnexpectedError, HttpMethod } from '@zerobias-org/types-core-js';
import { RequestFile, ObjectSerializer } from '../model/index.js';

export namespace FrameworkApi {
}

/**
 * FrameworkApi - interface
 * @export
 * @interface FrameworkApi
 */
export interface FrameworkApi {
  /**
   * Retrieves a framework info
   * @summary Retrieves a framework info
   * @param {UUID} frameworkId 
   * @param {*} [options] Override http request option.
   * @throws {@link @zerobias-org/types-core-js#ParameterRequiredError} if any required parameter is not provided
   * @example
   * ```typescript
   * const result = await api.getFramework('00000000-0000-0000-0000-000000000000');
   * ```
   * @openapi operation=getFramework path=/catalog/frameworks/{frameworkId} method=GET
   * @memberof FrameworkApi
   */
  getFramework(frameworkId: UUID): Promise<OldFramework>;

  /**
   * Retrieves a framework version info
   * @summary Retrieves a framework version info
   * @param {UUID} frameworkId 
   * @param {UUID} versionId 
   * @param {UUID} elementId 
   * @param {*} [options] Override http request option.
   * @throws {@link @zerobias-org/types-core-js#ParameterRequiredError} if any required parameter is not provided
   * @example
   * ```typescript
   * const result = await api.getFrameworkElement('00000000-0000-0000-0000-000000000000', '00000000-0000-0000-0000-000000000000', '00000000-0000-0000-0000-000000000000');
   * ```
   * @openapi operation=getFrameworkElement path=/catalog/frameworks/{frameworkId}/versions/{versionId}/elements/{elementId} method=GET
   * @memberof FrameworkApi
   */
  getFrameworkElement(frameworkId: UUID, versionId: UUID, elementId: UUID): Promise<OldFrameworkElement>;

  /**
   * Retrieves a framework element by code
   * @summary Retrieves a framework element by code
   * @param {string} frameworkCode 
   * @param {string} frameworkVersionCode 
   * @param {string} frameworkElementCode 
   * @param {*} [options] Override http request option.
   * @throws {@link @zerobias-org/types-core-js#ParameterRequiredError} if any required parameter is not provided
   * @example
   * ```typescript
   * const result = await api.getFrameworkElementByCode('frameworkCode', 'frameworkVersionCode', 'frameworkElementCode');
   * ```
   * @openapi operation=getFrameworkElementByCode path=/catalog/browserFrameworks/{frameworkCode}/{frameworkVersionCode}/{frameworkElementCode} method=GET
   * @memberof FrameworkApi
   */
  getFrameworkElementByCode(frameworkCode: string, frameworkVersionCode: string, frameworkElementCode: string): Promise<OldFrameworkElement>;

  /**
   * Retrieves a framework element info
   * @summary Retrieves a framework element info
   * @param {UUID} id 
   * @param {*} [options] Override http request option.
   * @throws {@link @zerobias-org/types-core-js#ParameterRequiredError} if any required parameter is not provided
   * @example
   * ```typescript
   * const result = await api.getFrameworkElementInfo('00000000-0000-0000-0000-000000000000');
   * ```
   * @openapi operation=getFrameworkElementInfo path=/catalog/frameworkElements/{id} method=GET
   * @memberof FrameworkApi
   */
  getFrameworkElementInfo(id: UUID): Promise<OldFrameworkElement>;

  /**
   * Retrieves a framework version info
   * @summary Retrieves a framework version info
   * @param {UUID} frameworkId 
   * @param {UUID} versionId 
   * @param {*} [options] Override http request option.
   * @throws {@link @zerobias-org/types-core-js#ParameterRequiredError} if any required parameter is not provided
   * @example
   * ```typescript
   * const result = await api.getFrameworkVersion('00000000-0000-0000-0000-000000000000', '00000000-0000-0000-0000-000000000000');
   * ```
   * @openapi operation=getFrameworkVersion path=/catalog/frameworks/{frameworkId}/versions/{versionId} method=GET
   * @memberof FrameworkApi
   */
  getFrameworkVersion(frameworkId: UUID, versionId: UUID): Promise<FrameworkVersion & ExtendedFrameworkVersion>;

  /**
   * Retrieves a Scf control info
   * @summary Retrieves a Scf control info
   * @param {UUID} id 
   * @param {*} [options] Override http request option.
   * @throws {@link @zerobias-org/types-core-js#ParameterRequiredError} if any required parameter is not provided
   * @example
   * ```typescript
   * const result = await api.getScfControl('00000000-0000-0000-0000-000000000000');
   * ```
   * @openapi operation=getScfControl path=/catalog/scfControls/{id} method=GET
   * @memberof FrameworkApi
   */
  getScfControl(id: UUID): Promise<ScfControl>;

  /**
   * Retrieves a Scf Domain by code
   * @summary Retrieves a Scf Domain by code
   * @param {string} domainCode 
   * @param {*} [options] Override http request option.
   * @throws {@link @zerobias-org/types-core-js#ParameterRequiredError} if any required parameter is not provided
   * @example
   * ```typescript
   * const result = await api.getScfDomain('domainCode');
   * ```
   * @openapi operation=getScfDomain path=/catalog/scfDomains/{domainCode} method=GET
   * @memberof FrameworkApi
   */
  getScfDomain(domainCode: string): Promise<ScfDomainExtended>;

  /**
   * Retrieves a list of all frameworks
   * @summary Retrieves a list of all frameworks
   * @param {number} [pageNumber] The requested page. This value is 1-indexed.
   * @param {number} [pageSize] The number of items in each page of data.
   * @param {*} [options] Override http request option.
   * @throws {@link @zerobias-org/types-core-js#ParameterRequiredError} if any required parameter is not provided
   * @example
   * ```typescript
   * const result = await api.listBrowserFrameworks(1, 1);
   * ```
   * @openapi operation=listBrowserFrameworks path=/catalog/browserFrameworks method=GET
   * @memberof FrameworkApi
   */
  listBrowserFrameworks(pageNumber?: number, pageSize?: number): Promise<PagedResults<OldFramework>>;

  /**
   * List evidence definitions that link to given framework element
   * @summary List evidence definitions that link to given framework element
   * @param {UUID} id 
   * @param {number} [pageNumber] The requested page. This value is 1-indexed.
   * @param {number} [pageSize] The number of items in each page of data.
   * @param {EvidenceDefinitionScfLinkScope} [scope] Filter by scope
   * @param {EvidenceDefinitionScfLinkRequired} [required] Filter by required
   * @param {SortObject} [sort] Sort object
   * @param {*} [options] Override http request option.
   * @throws {@link @zerobias-org/types-core-js#ParameterRequiredError} if any required parameter is not provided
   * @example
   * ```typescript
   * const result = await api.listEvidenceDefinitionByFrameworkElementId('00000000-0000-0000-0000-000000000000', 1, 1, null, null, null);
   * ```
   * @openapi operation=listEvidenceDefinitionByFrameworkElementId path=/catalog/frameworkElements/{id}/evidenceDefinitions method=GET
   * @memberof FrameworkApi
   */
  listEvidenceDefinitionByFrameworkElementId(id: UUID, pageNumber?: number, pageSize?: number, scope?: EvidenceDefinitionScfLinkScopeDef, required?: EvidenceDefinitionScfLinkRequiredDef, sort?: SortObject): Promise<PagedResults<EvidenceDefinitionFrameworkElementLink>>;

  /**
   * Retrieves a list of a framework element types
   * @summary Retrieves a list of a framework element types
   * @param {UUID} frameworkId 
   * @param {number} [pageNumber] The requested page. This value is 1-indexed.
   * @param {number} [pageSize] The number of items in each page of data.
   * @param {*} [options] Override http request option.
   * @throws {@link @zerobias-org/types-core-js#ParameterRequiredError} if any required parameter is not provided
   * @example
   * ```typescript
   * const result = await api.listFrameworkElementTypes('00000000-0000-0000-0000-000000000000', 1, 1);
   * ```
   * @openapi operation=listFrameworkElementTypes path=/catalog/frameworks/{frameworkId}/elementTypes method=GET
   * @memberof FrameworkApi
   */
  listFrameworkElementTypes(frameworkId: UUID, pageNumber?: number, pageSize?: number): Promise<PagedResults<FrameworkElementType>>;

  /**
   * Retrieves a list of a framework version elements
   * @summary Retrieves a list of a framework version elements
   * @param {UUID} frameworkId 
   * @param {UUID} versionId 
   * @param {number} [pageNumber] The requested page. This value is 1-indexed.
   * @param {number} [pageSize] The number of items in each page of data.
   * @param {string} [type] Filter used to get an entire level
   * @param {string} [keywords] Filter using keywords
   * @param {SortObject} [sort] Sort object
   * @param {*} [options] Override http request option.
   * @throws {@link @zerobias-org/types-core-js#ParameterRequiredError} if any required parameter is not provided
   * @example
   * ```typescript
   * const result = await api.listFrameworkElements('00000000-0000-0000-0000-000000000000', '00000000-0000-0000-0000-000000000000', 1, 1, 'type', 'keywords', null);
   * ```
   * @openapi operation=listFrameworkElements path=/catalog/frameworks/{frameworkId}/versions/{versionId}/elements method=GET
   * @memberof FrameworkApi
   */
  listFrameworkElements(frameworkId: UUID, versionId: UUID, pageNumber?: number, pageSize?: number, type?: string, keywords?: string, sort?: SortObject): Promise<PagedResults<OldFrameworkElement & OldFrameworkElementExtended>>;

  /**
   * Retrieves a list of framework versions
   * @summary Retrieves a list of framework versions
   * @param {string} frameworkCode 
   * @param {string} frameworkVersionCode 
   * @param {number} [pageNumber] The requested page. This value is 1-indexed.
   * @param {number} [pageSize] The number of items in each page of data.
   * @param {*} [options] Override http request option.
   * @throws {@link @zerobias-org/types-core-js#ParameterRequiredError} if any required parameter is not provided
   * @example
   * ```typescript
   * const result = await api.listFrameworkElementsByCode('frameworkCode', 'frameworkVersionCode', 1, 1);
   * ```
   * @openapi operation=listFrameworkElementsByCode path=/catalog/browserFrameworks/{frameworkCode}/{frameworkVersionCode} method=GET
   * @memberof FrameworkApi
   */
  listFrameworkElementsByCode(frameworkCode: string, frameworkVersionCode: string, pageNumber?: number, pageSize?: number): Promise<PagedResults<OldFrameworkElement & OldFrameworkElementExtended>>;

  /**
   * Retrieves a list of a framework versions
   * @summary Retrieves a list of a framework versions
   * @param {UUID} frameworkId 
   * @param {number} [pageNumber] The requested page. This value is 1-indexed.
   * @param {number} [pageSize] The number of items in each page of data.
   * @param {*} [options] Override http request option.
   * @throws {@link @zerobias-org/types-core-js#ParameterRequiredError} if any required parameter is not provided
   * @example
   * ```typescript
   * const result = await api.listFrameworkVersions('00000000-0000-0000-0000-000000000000', 1, 1);
   * ```
   * @openapi operation=listFrameworkVersions path=/catalog/frameworks/{frameworkId}/versions method=GET
   * @memberof FrameworkApi
   */
  listFrameworkVersions(frameworkId: UUID, pageNumber?: number, pageSize?: number): Promise<PagedResults<FrameworkVersion>>;

  /**
   * Retrieves a list of framework versions
   * @summary Retrieves a list of framework versions
   * @param {string} frameworkCode 
   * @param {number} [pageNumber] The requested page. This value is 1-indexed.
   * @param {number} [pageSize] The number of items in each page of data.
   * @param {*} [options] Override http request option.
   * @throws {@link @zerobias-org/types-core-js#ParameterRequiredError} if any required parameter is not provided
   * @example
   * ```typescript
   * const result = await api.listFrameworkVersionsByCode('frameworkCode', 1, 1);
   * ```
   * @openapi operation=listFrameworkVersionsByCode path=/catalog/browserFrameworks/{frameworkCode} method=GET
   * @memberof FrameworkApi
   */
  listFrameworkVersionsByCode(frameworkCode: string, pageNumber?: number, pageSize?: number): Promise<PagedResults<FrameworkVersion>>;

  /**
   * Retrieves a list of all frameworks
   * @summary Retrieves a list of all frameworks
   * @param {number} [pageNumber] The requested page. This value is 1-indexed.
   * @param {number} [pageSize] The number of items in each page of data.
   * @param {*} [options] Override http request option.
   * @throws {@link @zerobias-org/types-core-js#ParameterRequiredError} if any required parameter is not provided
   * @example
   * ```typescript
   * const result = await api.listFrameworks(1, 1);
   * ```
   * @openapi operation=listFrameworks path=/catalog/frameworks method=GET
   * @memberof FrameworkApi
   */
  listFrameworks(pageNumber?: number, pageSize?: number): Promise<PagedResults<OldFramework>>;

  /**
   * Retrieves a list of all Scf controls
   * @summary Retrieves a list of all Scf controls
   * @param {number} [pageNumber] The requested page. This value is 1-indexed.
   * @param {number} [pageSize] The number of items in each page of data.
   * @param {*} [options] Override http request option.
   * @throws {@link @zerobias-org/types-core-js#ParameterRequiredError} if any required parameter is not provided
   * @example
   * ```typescript
   * const result = await api.listScfControls(1, 1);
   * ```
   * @openapi operation=listScfControls path=/catalog/scfControls method=GET
   * @memberof FrameworkApi
   */
  listScfControls(pageNumber?: number, pageSize?: number): Promise<PagedResults<ScfControl>>;

  /**
   * Retrieves a list of Scf domains
   * @summary Retrieves a list of Scf domains
   * @param {number} [pageNumber] The requested page. This value is 1-indexed.
   * @param {number} [pageSize] The number of items in each page of data.
   * @param {*} [options] Override http request option.
   * @throws {@link @zerobias-org/types-core-js#ParameterRequiredError} if any required parameter is not provided
   * @example
   * ```typescript
   * const result = await api.listScfDomains(1, 1);
   * ```
   * @openapi operation=listScfDomains path=/catalog/scfDomains method=GET
   * @memberof FrameworkApi
   */
  listScfDomains(pageNumber?: number, pageSize?: number): Promise<PagedResults<ScfDomain>>;

  /**
   * Retrieves list of scf domains/controls/assertions searched by text
   * @summary Retrieves list of scf domains/controls/assertions searched by text
   * @param {string} search 
   * @param {number} [pageNumber] The requested page. This value is 1-indexed.
   * @param {number} [pageSize] The number of items in each page of data.
   * @param {ScfSearchType} [scfType] 
   * @param {SortObject} [sort] Sort object
   * @param {*} [options] Override http request option.
   * @throws {@link @zerobias-org/types-core-js#ParameterRequiredError} if any required parameter is not provided
   * @example
   * ```typescript
   * const result = await api.scfSearch('search', 1, 1, null, null);
   * ```
   * @openapi operation=scfSearch path=/catalog/scfSearches method=GET
   * @memberof FrameworkApi
   */
  scfSearch(search: string, pageNumber?: number, pageSize?: number, scfType?: ScfSearchTypeDef, sort?: SortObject): Promise<PagedResults<ScfSearchResult>>;

}

/**
 * FrameworkProducerApi - interface
 * Producer interface for Framework
 * @export
 * @interface FrameworkProducerApi
 */
export interface FrameworkProducerApi {
  /**
  * Retrieves a framework info
  * @summary Retrieves a framework info
  * @param {UUID} frameworkId 
  * @param {*} [options] Override http request option.
  * @throws {@link @zerobias-org/types-core-js#ParameterRequiredError} if any required parameter is not provided
  * @openapi operation=getFramework path=/catalog/frameworks/{frameworkId} method=GET
  * @memberof Framework
  */
  getFramework(frameworkId: UUID): Promise<OldFramework>;
  /**
  * Retrieves a framework version info
  * @summary Retrieves a framework version info
  * @param {UUID} frameworkId 
  * @param {UUID} versionId 
  * @param {UUID} elementId 
  * @param {*} [options] Override http request option.
  * @throws {@link @zerobias-org/types-core-js#ParameterRequiredError} if any required parameter is not provided
  * @openapi operation=getFrameworkElement path=/catalog/frameworks/{frameworkId}/versions/{versionId}/elements/{elementId} method=GET
  * @memberof Framework
  */
  getFrameworkElement(frameworkId: UUID, versionId: UUID, elementId: UUID): Promise<OldFrameworkElement>;
  /**
  * Retrieves a framework element by code
  * @summary Retrieves a framework element by code
  * @param {string} frameworkCode 
  * @param {string} frameworkVersionCode 
  * @param {string} frameworkElementCode 
  * @param {*} [options] Override http request option.
  * @throws {@link @zerobias-org/types-core-js#ParameterRequiredError} if any required parameter is not provided
  * @openapi operation=getFrameworkElementByCode path=/catalog/browserFrameworks/{frameworkCode}/{frameworkVersionCode}/{frameworkElementCode} method=GET
  * @memberof Framework
  */
  getFrameworkElementByCode(frameworkCode: string, frameworkVersionCode: string, frameworkElementCode: string): Promise<OldFrameworkElement>;
  /**
  * Retrieves a framework element info
  * @summary Retrieves a framework element info
  * @param {UUID} id 
  * @param {*} [options] Override http request option.
  * @throws {@link @zerobias-org/types-core-js#ParameterRequiredError} if any required parameter is not provided
  * @openapi operation=getFrameworkElementInfo path=/catalog/frameworkElements/{id} method=GET
  * @memberof Framework
  */
  getFrameworkElementInfo(id: UUID): Promise<OldFrameworkElement>;
  /**
  * Retrieves a framework version info
  * @summary Retrieves a framework version info
  * @param {UUID} frameworkId 
  * @param {UUID} versionId 
  * @param {*} [options] Override http request option.
  * @throws {@link @zerobias-org/types-core-js#ParameterRequiredError} if any required parameter is not provided
  * @openapi operation=getFrameworkVersion path=/catalog/frameworks/{frameworkId}/versions/{versionId} method=GET
  * @memberof Framework
  */
  getFrameworkVersion(frameworkId: UUID, versionId: UUID): Promise<FrameworkVersion & ExtendedFrameworkVersion>;
  /**
  * Retrieves a Scf control info
  * @summary Retrieves a Scf control info
  * @param {UUID} id 
  * @param {*} [options] Override http request option.
  * @throws {@link @zerobias-org/types-core-js#ParameterRequiredError} if any required parameter is not provided
  * @openapi operation=getScfControl path=/catalog/scfControls/{id} method=GET
  * @memberof Framework
  */
  getScfControl(id: UUID): Promise<ScfControl>;
  /**
  * Retrieves a Scf Domain by code
  * @summary Retrieves a Scf Domain by code
  * @param {string} domainCode 
  * @param {*} [options] Override http request option.
  * @throws {@link @zerobias-org/types-core-js#ParameterRequiredError} if any required parameter is not provided
  * @openapi operation=getScfDomain path=/catalog/scfDomains/{domainCode} method=GET
  * @memberof Framework
  */
  getScfDomain(domainCode: string): Promise<ScfDomainExtended>;
  /**
  * Retrieves a list of all frameworks
  * @summary Retrieves a list of all frameworks
  * @param {*} [options] Override http request option.
  * @throws {@link @zerobias-org/types-core-js#ParameterRequiredError} if any required parameter is not provided
  * @openapi operation=listBrowserFrameworks path=/catalog/browserFrameworks method=GET
  * @memberof Framework
  */
  listBrowserFrameworks(results: PagedResults<OldFramework>): Promise<void>;
  /**
  * List evidence definitions that link to given framework element
  * @summary List evidence definitions that link to given framework element
  * @param {UUID} id 
  * @param {EvidenceDefinitionScfLinkScope} [scope] Filter by scope
  * @param {EvidenceDefinitionScfLinkRequired} [required] Filter by required
  * @param {SortObject} [sort] Sort object
  * @param {*} [options] Override http request option.
  * @throws {@link @zerobias-org/types-core-js#ParameterRequiredError} if any required parameter is not provided
  * @openapi operation=listEvidenceDefinitionByFrameworkElementId path=/catalog/frameworkElements/{id}/evidenceDefinitions method=GET
  * @memberof Framework
  */
  listEvidenceDefinitionByFrameworkElementId(results: PagedResults<EvidenceDefinitionFrameworkElementLink>, id: UUID, scope?: EvidenceDefinitionScfLinkScopeDef, required?: EvidenceDefinitionScfLinkRequiredDef, sort?: SortObject): Promise<void>;
  /**
  * Retrieves a list of a framework element types
  * @summary Retrieves a list of a framework element types
  * @param {UUID} frameworkId 
  * @param {*} [options] Override http request option.
  * @throws {@link @zerobias-org/types-core-js#ParameterRequiredError} if any required parameter is not provided
  * @openapi operation=listFrameworkElementTypes path=/catalog/frameworks/{frameworkId}/elementTypes method=GET
  * @memberof Framework
  */
  listFrameworkElementTypes(results: PagedResults<FrameworkElementType>, frameworkId: UUID): Promise<void>;
  /**
  * Retrieves a list of a framework version elements
  * @summary Retrieves a list of a framework version elements
  * @param {UUID} frameworkId 
  * @param {UUID} versionId 
  * @param {string} [type] Filter used to get an entire level
  * @param {string} [keywords] Filter using keywords
  * @param {SortObject} [sort] Sort object
  * @param {*} [options] Override http request option.
  * @throws {@link @zerobias-org/types-core-js#ParameterRequiredError} if any required parameter is not provided
  * @openapi operation=listFrameworkElements path=/catalog/frameworks/{frameworkId}/versions/{versionId}/elements method=GET
  * @memberof Framework
  */
  listFrameworkElements(results: PagedResults<OldFrameworkElement & OldFrameworkElementExtended>, frameworkId: UUID, versionId: UUID, type?: string, keywords?: string, sort?: SortObject): Promise<void>;
  /**
  * Retrieves a list of framework versions
  * @summary Retrieves a list of framework versions
  * @param {string} frameworkCode 
  * @param {string} frameworkVersionCode 
  * @param {*} [options] Override http request option.
  * @throws {@link @zerobias-org/types-core-js#ParameterRequiredError} if any required parameter is not provided
  * @openapi operation=listFrameworkElementsByCode path=/catalog/browserFrameworks/{frameworkCode}/{frameworkVersionCode} method=GET
  * @memberof Framework
  */
  listFrameworkElementsByCode(results: PagedResults<OldFrameworkElement & OldFrameworkElementExtended>, frameworkCode: string, frameworkVersionCode: string): Promise<void>;
  /**
  * Retrieves a list of a framework versions
  * @summary Retrieves a list of a framework versions
  * @param {UUID} frameworkId 
  * @param {*} [options] Override http request option.
  * @throws {@link @zerobias-org/types-core-js#ParameterRequiredError} if any required parameter is not provided
  * @openapi operation=listFrameworkVersions path=/catalog/frameworks/{frameworkId}/versions method=GET
  * @memberof Framework
  */
  listFrameworkVersions(results: PagedResults<FrameworkVersion>, frameworkId: UUID): Promise<void>;
  /**
  * Retrieves a list of framework versions
  * @summary Retrieves a list of framework versions
  * @param {string} frameworkCode 
  * @param {*} [options] Override http request option.
  * @throws {@link @zerobias-org/types-core-js#ParameterRequiredError} if any required parameter is not provided
  * @openapi operation=listFrameworkVersionsByCode path=/catalog/browserFrameworks/{frameworkCode} method=GET
  * @memberof Framework
  */
  listFrameworkVersionsByCode(results: PagedResults<FrameworkVersion>, frameworkCode: string): Promise<void>;
  /**
  * Retrieves a list of all frameworks
  * @summary Retrieves a list of all frameworks
  * @param {*} [options] Override http request option.
  * @throws {@link @zerobias-org/types-core-js#ParameterRequiredError} if any required parameter is not provided
  * @openapi operation=listFrameworks path=/catalog/frameworks method=GET
  * @memberof Framework
  */
  listFrameworks(results: PagedResults<OldFramework>): Promise<void>;
  /**
  * Retrieves a list of all Scf controls
  * @summary Retrieves a list of all Scf controls
  * @param {*} [options] Override http request option.
  * @throws {@link @zerobias-org/types-core-js#ParameterRequiredError} if any required parameter is not provided
  * @openapi operation=listScfControls path=/catalog/scfControls method=GET
  * @memberof Framework
  */
  listScfControls(results: PagedResults<ScfControl>): Promise<void>;
  /**
  * Retrieves a list of Scf domains
  * @summary Retrieves a list of Scf domains
  * @param {*} [options] Override http request option.
  * @throws {@link @zerobias-org/types-core-js#ParameterRequiredError} if any required parameter is not provided
  * @openapi operation=listScfDomains path=/catalog/scfDomains method=GET
  * @memberof Framework
  */
  listScfDomains(results: PagedResults<ScfDomain>): Promise<void>;
  /**
  * Retrieves list of scf domains/controls/assertions searched by text
  * @summary Retrieves list of scf domains/controls/assertions searched by text
  * @param {string} search 
  * @param {ScfSearchType} [scfType] 
  * @param {SortObject} [sort] Sort object
  * @param {*} [options] Override http request option.
  * @throws {@link @zerobias-org/types-core-js#ParameterRequiredError} if any required parameter is not provided
  * @openapi operation=scfSearch path=/catalog/scfSearches method=GET
  * @memberof Framework
  */
  scfSearch(results: PagedResults<ScfSearchResult>, search: string, scfType?: ScfSearchTypeDef, sort?: SortObject): Promise<void>;
}

export class FrameworkApiMappingImpl implements FrameworkApi {
  private producer: FrameworkProducerApi;
  constructor(producer: FrameworkProducerApi) {
    this.producer = producer;
  }

  /**
   * Retrieves a framework info
   * @summary Retrieves a framework info
   * @param frameworkId 
   * @openapi operation=getFramework path=/catalog/frameworks/{frameworkId} method=GET
   */
  public async getFramework(frameworkId: UUID): Promise<OldFramework> {
    // verify required parameter 'frameworkId' is not null or undefined
    if (frameworkId === null || frameworkId === undefined) {
      throw new ParameterRequiredError('frameworkId');
    }
    return this.producer.getFramework(frameworkId);
  }
  /**
   * Retrieves a framework version info
   * @summary Retrieves a framework version info
   * @param frameworkId 
   * @param versionId 
   * @param elementId 
   * @openapi operation=getFrameworkElement path=/catalog/frameworks/{frameworkId}/versions/{versionId}/elements/{elementId} method=GET
   */
  public async getFrameworkElement(frameworkId: UUID, versionId: UUID, elementId: UUID): Promise<OldFrameworkElement> {
    // verify required parameter 'frameworkId' is not null or undefined
    if (frameworkId === null || frameworkId === undefined) {
      throw new ParameterRequiredError('frameworkId');
    }
    // verify required parameter 'versionId' is not null or undefined
    if (versionId === null || versionId === undefined) {
      throw new ParameterRequiredError('versionId');
    }
    // verify required parameter 'elementId' is not null or undefined
    if (elementId === null || elementId === undefined) {
      throw new ParameterRequiredError('elementId');
    }
    return this.producer.getFrameworkElement(frameworkId, versionId, elementId);
  }
  /**
   * Retrieves a framework element by code
   * @summary Retrieves a framework element by code
   * @param frameworkCode 
   * @param frameworkVersionCode 
   * @param frameworkElementCode 
   * @openapi operation=getFrameworkElementByCode path=/catalog/browserFrameworks/{frameworkCode}/{frameworkVersionCode}/{frameworkElementCode} method=GET
   */
  public async getFrameworkElementByCode(frameworkCode: string, frameworkVersionCode: string, frameworkElementCode: string): Promise<OldFrameworkElement> {
    // verify required parameter 'frameworkCode' is not null or undefined
    if (frameworkCode === null || frameworkCode === undefined || frameworkCode === '') {
      throw new ParameterRequiredError('frameworkCode');
    }
    // verify required parameter 'frameworkVersionCode' is not null or undefined
    if (frameworkVersionCode === null || frameworkVersionCode === undefined || frameworkVersionCode === '') {
      throw new ParameterRequiredError('frameworkVersionCode');
    }
    // verify required parameter 'frameworkElementCode' is not null or undefined
    if (frameworkElementCode === null || frameworkElementCode === undefined || frameworkElementCode === '') {
      throw new ParameterRequiredError('frameworkElementCode');
    }
    return this.producer.getFrameworkElementByCode(frameworkCode, frameworkVersionCode, frameworkElementCode);
  }
  /**
   * Retrieves a framework element info
   * @summary Retrieves a framework element info
   * @param id 
   * @openapi operation=getFrameworkElementInfo path=/catalog/frameworkElements/{id} method=GET
   */
  public async getFrameworkElementInfo(id: UUID): Promise<OldFrameworkElement> {
    // verify required parameter 'id' is not null or undefined
    if (id === null || id === undefined) {
      throw new ParameterRequiredError('id');
    }
    return this.producer.getFrameworkElementInfo(id);
  }
  /**
   * Retrieves a framework version info
   * @summary Retrieves a framework version info
   * @param frameworkId 
   * @param versionId 
   * @openapi operation=getFrameworkVersion path=/catalog/frameworks/{frameworkId}/versions/{versionId} method=GET
   */
  public async getFrameworkVersion(frameworkId: UUID, versionId: UUID): Promise<FrameworkVersion & ExtendedFrameworkVersion> {
    // verify required parameter 'frameworkId' is not null or undefined
    if (frameworkId === null || frameworkId === undefined) {
      throw new ParameterRequiredError('frameworkId');
    }
    // verify required parameter 'versionId' is not null or undefined
    if (versionId === null || versionId === undefined) {
      throw new ParameterRequiredError('versionId');
    }
    return this.producer.getFrameworkVersion(frameworkId, versionId);
  }
  /**
   * Retrieves a Scf control info
   * @summary Retrieves a Scf control info
   * @param id 
   * @openapi operation=getScfControl path=/catalog/scfControls/{id} method=GET
   */
  public async getScfControl(id: UUID): Promise<ScfControl> {
    // verify required parameter 'id' is not null or undefined
    if (id === null || id === undefined) {
      throw new ParameterRequiredError('id');
    }
    return this.producer.getScfControl(id);
  }
  /**
   * Retrieves a Scf Domain by code
   * @summary Retrieves a Scf Domain by code
   * @param domainCode 
   * @openapi operation=getScfDomain path=/catalog/scfDomains/{domainCode} method=GET
   */
  public async getScfDomain(domainCode: string): Promise<ScfDomainExtended> {
    // verify required parameter 'domainCode' is not null or undefined
    if (domainCode === null || domainCode === undefined || domainCode === '') {
      throw new ParameterRequiredError('domainCode');
    }
    return this.producer.getScfDomain(domainCode);
  }
  /**
   * Retrieves a list of all frameworks
   * @summary Retrieves a list of all frameworks
   * @param pageNumber The requested page. This value is 1-indexed.
   * @param pageSize The number of items in each page of data.
   * @openapi operation=listBrowserFrameworks path=/catalog/browserFrameworks method=GET
   */
  public async listBrowserFrameworks(pageNumber: number = 1, pageSize: number = 50): Promise<PagedResults<OldFramework>> {
    if (pageNumber) {
      await Int32.parse(pageNumber);
    }
    if (pageSize) {
      await Int32.parse(pageSize);
    }
    const bag = new PagedResults<OldFramework>();
    bag.pageNumber = pageNumber;
    bag.pageSize = pageSize;
    await this.producer.listBrowserFrameworks(bag);
    if (bag.items === null || bag.items === undefined) {
      throw new UnexpectedError("Producers must return 'items' for PagedResults queries");
    }
    return bag;
  }
  /**
   * List evidence definitions that link to given framework element
   * @summary List evidence definitions that link to given framework element
   * @param id 
   * @param pageNumber The requested page. This value is 1-indexed.
   * @param pageSize The number of items in each page of data.
   * @param scope Filter by scope
   * @param required Filter by required
   * @param sort Sort object
   * @openapi operation=listEvidenceDefinitionByFrameworkElementId path=/catalog/frameworkElements/{id}/evidenceDefinitions method=GET
   */
  public async listEvidenceDefinitionByFrameworkElementId(id: UUID, pageNumber: number = 1, pageSize: number = 50, scope?: EvidenceDefinitionScfLinkScopeDef, required?: EvidenceDefinitionScfLinkRequiredDef, sort?: SortObject): Promise<PagedResults<EvidenceDefinitionFrameworkElementLink>> {
    // verify required parameter 'id' is not null or undefined
    if (id === null || id === undefined) {
      throw new ParameterRequiredError('id');
    }
    if (pageNumber) {
      await Int32.parse(pageNumber);
    }
    if (pageSize) {
      await Int32.parse(pageSize);
    }
    const bag = new PagedResults<EvidenceDefinitionFrameworkElementLink>();
    bag.pageNumber = pageNumber;
    bag.pageSize = pageSize;
    await this.producer.listEvidenceDefinitionByFrameworkElementId(bag, id, scope, required, sort);
    if (bag.items === null || bag.items === undefined) {
      throw new UnexpectedError("Producers must return 'items' for PagedResults queries");
    }
    return bag;
  }
  /**
   * Retrieves a list of a framework element types
   * @summary Retrieves a list of a framework element types
   * @param frameworkId 
   * @param pageNumber The requested page. This value is 1-indexed.
   * @param pageSize The number of items in each page of data.
   * @openapi operation=listFrameworkElementTypes path=/catalog/frameworks/{frameworkId}/elementTypes method=GET
   */
  public async listFrameworkElementTypes(frameworkId: UUID, pageNumber: number = 1, pageSize: number = 50): Promise<PagedResults<FrameworkElementType>> {
    // verify required parameter 'frameworkId' is not null or undefined
    if (frameworkId === null || frameworkId === undefined) {
      throw new ParameterRequiredError('frameworkId');
    }
    if (pageNumber) {
      await Int32.parse(pageNumber);
    }
    if (pageSize) {
      await Int32.parse(pageSize);
    }
    const bag = new PagedResults<FrameworkElementType>();
    bag.pageNumber = pageNumber;
    bag.pageSize = pageSize;
    await this.producer.listFrameworkElementTypes(bag, frameworkId);
    if (bag.items === null || bag.items === undefined) {
      throw new UnexpectedError("Producers must return 'items' for PagedResults queries");
    }
    return bag;
  }
  /**
   * Retrieves a list of a framework version elements
   * @summary Retrieves a list of a framework version elements
   * @param frameworkId 
   * @param versionId 
   * @param pageNumber The requested page. This value is 1-indexed.
   * @param pageSize The number of items in each page of data.
   * @param type Filter used to get an entire level
   * @param keywords Filter using keywords
   * @param sort Sort object
   * @openapi operation=listFrameworkElements path=/catalog/frameworks/{frameworkId}/versions/{versionId}/elements method=GET
   */
  public async listFrameworkElements(frameworkId: UUID, versionId: UUID, pageNumber: number = 1, pageSize: number = 50, type?: string, keywords?: string, sort?: SortObject): Promise<PagedResults<OldFrameworkElement & OldFrameworkElementExtended>> {
    // verify required parameter 'frameworkId' is not null or undefined
    if (frameworkId === null || frameworkId === undefined) {
      throw new ParameterRequiredError('frameworkId');
    }
    // verify required parameter 'versionId' is not null or undefined
    if (versionId === null || versionId === undefined) {
      throw new ParameterRequiredError('versionId');
    }
    if (pageNumber) {
      await Int32.parse(pageNumber);
    }
    if (pageSize) {
      await Int32.parse(pageSize);
    }
    const bag = new PagedResults<OldFrameworkElement & OldFrameworkElementExtended>();
    bag.pageNumber = pageNumber;
    bag.pageSize = pageSize;
    await this.producer.listFrameworkElements(bag, frameworkId, versionId, type, keywords, sort);
    if (bag.items === null || bag.items === undefined) {
      throw new UnexpectedError("Producers must return 'items' for PagedResults queries");
    }
    return bag;
  }
  /**
   * Retrieves a list of framework versions
   * @summary Retrieves a list of framework versions
   * @param frameworkCode 
   * @param frameworkVersionCode 
   * @param pageNumber The requested page. This value is 1-indexed.
   * @param pageSize The number of items in each page of data.
   * @openapi operation=listFrameworkElementsByCode path=/catalog/browserFrameworks/{frameworkCode}/{frameworkVersionCode} method=GET
   */
  public async listFrameworkElementsByCode(frameworkCode: string, frameworkVersionCode: string, pageNumber: number = 1, pageSize: number = 50): Promise<PagedResults<OldFrameworkElement & OldFrameworkElementExtended>> {
    // verify required parameter 'frameworkCode' is not null or undefined
    if (frameworkCode === null || frameworkCode === undefined || frameworkCode === '') {
      throw new ParameterRequiredError('frameworkCode');
    }
    // verify required parameter 'frameworkVersionCode' is not null or undefined
    if (frameworkVersionCode === null || frameworkVersionCode === undefined || frameworkVersionCode === '') {
      throw new ParameterRequiredError('frameworkVersionCode');
    }
    if (pageNumber) {
      await Int32.parse(pageNumber);
    }
    if (pageSize) {
      await Int32.parse(pageSize);
    }
    const bag = new PagedResults<OldFrameworkElement & OldFrameworkElementExtended>();
    bag.pageNumber = pageNumber;
    bag.pageSize = pageSize;
    await this.producer.listFrameworkElementsByCode(bag, frameworkCode, frameworkVersionCode);
    if (bag.items === null || bag.items === undefined) {
      throw new UnexpectedError("Producers must return 'items' for PagedResults queries");
    }
    return bag;
  }
  /**
   * Retrieves a list of a framework versions
   * @summary Retrieves a list of a framework versions
   * @param frameworkId 
   * @param pageNumber The requested page. This value is 1-indexed.
   * @param pageSize The number of items in each page of data.
   * @openapi operation=listFrameworkVersions path=/catalog/frameworks/{frameworkId}/versions method=GET
   */
  public async listFrameworkVersions(frameworkId: UUID, pageNumber: number = 1, pageSize: number = 50): Promise<PagedResults<FrameworkVersion>> {
    // verify required parameter 'frameworkId' is not null or undefined
    if (frameworkId === null || frameworkId === undefined) {
      throw new ParameterRequiredError('frameworkId');
    }
    if (pageNumber) {
      await Int32.parse(pageNumber);
    }
    if (pageSize) {
      await Int32.parse(pageSize);
    }
    const bag = new PagedResults<FrameworkVersion>();
    bag.pageNumber = pageNumber;
    bag.pageSize = pageSize;
    await this.producer.listFrameworkVersions(bag, frameworkId);
    if (bag.items === null || bag.items === undefined) {
      throw new UnexpectedError("Producers must return 'items' for PagedResults queries");
    }
    return bag;
  }
  /**
   * Retrieves a list of framework versions
   * @summary Retrieves a list of framework versions
   * @param frameworkCode 
   * @param pageNumber The requested page. This value is 1-indexed.
   * @param pageSize The number of items in each page of data.
   * @openapi operation=listFrameworkVersionsByCode path=/catalog/browserFrameworks/{frameworkCode} method=GET
   */
  public async listFrameworkVersionsByCode(frameworkCode: string, pageNumber: number = 1, pageSize: number = 50): Promise<PagedResults<FrameworkVersion>> {
    // verify required parameter 'frameworkCode' is not null or undefined
    if (frameworkCode === null || frameworkCode === undefined || frameworkCode === '') {
      throw new ParameterRequiredError('frameworkCode');
    }
    if (pageNumber) {
      await Int32.parse(pageNumber);
    }
    if (pageSize) {
      await Int32.parse(pageSize);
    }
    const bag = new PagedResults<FrameworkVersion>();
    bag.pageNumber = pageNumber;
    bag.pageSize = pageSize;
    await this.producer.listFrameworkVersionsByCode(bag, frameworkCode);
    if (bag.items === null || bag.items === undefined) {
      throw new UnexpectedError("Producers must return 'items' for PagedResults queries");
    }
    return bag;
  }
  /**
   * Retrieves a list of all frameworks
   * @summary Retrieves a list of all frameworks
   * @param pageNumber The requested page. This value is 1-indexed.
   * @param pageSize The number of items in each page of data.
   * @openapi operation=listFrameworks path=/catalog/frameworks method=GET
   */
  public async listFrameworks(pageNumber: number = 1, pageSize: number = 50): Promise<PagedResults<OldFramework>> {
    if (pageNumber) {
      await Int32.parse(pageNumber);
    }
    if (pageSize) {
      await Int32.parse(pageSize);
    }
    const bag = new PagedResults<OldFramework>();
    bag.pageNumber = pageNumber;
    bag.pageSize = pageSize;
    await this.producer.listFrameworks(bag);
    if (bag.items === null || bag.items === undefined) {
      throw new UnexpectedError("Producers must return 'items' for PagedResults queries");
    }
    return bag;
  }
  /**
   * Retrieves a list of all Scf controls
   * @summary Retrieves a list of all Scf controls
   * @param pageNumber The requested page. This value is 1-indexed.
   * @param pageSize The number of items in each page of data.
   * @openapi operation=listScfControls path=/catalog/scfControls method=GET
   */
  public async listScfControls(pageNumber: number = 1, pageSize: number = 50): Promise<PagedResults<ScfControl>> {
    if (pageNumber) {
      await Int32.parse(pageNumber);
    }
    if (pageSize) {
      await Int32.parse(pageSize);
    }
    const bag = new PagedResults<ScfControl>();
    bag.pageNumber = pageNumber;
    bag.pageSize = pageSize;
    await this.producer.listScfControls(bag);
    if (bag.items === null || bag.items === undefined) {
      throw new UnexpectedError("Producers must return 'items' for PagedResults queries");
    }
    return bag;
  }
  /**
   * Retrieves a list of Scf domains
   * @summary Retrieves a list of Scf domains
   * @param pageNumber The requested page. This value is 1-indexed.
   * @param pageSize The number of items in each page of data.
   * @openapi operation=listScfDomains path=/catalog/scfDomains method=GET
   */
  public async listScfDomains(pageNumber: number = 1, pageSize: number = 50): Promise<PagedResults<ScfDomain>> {
    if (pageNumber) {
      await Int32.parse(pageNumber);
    }
    if (pageSize) {
      await Int32.parse(pageSize);
    }
    const bag = new PagedResults<ScfDomain>();
    bag.pageNumber = pageNumber;
    bag.pageSize = pageSize;
    await this.producer.listScfDomains(bag);
    if (bag.items === null || bag.items === undefined) {
      throw new UnexpectedError("Producers must return 'items' for PagedResults queries");
    }
    return bag;
  }
  /**
   * Retrieves list of scf domains/controls/assertions searched by text
   * @summary Retrieves list of scf domains/controls/assertions searched by text
   * @param search 
   * @param pageNumber The requested page. This value is 1-indexed.
   * @param pageSize The number of items in each page of data.
   * @param scfType 
   * @param sort Sort object
   * @openapi operation=scfSearch path=/catalog/scfSearches method=GET
   */
  public async scfSearch(search: string, pageNumber: number = 1, pageSize: number = 50, scfType?: ScfSearchTypeDef, sort?: SortObject): Promise<PagedResults<ScfSearchResult>> {
    // verify required parameter 'search' is not null or undefined
    if (search === null || search === undefined || search === '') {
      throw new ParameterRequiredError('search');
    }
    if (pageNumber) {
      await Int32.parse(pageNumber);
    }
    if (pageSize) {
      await Int32.parse(pageSize);
    }
    const bag = new PagedResults<ScfSearchResult>();
    bag.pageNumber = pageNumber;
    bag.pageSize = pageSize;
    await this.producer.scfSearch(bag, search, scfType, sort);
    if (bag.items === null || bag.items === undefined) {
      throw new UnexpectedError("Producers must return 'items' for PagedResults queries");
    }
    return bag;
  }
}

/**
 * Wrap producer with mapping implementation
 */
export function wrapFrameworkProducer(producer: FrameworkProducerApi): FrameworkApi {
  return new FrameworkApiMappingImpl(producer);
}

/**
 * FrameworkApiHttpImpl - Direct HTTP implementation
 *
 * Makes direct HTTP calls to the API using Axios.
 * Used by SDK clients for platform service access.
 */
export class FrameworkApiHttpImpl implements FrameworkProducerApi {
  private client: AxiosInstance;
  private headers: Record<string, string>;

  constructor(client: AxiosInstance, headers: Record<string, string> = {}) {
    this.client = client;
    this.headers = headers;
  }

  async getFramework(frameworkId: UUID): Promise<OldFramework> {
  const _queryParams = {
      
  };
  const _bodyParams = {
      
  };
  let _path = '/catalog/frameworks/{frameworkId}';
  _path = _path.replace('{frameworkId}', encodeURIComponent(String(frameworkId)));
  return this.client.get(
    _path,
    { params: _queryParams })
    .then((response) => {
      // BaseApiClient uses validateStatus: () => true, so we must check status manually
      if (response.status >= 400) {
        throw CoreError.deserialize(response.data);
      }
      return ObjectSerializer.deserialize(response.data, 'OldFramework')
    })
    .catch((error) => {
      if (error.data) {
        throw CoreError.deserialize(error.data);
      } else {
        throw error;
      }
    });
  }
  async getFrameworkElement(frameworkId: UUID, versionId: UUID, elementId: UUID): Promise<OldFrameworkElement> {
  const _queryParams = {
      
  };
  const _bodyParams = {
      
  };
  let _path = '/catalog/frameworks/{frameworkId}/versions/{versionId}/elements/{elementId}';
  _path = _path.replace('{frameworkId}', encodeURIComponent(String(frameworkId)));
  _path = _path.replace('{versionId}', encodeURIComponent(String(versionId)));
  _path = _path.replace('{elementId}', encodeURIComponent(String(elementId)));
  return this.client.get(
    _path,
    { params: _queryParams })
    .then((response) => {
      // BaseApiClient uses validateStatus: () => true, so we must check status manually
      if (response.status >= 400) {
        throw CoreError.deserialize(response.data);
      }
      return ObjectSerializer.deserialize(response.data, 'OldFrameworkElement')
    })
    .catch((error) => {
      if (error.data) {
        throw CoreError.deserialize(error.data);
      } else {
        throw error;
      }
    });
  }
  async getFrameworkElementByCode(frameworkCode: string, frameworkVersionCode: string, frameworkElementCode: string): Promise<OldFrameworkElement> {
  const _queryParams = {
      
  };
  const _bodyParams = {
      
  };
  let _path = '/catalog/browserFrameworks/{frameworkCode}/{frameworkVersionCode}/{frameworkElementCode}';
  _path = _path.replace('{frameworkCode}', encodeURIComponent(String(frameworkCode)));
  _path = _path.replace('{frameworkVersionCode}', encodeURIComponent(String(frameworkVersionCode)));
  _path = _path.replace('{frameworkElementCode}', encodeURIComponent(String(frameworkElementCode)));
  return this.client.get(
    _path,
    { params: _queryParams })
    .then((response) => {
      // BaseApiClient uses validateStatus: () => true, so we must check status manually
      if (response.status >= 400) {
        throw CoreError.deserialize(response.data);
      }
      return ObjectSerializer.deserialize(response.data, 'OldFrameworkElement')
    })
    .catch((error) => {
      if (error.data) {
        throw CoreError.deserialize(error.data);
      } else {
        throw error;
      }
    });
  }
  async getFrameworkElementInfo(id: UUID): Promise<OldFrameworkElement> {
  const _queryParams = {
      
  };
  const _bodyParams = {
      
  };
  let _path = '/catalog/frameworkElements/{id}';
  _path = _path.replace('{id}', encodeURIComponent(String(id)));
  return this.client.get(
    _path,
    { params: _queryParams })
    .then((response) => {
      // BaseApiClient uses validateStatus: () => true, so we must check status manually
      if (response.status >= 400) {
        throw CoreError.deserialize(response.data);
      }
      return ObjectSerializer.deserialize(response.data, 'OldFrameworkElement')
    })
    .catch((error) => {
      if (error.data) {
        throw CoreError.deserialize(error.data);
      } else {
        throw error;
      }
    });
  }
  async getFrameworkVersion(frameworkId: UUID, versionId: UUID): Promise<FrameworkVersion & ExtendedFrameworkVersion> {
  const _queryParams = {
      
  };
  const _bodyParams = {
      
  };
  let _path = '/catalog/frameworks/{frameworkId}/versions/{versionId}';
  _path = _path.replace('{frameworkId}', encodeURIComponent(String(frameworkId)));
  _path = _path.replace('{versionId}', encodeURIComponent(String(versionId)));
  return this.client.get(
    _path,
    { params: _queryParams })
    .then((response) => {
      // BaseApiClient uses validateStatus: () => true, so we must check status manually
      if (response.status >= 400) {
        throw CoreError.deserialize(response.data);
      }
      return ObjectSerializer.deserialize(response.data, 'FrameworkVersion & ExtendedFrameworkVersion')
    })
    .catch((error) => {
      if (error.data) {
        throw CoreError.deserialize(error.data);
      } else {
        throw error;
      }
    });
  }
  async getScfControl(id: UUID): Promise<ScfControl> {
  const _queryParams = {
      
  };
  const _bodyParams = {
      
  };
  let _path = '/catalog/scfControls/{id}';
  _path = _path.replace('{id}', encodeURIComponent(String(id)));
  return this.client.get(
    _path,
    { params: _queryParams })
    .then((response) => {
      // BaseApiClient uses validateStatus: () => true, so we must check status manually
      if (response.status >= 400) {
        throw CoreError.deserialize(response.data);
      }
      return ObjectSerializer.deserialize(response.data, 'ScfControl')
    })
    .catch((error) => {
      if (error.data) {
        throw CoreError.deserialize(error.data);
      } else {
        throw error;
      }
    });
  }
  async getScfDomain(domainCode: string): Promise<ScfDomainExtended> {
  const _queryParams = {
      
  };
  const _bodyParams = {
      
  };
  let _path = '/catalog/scfDomains/{domainCode}';
  _path = _path.replace('{domainCode}', encodeURIComponent(String(domainCode)));
  return this.client.get(
    _path,
    { params: _queryParams })
    .then((response) => {
      // BaseApiClient uses validateStatus: () => true, so we must check status manually
      if (response.status >= 400) {
        throw CoreError.deserialize(response.data);
      }
      return ObjectSerializer.deserialize(response.data, 'ScfDomainExtended')
    })
    .catch((error) => {
      if (error.data) {
        throw CoreError.deserialize(error.data);
      } else {
        throw error;
      }
    });
  }
  async listBrowserFrameworks(results: PagedResults<OldFramework>): Promise<void> {
  const _body = {
      
  };
  let _path = '/catalog/browserFrameworks';
  return this.client.get(
    _path,
    {
      params: {
        ..._body,
        pageNumber: results.pageNumber,
        pageSize: results.pageSize,
      }
    })
    .then((response) => {
      // BaseApiClient uses validateStatus: () => true, so we must check status manually
      if (response.status >= 400) {
        throw CoreError.deserialize(response.data);
      }
      results.items = ObjectSerializer.deserialize(response.data, 'Array<OldFramework>');
      results.count = response.headers.count ? Number(response.headers.count) : -1;
      results.pageToken = response.headers.pagetoken ?? response.headers.pageToken;
      results.headers = this.headers;
      results.baseUrl = new URL(`${this.client.getUri()}/catalog/browserFrameworks`);
      results.httpMethod = HttpMethod.Get;
      results.body = _body;
      results.mapper = (obj) => ObjectSerializer.deserialize(obj, 'OldFramework');
    })
    .catch((error) => {
      if (error.data) {
        throw CoreError.deserialize(error.data);
      } else {
        throw error;
      }
    });
  }
  async listEvidenceDefinitionByFrameworkElementId(results: PagedResults<EvidenceDefinitionFrameworkElementLink>, id: UUID, scope?: EvidenceDefinitionScfLinkScopeDef, required?: EvidenceDefinitionScfLinkRequiredDef, sort?: SortObject): Promise<void> {
  const _body = {
      id,scope,required,sort,
  };
  let _path = '/catalog/frameworkElements/{id}/evidenceDefinitions';
  _path = _path.replace('{id}', encodeURIComponent(String(id)));
  return this.client.get(
    _path,
    {
      params: {
        ..._body,
        pageNumber: results.pageNumber,
        pageSize: results.pageSize,
      }
    })
    .then((response) => {
      // BaseApiClient uses validateStatus: () => true, so we must check status manually
      if (response.status >= 400) {
        throw CoreError.deserialize(response.data);
      }
      results.items = ObjectSerializer.deserialize(response.data, 'Array<EvidenceDefinitionFrameworkElementLink>');
      results.count = response.headers.count ? Number(response.headers.count) : -1;
      results.pageToken = response.headers.pagetoken ?? response.headers.pageToken;
      results.headers = this.headers;
      results.baseUrl = new URL(`${this.client.getUri()}/catalog/frameworkElements/{id}/evidenceDefinitions`);
      results.httpMethod = HttpMethod.Get;
      results.body = _body;
      results.mapper = (obj) => ObjectSerializer.deserialize(obj, 'EvidenceDefinitionFrameworkElementLink');
    })
    .catch((error) => {
      if (error.data) {
        throw CoreError.deserialize(error.data);
      } else {
        throw error;
      }
    });
  }
  async listFrameworkElementTypes(results: PagedResults<FrameworkElementType>, frameworkId: UUID): Promise<void> {
  const _body = {
      frameworkId,
  };
  let _path = '/catalog/frameworks/{frameworkId}/elementTypes';
  _path = _path.replace('{frameworkId}', encodeURIComponent(String(frameworkId)));
  return this.client.get(
    _path,
    {
      params: {
        ..._body,
        pageNumber: results.pageNumber,
        pageSize: results.pageSize,
      }
    })
    .then((response) => {
      // BaseApiClient uses validateStatus: () => true, so we must check status manually
      if (response.status >= 400) {
        throw CoreError.deserialize(response.data);
      }
      results.items = ObjectSerializer.deserialize(response.data, 'Array<FrameworkElementType>');
      results.count = response.headers.count ? Number(response.headers.count) : -1;
      results.pageToken = response.headers.pagetoken ?? response.headers.pageToken;
      results.headers = this.headers;
      results.baseUrl = new URL(`${this.client.getUri()}/catalog/frameworks/{frameworkId}/elementTypes`);
      results.httpMethod = HttpMethod.Get;
      results.body = _body;
      results.mapper = (obj) => ObjectSerializer.deserialize(obj, 'FrameworkElementType');
    })
    .catch((error) => {
      if (error.data) {
        throw CoreError.deserialize(error.data);
      } else {
        throw error;
      }
    });
  }
  async listFrameworkElements(results: PagedResults<OldFrameworkElement & OldFrameworkElementExtended>, frameworkId: UUID, versionId: UUID, type?: string, keywords?: string, sort?: SortObject): Promise<void> {
  const _body = {
      frameworkId,versionId,type,keywords,sort,
  };
  let _path = '/catalog/frameworks/{frameworkId}/versions/{versionId}/elements';
  _path = _path.replace('{frameworkId}', encodeURIComponent(String(frameworkId)));
  _path = _path.replace('{versionId}', encodeURIComponent(String(versionId)));
  return this.client.get(
    _path,
    {
      params: {
        ..._body,
        pageNumber: results.pageNumber,
        pageSize: results.pageSize,
      }
    })
    .then((response) => {
      // BaseApiClient uses validateStatus: () => true, so we must check status manually
      if (response.status >= 400) {
        throw CoreError.deserialize(response.data);
      }
      results.items = ObjectSerializer.deserialize(response.data, 'Array<OldFrameworkElement & OldFrameworkElementExtended>');
      results.count = response.headers.count ? Number(response.headers.count) : -1;
      results.pageToken = response.headers.pagetoken ?? response.headers.pageToken;
      results.headers = this.headers;
      results.baseUrl = new URL(`${this.client.getUri()}/catalog/frameworks/{frameworkId}/versions/{versionId}/elements`);
      results.httpMethod = HttpMethod.Get;
      results.body = _body;
      results.mapper = (obj) => ObjectSerializer.deserialize(obj, 'OldFrameworkElement & OldFrameworkElementExtended');
    })
    .catch((error) => {
      if (error.data) {
        throw CoreError.deserialize(error.data);
      } else {
        throw error;
      }
    });
  }
  async listFrameworkElementsByCode(results: PagedResults<OldFrameworkElement & OldFrameworkElementExtended>, frameworkCode: string, frameworkVersionCode: string): Promise<void> {
  const _body = {
      frameworkCode,frameworkVersionCode,
  };
  let _path = '/catalog/browserFrameworks/{frameworkCode}/{frameworkVersionCode}';
  _path = _path.replace('{frameworkCode}', encodeURIComponent(String(frameworkCode)));
  _path = _path.replace('{frameworkVersionCode}', encodeURIComponent(String(frameworkVersionCode)));
  return this.client.get(
    _path,
    {
      params: {
        ..._body,
        pageNumber: results.pageNumber,
        pageSize: results.pageSize,
      }
    })
    .then((response) => {
      // BaseApiClient uses validateStatus: () => true, so we must check status manually
      if (response.status >= 400) {
        throw CoreError.deserialize(response.data);
      }
      results.items = ObjectSerializer.deserialize(response.data, 'Array<OldFrameworkElement & OldFrameworkElementExtended>');
      results.count = response.headers.count ? Number(response.headers.count) : -1;
      results.pageToken = response.headers.pagetoken ?? response.headers.pageToken;
      results.headers = this.headers;
      results.baseUrl = new URL(`${this.client.getUri()}/catalog/browserFrameworks/{frameworkCode}/{frameworkVersionCode}`);
      results.httpMethod = HttpMethod.Get;
      results.body = _body;
      results.mapper = (obj) => ObjectSerializer.deserialize(obj, 'OldFrameworkElement & OldFrameworkElementExtended');
    })
    .catch((error) => {
      if (error.data) {
        throw CoreError.deserialize(error.data);
      } else {
        throw error;
      }
    });
  }
  async listFrameworkVersions(results: PagedResults<FrameworkVersion>, frameworkId: UUID): Promise<void> {
  const _body = {
      frameworkId,
  };
  let _path = '/catalog/frameworks/{frameworkId}/versions';
  _path = _path.replace('{frameworkId}', encodeURIComponent(String(frameworkId)));
  return this.client.get(
    _path,
    {
      params: {
        ..._body,
        pageNumber: results.pageNumber,
        pageSize: results.pageSize,
      }
    })
    .then((response) => {
      // BaseApiClient uses validateStatus: () => true, so we must check status manually
      if (response.status >= 400) {
        throw CoreError.deserialize(response.data);
      }
      results.items = ObjectSerializer.deserialize(response.data, 'Array<FrameworkVersion>');
      results.count = response.headers.count ? Number(response.headers.count) : -1;
      results.pageToken = response.headers.pagetoken ?? response.headers.pageToken;
      results.headers = this.headers;
      results.baseUrl = new URL(`${this.client.getUri()}/catalog/frameworks/{frameworkId}/versions`);
      results.httpMethod = HttpMethod.Get;
      results.body = _body;
      results.mapper = (obj) => ObjectSerializer.deserialize(obj, 'FrameworkVersion');
    })
    .catch((error) => {
      if (error.data) {
        throw CoreError.deserialize(error.data);
      } else {
        throw error;
      }
    });
  }
  async listFrameworkVersionsByCode(results: PagedResults<FrameworkVersion>, frameworkCode: string): Promise<void> {
  const _body = {
      frameworkCode,
  };
  let _path = '/catalog/browserFrameworks/{frameworkCode}';
  _path = _path.replace('{frameworkCode}', encodeURIComponent(String(frameworkCode)));
  return this.client.get(
    _path,
    {
      params: {
        ..._body,
        pageNumber: results.pageNumber,
        pageSize: results.pageSize,
      }
    })
    .then((response) => {
      // BaseApiClient uses validateStatus: () => true, so we must check status manually
      if (response.status >= 400) {
        throw CoreError.deserialize(response.data);
      }
      results.items = ObjectSerializer.deserialize(response.data, 'Array<FrameworkVersion>');
      results.count = response.headers.count ? Number(response.headers.count) : -1;
      results.pageToken = response.headers.pagetoken ?? response.headers.pageToken;
      results.headers = this.headers;
      results.baseUrl = new URL(`${this.client.getUri()}/catalog/browserFrameworks/{frameworkCode}`);
      results.httpMethod = HttpMethod.Get;
      results.body = _body;
      results.mapper = (obj) => ObjectSerializer.deserialize(obj, 'FrameworkVersion');
    })
    .catch((error) => {
      if (error.data) {
        throw CoreError.deserialize(error.data);
      } else {
        throw error;
      }
    });
  }
  async listFrameworks(results: PagedResults<OldFramework>): Promise<void> {
  const _body = {
      
  };
  let _path = '/catalog/frameworks';
  return this.client.get(
    _path,
    {
      params: {
        ..._body,
        pageNumber: results.pageNumber,
        pageSize: results.pageSize,
      }
    })
    .then((response) => {
      // BaseApiClient uses validateStatus: () => true, so we must check status manually
      if (response.status >= 400) {
        throw CoreError.deserialize(response.data);
      }
      results.items = ObjectSerializer.deserialize(response.data, 'Array<OldFramework>');
      results.count = response.headers.count ? Number(response.headers.count) : -1;
      results.pageToken = response.headers.pagetoken ?? response.headers.pageToken;
      results.headers = this.headers;
      results.baseUrl = new URL(`${this.client.getUri()}/catalog/frameworks`);
      results.httpMethod = HttpMethod.Get;
      results.body = _body;
      results.mapper = (obj) => ObjectSerializer.deserialize(obj, 'OldFramework');
    })
    .catch((error) => {
      if (error.data) {
        throw CoreError.deserialize(error.data);
      } else {
        throw error;
      }
    });
  }
  async listScfControls(results: PagedResults<ScfControl>): Promise<void> {
  const _body = {
      
  };
  let _path = '/catalog/scfControls';
  return this.client.get(
    _path,
    {
      params: {
        ..._body,
        pageNumber: results.pageNumber,
        pageSize: results.pageSize,
      }
    })
    .then((response) => {
      // BaseApiClient uses validateStatus: () => true, so we must check status manually
      if (response.status >= 400) {
        throw CoreError.deserialize(response.data);
      }
      results.items = ObjectSerializer.deserialize(response.data, 'Array<ScfControl>');
      results.count = response.headers.count ? Number(response.headers.count) : -1;
      results.pageToken = response.headers.pagetoken ?? response.headers.pageToken;
      results.headers = this.headers;
      results.baseUrl = new URL(`${this.client.getUri()}/catalog/scfControls`);
      results.httpMethod = HttpMethod.Get;
      results.body = _body;
      results.mapper = (obj) => ObjectSerializer.deserialize(obj, 'ScfControl');
    })
    .catch((error) => {
      if (error.data) {
        throw CoreError.deserialize(error.data);
      } else {
        throw error;
      }
    });
  }
  async listScfDomains(results: PagedResults<ScfDomain>): Promise<void> {
  const _body = {
      
  };
  let _path = '/catalog/scfDomains';
  return this.client.get(
    _path,
    {
      params: {
        ..._body,
        pageNumber: results.pageNumber,
        pageSize: results.pageSize,
      }
    })
    .then((response) => {
      // BaseApiClient uses validateStatus: () => true, so we must check status manually
      if (response.status >= 400) {
        throw CoreError.deserialize(response.data);
      }
      results.items = ObjectSerializer.deserialize(response.data, 'Array<ScfDomain>');
      results.count = response.headers.count ? Number(response.headers.count) : -1;
      results.pageToken = response.headers.pagetoken ?? response.headers.pageToken;
      results.headers = this.headers;
      results.baseUrl = new URL(`${this.client.getUri()}/catalog/scfDomains`);
      results.httpMethod = HttpMethod.Get;
      results.body = _body;
      results.mapper = (obj) => ObjectSerializer.deserialize(obj, 'ScfDomain');
    })
    .catch((error) => {
      if (error.data) {
        throw CoreError.deserialize(error.data);
      } else {
        throw error;
      }
    });
  }
  async scfSearch(results: PagedResults<ScfSearchResult>, search: string, scfType?: ScfSearchTypeDef, sort?: SortObject): Promise<void> {
  const _body = {
      search,scfType,sort,
  };
  let _path = '/catalog/scfSearches';
  return this.client.get(
    _path,
    {
      params: {
        ..._body,
        pageNumber: results.pageNumber,
        pageSize: results.pageSize,
      }
    })
    .then((response) => {
      // BaseApiClient uses validateStatus: () => true, so we must check status manually
      if (response.status >= 400) {
        throw CoreError.deserialize(response.data);
      }
      results.items = ObjectSerializer.deserialize(response.data, 'Array<ScfSearchResult>');
      results.count = response.headers.count ? Number(response.headers.count) : -1;
      results.pageToken = response.headers.pagetoken ?? response.headers.pageToken;
      results.headers = this.headers;
      results.baseUrl = new URL(`${this.client.getUri()}/catalog/scfSearches`);
      results.httpMethod = HttpMethod.Get;
      results.body = _body;
      results.mapper = (obj) => ObjectSerializer.deserialize(obj, 'ScfSearchResult');
    })
    .catch((error) => {
      if (error.data) {
        throw CoreError.deserialize(error.data);
      } else {
        throw error;
      }
    });
  }
}
