/* eslint-disable */
// ===============================================
// This file is autogenerated - Please do not edit
// ===============================================
import { AxiosInstance } from 'axios';
import { BaselineElementExtended, BaselineExtended, ElementExtended, ElementSearchRequestBody, SearchStandardBody, SortObject, StandardExtended, StandardFilterTreeNode, StandardStatusDef, StandardTypeDef } from '../model/index.js';
import { URL, EnumValue, IllegalArgumentError, PagedResults, Int32, UUID, CoreError, ParameterRequiredError, UnexpectedError, HttpMethod } from '@zerobias-org/types-core-js';
import { RequestFile, ObjectSerializer } from '../model/index.js';

export namespace StandardApi {
}

/**
 * StandardApi - interface
 * @export
 * @interface StandardApi
 */
export interface StandardApi {
  /**
   * Browse standard baseline element
   * @summary Browse standard baseline element
   * @param {string} standardCode 
   * @param {string} baselineCode 
   * @param {string} elementCode 
   * @param {*} [options] Override http request option.
   * @throws {@link @zerobias-org/types-core-js#ParameterRequiredError} if any required parameter is not provided
   * @example
   * ```typescript
   * const result = await api.browseStandardBaselineElement('standardCode', 'baselineCode', 'elementCode');
   * ```
   * @openapi operation=browseStandardBaselineElement path=/standardBrowser/{standardCode}/{baselineCode}/{elementCode} method=GET
   * @memberof StandardApi
   */
  browseStandardBaselineElement(standardCode: string, baselineCode: string, elementCode: string): Promise<BaselineElementExtended>;

  /**
   * Browse standard baseline elements
   * @summary Browse standard baseline elements
   * @param {string} standardCode 
   * @param {string} baselineCode 
   * @param {number} [pageNumber] The requested page. This value is 1-indexed.
   * @param {number} [pageSize] The number of items in each page of data.
   * @param {*} [options] Override http request option.
   * @throws {@link @zerobias-org/types-core-js#ParameterRequiredError} if any required parameter is not provided
   * @example
   * ```typescript
   * const result = await api.browseStandardBaselineElements('standardCode', 'baselineCode', 1, 1);
   * ```
   * @openapi operation=browseStandardBaselineElements path=/standardBrowser/{standardCode}/{baselineCode} method=GET
   * @memberof StandardApi
   */
  browseStandardBaselineElements(standardCode: string, baselineCode: string, pageNumber?: number, pageSize?: number): Promise<PagedResults<BaselineElementExtended>>;

  /**
   * Browse standard baselines
   * @summary Browse standard baselines
   * @param {string} standardCode 
   * @param {number} [pageNumber] The requested page. This value is 1-indexed.
   * @param {number} [pageSize] The number of items in each page of data.
   * @param {*} [options] Override http request option.
   * @throws {@link @zerobias-org/types-core-js#ParameterRequiredError} if any required parameter is not provided
   * @example
   * ```typescript
   * const result = await api.browseStandardBaselines('standardCode', 1, 1);
   * ```
   * @openapi operation=browseStandardBaselines path=/standardBrowser/{standardCode} method=GET
   * @memberof StandardApi
   */
  browseStandardBaselines(standardCode: string, pageNumber?: number, pageSize?: number): Promise<PagedResults<BaselineExtended>>;

  /**
   * Browse standards
   * @summary Browse standards
   * @param {number} [pageNumber] The requested page. This value is 1-indexed.
   * @param {number} [pageSize] The number of items in each page of data.
   * @param {*} [options] Override http request option.
   * @throws {@link @zerobias-org/types-core-js#ParameterRequiredError} if any required parameter is not provided
   * @example
   * ```typescript
   * const result = await api.browseStandards(1, 1);
   * ```
   * @openapi operation=browseStandards path=/standardBrowser method=GET
   * @memberof StandardApi
   */
  browseStandards(pageNumber?: number, pageSize?: number): Promise<PagedResults<StandardExtended>>;

  /**
   * Get standard by id
   * @summary Get standard by id
   * @param {UUID} standardId 
   * @param {*} [options] Override http request option.
   * @throws {@link @zerobias-org/types-core-js#ParameterRequiredError} if any required parameter is not provided
   * @example
   * ```typescript
   * const result = await api.get('00000000-0000-0000-0000-000000000000');
   * ```
   * @openapi operation=getStandard path=/standards/{standardId} method=GET
   * @memberof StandardApi
   */
  get(standardId: UUID): Promise<StandardExtended>;

  /**
   * Get baseline by standard and baseline id
   * @summary Get baseline by standard and baseline id
   * @param {UUID} standardId 
   * @param {UUID} baselineId 
   * @param {*} [options] Override http request option.
   * @throws {@link @zerobias-org/types-core-js#ParameterRequiredError} if any required parameter is not provided
   * @example
   * ```typescript
   * const result = await api.getBaseline('00000000-0000-0000-0000-000000000000', '00000000-0000-0000-0000-000000000000');
   * ```
   * @openapi operation=getStandardBaseline path=/standards/{standardId}/baselines/{baselineId} method=GET
   * @memberof StandardApi
   */
  getBaseline(standardId: UUID, baselineId: UUID): Promise<BaselineExtended>;

  /**
   * Get element by standard and baseline and element id
   * @summary Get element by standard and baseline and element id
   * @param {UUID} standardId 
   * @param {UUID} baselineId 
   * @param {UUID} elementId 
   * @param {*} [options] Override http request option.
   * @throws {@link @zerobias-org/types-core-js#ParameterRequiredError} if any required parameter is not provided
   * @example
   * ```typescript
   * const result = await api.getBaselineElement('00000000-0000-0000-0000-000000000000', '00000000-0000-0000-0000-000000000000', '00000000-0000-0000-0000-000000000000');
   * ```
   * @openapi operation=getStandardBaselineElement path=/standards/{standardId}/baselines/{baselineId}/elements/{elementId} method=GET
   * @memberof StandardApi
   */
  getBaselineElement(standardId: UUID, baselineId: UUID, elementId: UUID): Promise<BaselineElementExtended>;

  /**
   * Get element by standard and baseline and element id
   * @summary Get element by standard and baseline and element id
   * @param {UUID} standardId 
   * @param {UUID} baselineId 
   * @param {*} [options] Override http request option.
   * @throws {@link @zerobias-org/types-core-js#ParameterRequiredError} if any required parameter is not provided
   * @example
   * ```typescript
   * const result = await api.getBaselineFilterTree('00000000-0000-0000-0000-000000000000', '00000000-0000-0000-0000-000000000000');
   * ```
   * @openapi operation=getStandardBaselineFilterTree path=/standards/{standardId}/baselines/{baselineId}/filterTree method=GET
   * @memberof StandardApi
   */
  getBaselineFilterTree(standardId: UUID, baselineId: UUID): Promise<{ [key: string]: StandardFilterTreeNode; }>;

  /**
   * Get element by standard and element id
   * @summary Get element by standard and element id
   * @param {UUID} standardId 
   * @param {UUID} elementId 
   * @param {*} [options] Override http request option.
   * @throws {@link @zerobias-org/types-core-js#ParameterRequiredError} if any required parameter is not provided
   * @example
   * ```typescript
   * const result = await api.getElement('00000000-0000-0000-0000-000000000000', '00000000-0000-0000-0000-000000000000');
   * ```
   * @openapi operation=getStandardElement path=/standards/{standardId}/elements/{elementId} method=GET
   * @memberof StandardApi
   */
  getElement(standardId: UUID, elementId: UUID): Promise<ElementExtended>;

  /**
   * list all standard baseline elements
   * @summary list all standard baseline elements
   * @param {UUID} standardId 
   * @param {UUID} baselineId 
   * @param {number} [pageNumber] The requested page. This value is 1-indexed.
   * @param {number} [pageSize] The number of items in each page of data.
   * @param {UUID} [elementTypeId] 
   * @param {string} [search] 
   * @param {SortObject} [sort] Sort object
   * @param {*} [options] Override http request option.
   * @throws {@link @zerobias-org/types-core-js#ParameterRequiredError} if any required parameter is not provided
   * @example
   * ```typescript
   * const result = await api.listBaselineElements('00000000-0000-0000-0000-000000000000', '00000000-0000-0000-0000-000000000000', 1, 1, '00000000-0000-0000-0000-000000000000', 'search', null);
   * ```
   * @openapi operation=listStandardBaselineElements path=/standards/{standardId}/baselines/{baselineId}/elements method=GET
   * @memberof StandardApi
   */
  listBaselineElements(standardId: UUID, baselineId: UUID, pageNumber?: number, pageSize?: number, elementTypeId?: UUID, search?: string, sort?: SortObject): Promise<PagedResults<BaselineElementExtended>>;

  /**
   * list all standard baselines
   * @summary list all standard baselines
   * @param {UUID} standardId 
   * @param {number} [pageNumber] The requested page. This value is 1-indexed.
   * @param {number} [pageSize] The number of items in each page of data.
   * @param {string} [search] 
   * @param {SortObject} [sort] Sort object
   * @param {*} [options] Override http request option.
   * @throws {@link @zerobias-org/types-core-js#ParameterRequiredError} if any required parameter is not provided
   * @example
   * ```typescript
   * const result = await api.listBaselines('00000000-0000-0000-0000-000000000000', 1, 1, 'search', null);
   * ```
   * @openapi operation=listStandardBaselines path=/standards/{standardId}/baselines method=GET
   * @memberof StandardApi
   */
  listBaselines(standardId: UUID, pageNumber?: number, pageSize?: number, search?: string, sort?: SortObject): Promise<PagedResults<BaselineExtended>>;

  /**
   * list all standard elements
   * @summary list all standard elements
   * @param {UUID} standardId 
   * @param {number} [pageNumber] The requested page. This value is 1-indexed.
   * @param {number} [pageSize] The number of items in each page of data.
   * @param {UUID} [elementTypeId] 
   * @param {string} [search] 
   * @param {string} [packageCode] 
   * @param {SortObject} [sort] Sort object
   * @param {*} [options] Override http request option.
   * @throws {@link @zerobias-org/types-core-js#ParameterRequiredError} if any required parameter is not provided
   * @example
   * ```typescript
   * const result = await api.listElements('00000000-0000-0000-0000-000000000000', 1, 1, '00000000-0000-0000-0000-000000000000', 'search', 'packageCode', null);
   * ```
   * @openapi operation=listStandardElements path=/standards/{standardId}/elements method=GET
   * @memberof StandardApi
   */
  listElements(standardId: UUID, pageNumber?: number, pageSize?: number, elementTypeId?: UUID, search?: string, packageCode?: string, sort?: SortObject): Promise<PagedResults<ElementExtended>>;

  /**
   * list all standards
   * @summary list all standards
   * @param {number} [pageNumber] The requested page. This value is 1-indexed.
   * @param {number} [pageSize] The number of items in each page of data.
   * @param {StandardType} [standardType] 
   * @param {StandardStatus} [status] 
   * @param {string} [search] 
   * @param {string} [packageCode] 
   * @param {UUID} [vspId] 
   * @param {SortObject} [sort] Sort object
   * @param {*} [options] Override http request option.
   * @throws {@link @zerobias-org/types-core-js#ParameterRequiredError} if any required parameter is not provided
   * @example
   * ```typescript
   * const result = await api.list(1, 1, null, null, 'search', 'packageCode', '00000000-0000-0000-0000-000000000000', null);
   * ```
   * @openapi operation=listStandards path=/standards method=GET
   * @memberof StandardApi
   */
  list(pageNumber?: number, pageSize?: number, standardType?: StandardTypeDef, status?: StandardStatusDef, search?: string, packageCode?: string, vspId?: UUID, sort?: SortObject): Promise<PagedResults<StandardExtended>>;

  /**
   * search standard elements
   * @summary search standard elements
   * @param {UUID} standardId 
   * @param {ElementSearchRequestBody} elementSearchRequestBody 
   * @param {number} [pageNumber] The requested page. This value is 1-indexed.
   * @param {number} [pageSize] The number of items in each page of data.
   * @param {SortObject} [sort] Sort object
   * @param {*} [options] Override http request option.
   * @throws {@link @zerobias-org/types-core-js#ParameterRequiredError} if any required parameter is not provided
   * @example
   * ```typescript
   * const result = await api.searchElements('00000000-0000-0000-0000-000000000000', null, 1, 1, null);
   * ```
   * @openapi operation=searchStandardElements path=/standards/{standardId}/elementSearch method=POST
   * @memberof StandardApi
   */
  searchElements(standardId: UUID, elementSearchRequestBody: ElementSearchRequestBody, pageNumber?: number, pageSize?: number, sort?: SortObject): Promise<PagedResults<ElementExtended>>;

  /**
   * search standards
   * @summary search standards
   * @param {SearchStandardBody} searchStandardBody 
   * @param {number} [pageNumber] The requested page. This value is 1-indexed.
   * @param {number} [pageSize] The number of items in each page of data.
   * @param {SortObject} [sort] Sort object
   * @param {*} [options] Override http request option.
   * @throws {@link @zerobias-org/types-core-js#ParameterRequiredError} if any required parameter is not provided
   * @example
   * ```typescript
   * const result = await api.search(null, 1, 1, null);
   * ```
   * @openapi operation=searchStandards path=/standardSearch method=POST
   * @memberof StandardApi
   */
  search(searchStandardBody: SearchStandardBody, pageNumber?: number, pageSize?: number, sort?: SortObject): Promise<PagedResults<StandardExtended>>;

}

/**
 * StandardProducerApi - interface
 * Producer interface for Standard
 * @export
 * @interface StandardProducerApi
 */
export interface StandardProducerApi {
  /**
  * Browse standard baseline element
  * @summary Browse standard baseline element
  * @param {string} standardCode 
  * @param {string} baselineCode 
  * @param {string} elementCode 
  * @param {*} [options] Override http request option.
  * @throws {@link @zerobias-org/types-core-js#ParameterRequiredError} if any required parameter is not provided
  * @openapi operation=browseStandardBaselineElement path=/standardBrowser/{standardCode}/{baselineCode}/{elementCode} method=GET
  * @memberof Standard
  */
  browseStandardBaselineElement(standardCode: string, baselineCode: string, elementCode: string): Promise<BaselineElementExtended>;
  /**
  * Browse standard baseline elements
  * @summary Browse standard baseline elements
  * @param {string} standardCode 
  * @param {string} baselineCode 
  * @param {*} [options] Override http request option.
  * @throws {@link @zerobias-org/types-core-js#ParameterRequiredError} if any required parameter is not provided
  * @openapi operation=browseStandardBaselineElements path=/standardBrowser/{standardCode}/{baselineCode} method=GET
  * @memberof Standard
  */
  browseStandardBaselineElements(results: PagedResults<BaselineElementExtended>, standardCode: string, baselineCode: string): Promise<void>;
  /**
  * Browse standard baselines
  * @summary Browse standard baselines
  * @param {string} standardCode 
  * @param {*} [options] Override http request option.
  * @throws {@link @zerobias-org/types-core-js#ParameterRequiredError} if any required parameter is not provided
  * @openapi operation=browseStandardBaselines path=/standardBrowser/{standardCode} method=GET
  * @memberof Standard
  */
  browseStandardBaselines(results: PagedResults<BaselineExtended>, standardCode: string): Promise<void>;
  /**
  * Browse standards
  * @summary Browse standards
  * @param {*} [options] Override http request option.
  * @throws {@link @zerobias-org/types-core-js#ParameterRequiredError} if any required parameter is not provided
  * @openapi operation=browseStandards path=/standardBrowser method=GET
  * @memberof Standard
  */
  browseStandards(results: PagedResults<StandardExtended>): Promise<void>;
  /**
  * Get standard by id
  * @summary Get standard by id
  * @param {UUID} standardId 
  * @param {*} [options] Override http request option.
  * @throws {@link @zerobias-org/types-core-js#ParameterRequiredError} if any required parameter is not provided
  * @openapi operation=getStandard path=/standards/{standardId} method=GET
  * @memberof Standard
  */
  get(standardId: UUID): Promise<StandardExtended>;
  /**
  * Get baseline by standard and baseline id
  * @summary Get baseline by standard and baseline id
  * @param {UUID} standardId 
  * @param {UUID} baselineId 
  * @param {*} [options] Override http request option.
  * @throws {@link @zerobias-org/types-core-js#ParameterRequiredError} if any required parameter is not provided
  * @openapi operation=getStandardBaseline path=/standards/{standardId}/baselines/{baselineId} method=GET
  * @memberof Standard
  */
  getBaseline(standardId: UUID, baselineId: UUID): Promise<BaselineExtended>;
  /**
  * Get element by standard and baseline and element id
  * @summary Get element by standard and baseline and element id
  * @param {UUID} standardId 
  * @param {UUID} baselineId 
  * @param {UUID} elementId 
  * @param {*} [options] Override http request option.
  * @throws {@link @zerobias-org/types-core-js#ParameterRequiredError} if any required parameter is not provided
  * @openapi operation=getStandardBaselineElement path=/standards/{standardId}/baselines/{baselineId}/elements/{elementId} method=GET
  * @memberof Standard
  */
  getBaselineElement(standardId: UUID, baselineId: UUID, elementId: UUID): Promise<BaselineElementExtended>;
  /**
  * Get element by standard and baseline and element id
  * @summary Get element by standard and baseline and element id
  * @param {UUID} standardId 
  * @param {UUID} baselineId 
  * @param {*} [options] Override http request option.
  * @throws {@link @zerobias-org/types-core-js#ParameterRequiredError} if any required parameter is not provided
  * @openapi operation=getStandardBaselineFilterTree path=/standards/{standardId}/baselines/{baselineId}/filterTree method=GET
  * @memberof Standard
  */
  getBaselineFilterTree(standardId: UUID, baselineId: UUID): Promise<{ [key: string]: StandardFilterTreeNode; }>;
  /**
  * Get element by standard and element id
  * @summary Get element by standard and element id
  * @param {UUID} standardId 
  * @param {UUID} elementId 
  * @param {*} [options] Override http request option.
  * @throws {@link @zerobias-org/types-core-js#ParameterRequiredError} if any required parameter is not provided
  * @openapi operation=getStandardElement path=/standards/{standardId}/elements/{elementId} method=GET
  * @memberof Standard
  */
  getElement(standardId: UUID, elementId: UUID): Promise<ElementExtended>;
  /**
  * list all standard baseline elements
  * @summary list all standard baseline elements
  * @param {UUID} standardId 
  * @param {UUID} baselineId 
  * @param {UUID} [elementTypeId] 
  * @param {string} [search] 
  * @param {SortObject} [sort] Sort object
  * @param {*} [options] Override http request option.
  * @throws {@link @zerobias-org/types-core-js#ParameterRequiredError} if any required parameter is not provided
  * @openapi operation=listStandardBaselineElements path=/standards/{standardId}/baselines/{baselineId}/elements method=GET
  * @memberof Standard
  */
  listBaselineElements(results: PagedResults<BaselineElementExtended>, standardId: UUID, baselineId: UUID, elementTypeId?: UUID, search?: string, sort?: SortObject): Promise<void>;
  /**
  * list all standard baselines
  * @summary list all standard baselines
  * @param {UUID} standardId 
  * @param {string} [search] 
  * @param {SortObject} [sort] Sort object
  * @param {*} [options] Override http request option.
  * @throws {@link @zerobias-org/types-core-js#ParameterRequiredError} if any required parameter is not provided
  * @openapi operation=listStandardBaselines path=/standards/{standardId}/baselines method=GET
  * @memberof Standard
  */
  listBaselines(results: PagedResults<BaselineExtended>, standardId: UUID, search?: string, sort?: SortObject): Promise<void>;
  /**
  * list all standard elements
  * @summary list all standard elements
  * @param {UUID} standardId 
  * @param {UUID} [elementTypeId] 
  * @param {string} [search] 
  * @param {string} [packageCode] 
  * @param {SortObject} [sort] Sort object
  * @param {*} [options] Override http request option.
  * @throws {@link @zerobias-org/types-core-js#ParameterRequiredError} if any required parameter is not provided
  * @openapi operation=listStandardElements path=/standards/{standardId}/elements method=GET
  * @memberof Standard
  */
  listElements(results: PagedResults<ElementExtended>, standardId: UUID, elementTypeId?: UUID, search?: string, packageCode?: string, sort?: SortObject): Promise<void>;
  /**
  * list all standards
  * @summary list all standards
  * @param {StandardType} [standardType] 
  * @param {StandardStatus} [status] 
  * @param {string} [search] 
  * @param {string} [packageCode] 
  * @param {UUID} [vspId] 
  * @param {SortObject} [sort] Sort object
  * @param {*} [options] Override http request option.
  * @throws {@link @zerobias-org/types-core-js#ParameterRequiredError} if any required parameter is not provided
  * @openapi operation=listStandards path=/standards method=GET
  * @memberof Standard
  */
  list(results: PagedResults<StandardExtended>, standardType?: StandardTypeDef, status?: StandardStatusDef, search?: string, packageCode?: string, vspId?: UUID, sort?: SortObject): Promise<void>;
  /**
  * search standard elements
  * @summary search standard elements
  * @param {UUID} standardId 
  * @param {ElementSearchRequestBody} elementSearchRequestBody 
  * @param {SortObject} [sort] Sort object
  * @param {*} [options] Override http request option.
  * @throws {@link @zerobias-org/types-core-js#ParameterRequiredError} if any required parameter is not provided
  * @openapi operation=searchStandardElements path=/standards/{standardId}/elementSearch method=POST
  * @memberof Standard
  */
  searchElements(results: PagedResults<ElementExtended>, standardId: UUID, elementSearchRequestBody: ElementSearchRequestBody, sort?: SortObject): Promise<void>;
  /**
  * search standards
  * @summary search standards
  * @param {SearchStandardBody} searchStandardBody 
  * @param {SortObject} [sort] Sort object
  * @param {*} [options] Override http request option.
  * @throws {@link @zerobias-org/types-core-js#ParameterRequiredError} if any required parameter is not provided
  * @openapi operation=searchStandards path=/standardSearch method=POST
  * @memberof Standard
  */
  search(results: PagedResults<StandardExtended>, searchStandardBody: SearchStandardBody, sort?: SortObject): Promise<void>;
}

export class StandardApiMappingImpl implements StandardApi {
  private producer: StandardProducerApi;
  constructor(producer: StandardProducerApi) {
    this.producer = producer;
  }

  /**
   * Browse standard baseline element
   * @summary Browse standard baseline element
   * @param standardCode 
   * @param baselineCode 
   * @param elementCode 
   * @openapi operation=browseStandardBaselineElement path=/standardBrowser/{standardCode}/{baselineCode}/{elementCode} method=GET
   */
  public async browseStandardBaselineElement(standardCode: string, baselineCode: string, elementCode: string): Promise<BaselineElementExtended> {
    // verify required parameter 'standardCode' is not null or undefined
    if (standardCode === null || standardCode === undefined || standardCode === '') {
      throw new ParameterRequiredError('standardCode');
    }
    // verify required parameter 'baselineCode' is not null or undefined
    if (baselineCode === null || baselineCode === undefined || baselineCode === '') {
      throw new ParameterRequiredError('baselineCode');
    }
    // verify required parameter 'elementCode' is not null or undefined
    if (elementCode === null || elementCode === undefined || elementCode === '') {
      throw new ParameterRequiredError('elementCode');
    }
    return this.producer.browseStandardBaselineElement(standardCode, baselineCode, elementCode);
  }
  /**
   * Browse standard baseline elements
   * @summary Browse standard baseline elements
   * @param standardCode 
   * @param baselineCode 
   * @param pageNumber The requested page. This value is 1-indexed.
   * @param pageSize The number of items in each page of data.
   * @openapi operation=browseStandardBaselineElements path=/standardBrowser/{standardCode}/{baselineCode} method=GET
   */
  public async browseStandardBaselineElements(standardCode: string, baselineCode: string, pageNumber: number = 1, pageSize: number = 50): Promise<PagedResults<BaselineElementExtended>> {
    // verify required parameter 'standardCode' is not null or undefined
    if (standardCode === null || standardCode === undefined || standardCode === '') {
      throw new ParameterRequiredError('standardCode');
    }
    // verify required parameter 'baselineCode' is not null or undefined
    if (baselineCode === null || baselineCode === undefined || baselineCode === '') {
      throw new ParameterRequiredError('baselineCode');
    }
    if (pageNumber) {
      await Int32.parse(pageNumber);
    }
    if (pageSize) {
      await Int32.parse(pageSize);
    }
    const bag = new PagedResults<BaselineElementExtended>();
    bag.pageNumber = pageNumber;
    bag.pageSize = pageSize;
    await this.producer.browseStandardBaselineElements(bag, standardCode, baselineCode);
    if (bag.items === null || bag.items === undefined) {
      throw new UnexpectedError("Producers must return 'items' for PagedResults queries");
    }
    return bag;
  }
  /**
   * Browse standard baselines
   * @summary Browse standard baselines
   * @param standardCode 
   * @param pageNumber The requested page. This value is 1-indexed.
   * @param pageSize The number of items in each page of data.
   * @openapi operation=browseStandardBaselines path=/standardBrowser/{standardCode} method=GET
   */
  public async browseStandardBaselines(standardCode: string, pageNumber: number = 1, pageSize: number = 50): Promise<PagedResults<BaselineExtended>> {
    // verify required parameter 'standardCode' is not null or undefined
    if (standardCode === null || standardCode === undefined || standardCode === '') {
      throw new ParameterRequiredError('standardCode');
    }
    if (pageNumber) {
      await Int32.parse(pageNumber);
    }
    if (pageSize) {
      await Int32.parse(pageSize);
    }
    const bag = new PagedResults<BaselineExtended>();
    bag.pageNumber = pageNumber;
    bag.pageSize = pageSize;
    await this.producer.browseStandardBaselines(bag, standardCode);
    if (bag.items === null || bag.items === undefined) {
      throw new UnexpectedError("Producers must return 'items' for PagedResults queries");
    }
    return bag;
  }
  /**
   * Browse standards
   * @summary Browse standards
   * @param pageNumber The requested page. This value is 1-indexed.
   * @param pageSize The number of items in each page of data.
   * @openapi operation=browseStandards path=/standardBrowser method=GET
   */
  public async browseStandards(pageNumber: number = 1, pageSize: number = 50): Promise<PagedResults<StandardExtended>> {
    if (pageNumber) {
      await Int32.parse(pageNumber);
    }
    if (pageSize) {
      await Int32.parse(pageSize);
    }
    const bag = new PagedResults<StandardExtended>();
    bag.pageNumber = pageNumber;
    bag.pageSize = pageSize;
    await this.producer.browseStandards(bag);
    if (bag.items === null || bag.items === undefined) {
      throw new UnexpectedError("Producers must return 'items' for PagedResults queries");
    }
    return bag;
  }
  /**
   * Get standard by id
   * @summary Get standard by id
   * @param standardId 
   * @openapi operation=getStandard path=/standards/{standardId} method=GET
   */
  public async get(standardId: UUID): Promise<StandardExtended> {
    // verify required parameter 'standardId' is not null or undefined
    if (standardId === null || standardId === undefined) {
      throw new ParameterRequiredError('standardId');
    }
    return this.producer.get(standardId);
  }
  /**
   * Get baseline by standard and baseline id
   * @summary Get baseline by standard and baseline id
   * @param standardId 
   * @param baselineId 
   * @openapi operation=getStandardBaseline path=/standards/{standardId}/baselines/{baselineId} method=GET
   */
  public async getBaseline(standardId: UUID, baselineId: UUID): Promise<BaselineExtended> {
    // verify required parameter 'standardId' is not null or undefined
    if (standardId === null || standardId === undefined) {
      throw new ParameterRequiredError('standardId');
    }
    // verify required parameter 'baselineId' is not null or undefined
    if (baselineId === null || baselineId === undefined) {
      throw new ParameterRequiredError('baselineId');
    }
    return this.producer.getBaseline(standardId, baselineId);
  }
  /**
   * Get element by standard and baseline and element id
   * @summary Get element by standard and baseline and element id
   * @param standardId 
   * @param baselineId 
   * @param elementId 
   * @openapi operation=getStandardBaselineElement path=/standards/{standardId}/baselines/{baselineId}/elements/{elementId} method=GET
   */
  public async getBaselineElement(standardId: UUID, baselineId: UUID, elementId: UUID): Promise<BaselineElementExtended> {
    // verify required parameter 'standardId' is not null or undefined
    if (standardId === null || standardId === undefined) {
      throw new ParameterRequiredError('standardId');
    }
    // verify required parameter 'baselineId' is not null or undefined
    if (baselineId === null || baselineId === undefined) {
      throw new ParameterRequiredError('baselineId');
    }
    // verify required parameter 'elementId' is not null or undefined
    if (elementId === null || elementId === undefined) {
      throw new ParameterRequiredError('elementId');
    }
    return this.producer.getBaselineElement(standardId, baselineId, elementId);
  }
  /**
   * Get element by standard and baseline and element id
   * @summary Get element by standard and baseline and element id
   * @param standardId 
   * @param baselineId 
   * @openapi operation=getStandardBaselineFilterTree path=/standards/{standardId}/baselines/{baselineId}/filterTree method=GET
   */
  public async getBaselineFilterTree(standardId: UUID, baselineId: UUID): Promise<{ [key: string]: StandardFilterTreeNode; }> {
    // verify required parameter 'standardId' is not null or undefined
    if (standardId === null || standardId === undefined) {
      throw new ParameterRequiredError('standardId');
    }
    // verify required parameter 'baselineId' is not null or undefined
    if (baselineId === null || baselineId === undefined) {
      throw new ParameterRequiredError('baselineId');
    }
    return this.producer.getBaselineFilterTree(standardId, baselineId);
  }
  /**
   * Get element by standard and element id
   * @summary Get element by standard and element id
   * @param standardId 
   * @param elementId 
   * @openapi operation=getStandardElement path=/standards/{standardId}/elements/{elementId} method=GET
   */
  public async getElement(standardId: UUID, elementId: UUID): Promise<ElementExtended> {
    // verify required parameter 'standardId' is not null or undefined
    if (standardId === null || standardId === undefined) {
      throw new ParameterRequiredError('standardId');
    }
    // verify required parameter 'elementId' is not null or undefined
    if (elementId === null || elementId === undefined) {
      throw new ParameterRequiredError('elementId');
    }
    return this.producer.getElement(standardId, elementId);
  }
  /**
   * list all standard baseline elements
   * @summary list all standard baseline elements
   * @param standardId 
   * @param baselineId 
   * @param pageNumber The requested page. This value is 1-indexed.
   * @param pageSize The number of items in each page of data.
   * @param elementTypeId 
   * @param search 
   * @param sort Sort object
   * @openapi operation=listStandardBaselineElements path=/standards/{standardId}/baselines/{baselineId}/elements method=GET
   */
  public async listBaselineElements(standardId: UUID, baselineId: UUID, pageNumber: number = 1, pageSize: number = 50, elementTypeId?: UUID, search?: string, sort?: SortObject): Promise<PagedResults<BaselineElementExtended>> {
    // verify required parameter 'standardId' is not null or undefined
    if (standardId === null || standardId === undefined) {
      throw new ParameterRequiredError('standardId');
    }
    // verify required parameter 'baselineId' is not null or undefined
    if (baselineId === null || baselineId === undefined) {
      throw new ParameterRequiredError('baselineId');
    }
    if (pageNumber) {
      await Int32.parse(pageNumber);
    }
    if (pageSize) {
      await Int32.parse(pageSize);
    }
    const bag = new PagedResults<BaselineElementExtended>();
    bag.pageNumber = pageNumber;
    bag.pageSize = pageSize;
    await this.producer.listBaselineElements(bag, standardId, baselineId, elementTypeId, search, sort);
    if (bag.items === null || bag.items === undefined) {
      throw new UnexpectedError("Producers must return 'items' for PagedResults queries");
    }
    return bag;
  }
  /**
   * list all standard baselines
   * @summary list all standard baselines
   * @param standardId 
   * @param pageNumber The requested page. This value is 1-indexed.
   * @param pageSize The number of items in each page of data.
   * @param search 
   * @param sort Sort object
   * @openapi operation=listStandardBaselines path=/standards/{standardId}/baselines method=GET
   */
  public async listBaselines(standardId: UUID, pageNumber: number = 1, pageSize: number = 50, search?: string, sort?: SortObject): Promise<PagedResults<BaselineExtended>> {
    // verify required parameter 'standardId' is not null or undefined
    if (standardId === null || standardId === undefined) {
      throw new ParameterRequiredError('standardId');
    }
    if (pageNumber) {
      await Int32.parse(pageNumber);
    }
    if (pageSize) {
      await Int32.parse(pageSize);
    }
    const bag = new PagedResults<BaselineExtended>();
    bag.pageNumber = pageNumber;
    bag.pageSize = pageSize;
    await this.producer.listBaselines(bag, standardId, search, sort);
    if (bag.items === null || bag.items === undefined) {
      throw new UnexpectedError("Producers must return 'items' for PagedResults queries");
    }
    return bag;
  }
  /**
   * list all standard elements
   * @summary list all standard elements
   * @param standardId 
   * @param pageNumber The requested page. This value is 1-indexed.
   * @param pageSize The number of items in each page of data.
   * @param elementTypeId 
   * @param search 
   * @param packageCode 
   * @param sort Sort object
   * @openapi operation=listStandardElements path=/standards/{standardId}/elements method=GET
   */
  public async listElements(standardId: UUID, pageNumber: number = 1, pageSize: number = 50, elementTypeId?: UUID, search?: string, packageCode?: string, sort?: SortObject): Promise<PagedResults<ElementExtended>> {
    // verify required parameter 'standardId' is not null or undefined
    if (standardId === null || standardId === undefined) {
      throw new ParameterRequiredError('standardId');
    }
    if (pageNumber) {
      await Int32.parse(pageNumber);
    }
    if (pageSize) {
      await Int32.parse(pageSize);
    }
    const bag = new PagedResults<ElementExtended>();
    bag.pageNumber = pageNumber;
    bag.pageSize = pageSize;
    await this.producer.listElements(bag, standardId, elementTypeId, search, packageCode, sort);
    if (bag.items === null || bag.items === undefined) {
      throw new UnexpectedError("Producers must return 'items' for PagedResults queries");
    }
    return bag;
  }
  /**
   * list all standards
   * @summary list all standards
   * @param pageNumber The requested page. This value is 1-indexed.
   * @param pageSize The number of items in each page of data.
   * @param standardType 
   * @param status 
   * @param search 
   * @param packageCode 
   * @param vspId 
   * @param sort Sort object
   * @openapi operation=listStandards path=/standards method=GET
   */
  public async list(pageNumber: number = 1, pageSize: number = 50, standardType?: StandardTypeDef, status?: StandardStatusDef, search?: string, packageCode?: string, vspId?: UUID, sort?: SortObject): Promise<PagedResults<StandardExtended>> {
    if (pageNumber) {
      await Int32.parse(pageNumber);
    }
    if (pageSize) {
      await Int32.parse(pageSize);
    }
    const bag = new PagedResults<StandardExtended>();
    bag.pageNumber = pageNumber;
    bag.pageSize = pageSize;
    await this.producer.list(bag, standardType, status, search, packageCode, vspId, sort);
    if (bag.items === null || bag.items === undefined) {
      throw new UnexpectedError("Producers must return 'items' for PagedResults queries");
    }
    return bag;
  }
  /**
   * search standard elements
   * @summary search standard elements
   * @param standardId 
   * @param elementSearchRequestBody 
   * @param pageNumber The requested page. This value is 1-indexed.
   * @param pageSize The number of items in each page of data.
   * @param sort Sort object
   * @openapi operation=searchStandardElements path=/standards/{standardId}/elementSearch method=POST
   */
  public async searchElements(standardId: UUID, elementSearchRequestBody: ElementSearchRequestBody, pageNumber: number = 1, pageSize: number = 50, sort?: SortObject): Promise<PagedResults<ElementExtended>> {
    // verify required parameter 'standardId' is not null or undefined
    if (standardId === null || standardId === undefined) {
      throw new ParameterRequiredError('standardId');
    }
    // verify required parameter 'elementSearchRequestBody' is not null or undefined
    if (elementSearchRequestBody === null || elementSearchRequestBody === undefined) {
      throw new ParameterRequiredError('elementSearchRequestBody');
    }
    if (pageNumber) {
      await Int32.parse(pageNumber);
    }
    if (pageSize) {
      await Int32.parse(pageSize);
    }
    const bag = new PagedResults<ElementExtended>();
    bag.pageNumber = pageNumber;
    bag.pageSize = pageSize;
    await this.producer.searchElements(bag, standardId, elementSearchRequestBody, sort);
    if (bag.items === null || bag.items === undefined) {
      throw new UnexpectedError("Producers must return 'items' for PagedResults queries");
    }
    return bag;
  }
  /**
   * search standards
   * @summary search standards
   * @param searchStandardBody 
   * @param pageNumber The requested page. This value is 1-indexed.
   * @param pageSize The number of items in each page of data.
   * @param sort Sort object
   * @openapi operation=searchStandards path=/standardSearch method=POST
   */
  public async search(searchStandardBody: SearchStandardBody, pageNumber: number = 1, pageSize: number = 50, sort?: SortObject): Promise<PagedResults<StandardExtended>> {
    // verify required parameter 'searchStandardBody' is not null or undefined
    if (searchStandardBody === null || searchStandardBody === undefined) {
      throw new ParameterRequiredError('searchStandardBody');
    }
    if (pageNumber) {
      await Int32.parse(pageNumber);
    }
    if (pageSize) {
      await Int32.parse(pageSize);
    }
    const bag = new PagedResults<StandardExtended>();
    bag.pageNumber = pageNumber;
    bag.pageSize = pageSize;
    await this.producer.search(bag, searchStandardBody, sort);
    if (bag.items === null || bag.items === undefined) {
      throw new UnexpectedError("Producers must return 'items' for PagedResults queries");
    }
    return bag;
  }
}

/**
 * Wrap producer with mapping implementation
 */
export function wrapStandardProducer(producer: StandardProducerApi): StandardApi {
  return new StandardApiMappingImpl(producer);
}

/**
 * StandardApiHttpImpl - Direct HTTP implementation
 *
 * Makes direct HTTP calls to the API using Axios.
 * Used by SDK clients for platform service access.
 */
export class StandardApiHttpImpl implements StandardProducerApi {
  private client: AxiosInstance;
  private headers: Record<string, string>;

  constructor(client: AxiosInstance, headers: Record<string, string> = {}) {
    this.client = client;
    this.headers = headers;
  }

  async browseStandardBaselineElement(standardCode: string, baselineCode: string, elementCode: string): Promise<BaselineElementExtended> {
  const _queryParams = {
      
  };
  const _bodyParams = {
      
  };
  let _path = '/standardBrowser/{standardCode}/{baselineCode}/{elementCode}';
  _path = _path.replace('{standardCode}', encodeURIComponent(String(standardCode)));
  _path = _path.replace('{baselineCode}', encodeURIComponent(String(baselineCode)));
  _path = _path.replace('{elementCode}', encodeURIComponent(String(elementCode)));
  return this.client.get(
    _path,
    { params: _queryParams })
    .then((response) => {
      // BaseApiClient uses validateStatus: () => true, so we must check status manually
      if (response.status >= 400) {
        throw CoreError.deserialize(response.data);
      }
      return ObjectSerializer.deserialize(response.data, 'BaselineElementExtended')
    })
    .catch((error) => {
      if (error.data) {
        throw CoreError.deserialize(error.data);
      } else {
        throw error;
      }
    });
  }
  async browseStandardBaselineElements(results: PagedResults<BaselineElementExtended>, standardCode: string, baselineCode: string): Promise<void> {
  const _body = {
      standardCode,baselineCode,
  };
  let _path = '/standardBrowser/{standardCode}/{baselineCode}';
  _path = _path.replace('{standardCode}', encodeURIComponent(String(standardCode)));
  _path = _path.replace('{baselineCode}', encodeURIComponent(String(baselineCode)));
  return this.client.get(
    _path,
    {
      params: {
        ..._body,
        pageNumber: results.pageNumber,
        pageSize: results.pageSize,
      }
    })
    .then((response) => {
      // BaseApiClient uses validateStatus: () => true, so we must check status manually
      if (response.status >= 400) {
        throw CoreError.deserialize(response.data);
      }
      results.items = ObjectSerializer.deserialize(response.data, 'Array<BaselineElementExtended>');
      results.count = response.headers.count ? Number(response.headers.count) : -1;
      results.pageToken = response.headers.pagetoken ?? response.headers.pageToken;
      results.headers = this.headers;
      results.baseUrl = new URL(`${this.client.getUri()}/standardBrowser/{standardCode}/{baselineCode}`);
      results.httpMethod = HttpMethod.Get;
      results.body = _body;
      results.mapper = (obj) => ObjectSerializer.deserialize(obj, 'BaselineElementExtended');
    })
    .catch((error) => {
      if (error.data) {
        throw CoreError.deserialize(error.data);
      } else {
        throw error;
      }
    });
  }
  async browseStandardBaselines(results: PagedResults<BaselineExtended>, standardCode: string): Promise<void> {
  const _body = {
      standardCode,
  };
  let _path = '/standardBrowser/{standardCode}';
  _path = _path.replace('{standardCode}', encodeURIComponent(String(standardCode)));
  return this.client.get(
    _path,
    {
      params: {
        ..._body,
        pageNumber: results.pageNumber,
        pageSize: results.pageSize,
      }
    })
    .then((response) => {
      // BaseApiClient uses validateStatus: () => true, so we must check status manually
      if (response.status >= 400) {
        throw CoreError.deserialize(response.data);
      }
      results.items = ObjectSerializer.deserialize(response.data, 'Array<BaselineExtended>');
      results.count = response.headers.count ? Number(response.headers.count) : -1;
      results.pageToken = response.headers.pagetoken ?? response.headers.pageToken;
      results.headers = this.headers;
      results.baseUrl = new URL(`${this.client.getUri()}/standardBrowser/{standardCode}`);
      results.httpMethod = HttpMethod.Get;
      results.body = _body;
      results.mapper = (obj) => ObjectSerializer.deserialize(obj, 'BaselineExtended');
    })
    .catch((error) => {
      if (error.data) {
        throw CoreError.deserialize(error.data);
      } else {
        throw error;
      }
    });
  }
  async browseStandards(results: PagedResults<StandardExtended>): Promise<void> {
  const _body = {
      
  };
  let _path = '/standardBrowser';
  return this.client.get(
    _path,
    {
      params: {
        ..._body,
        pageNumber: results.pageNumber,
        pageSize: results.pageSize,
      }
    })
    .then((response) => {
      // BaseApiClient uses validateStatus: () => true, so we must check status manually
      if (response.status >= 400) {
        throw CoreError.deserialize(response.data);
      }
      results.items = ObjectSerializer.deserialize(response.data, 'Array<StandardExtended>');
      results.count = response.headers.count ? Number(response.headers.count) : -1;
      results.pageToken = response.headers.pagetoken ?? response.headers.pageToken;
      results.headers = this.headers;
      results.baseUrl = new URL(`${this.client.getUri()}/standardBrowser`);
      results.httpMethod = HttpMethod.Get;
      results.body = _body;
      results.mapper = (obj) => ObjectSerializer.deserialize(obj, 'StandardExtended');
    })
    .catch((error) => {
      if (error.data) {
        throw CoreError.deserialize(error.data);
      } else {
        throw error;
      }
    });
  }
  async get(standardId: UUID): Promise<StandardExtended> {
  const _queryParams = {
      
  };
  const _bodyParams = {
      
  };
  let _path = '/standards/{standardId}';
  _path = _path.replace('{standardId}', encodeURIComponent(String(standardId)));
  return this.client.get(
    _path,
    { params: _queryParams })
    .then((response) => {
      // BaseApiClient uses validateStatus: () => true, so we must check status manually
      if (response.status >= 400) {
        throw CoreError.deserialize(response.data);
      }
      return ObjectSerializer.deserialize(response.data, 'StandardExtended')
    })
    .catch((error) => {
      if (error.data) {
        throw CoreError.deserialize(error.data);
      } else {
        throw error;
      }
    });
  }
  async getBaseline(standardId: UUID, baselineId: UUID): Promise<BaselineExtended> {
  const _queryParams = {
      
  };
  const _bodyParams = {
      
  };
  let _path = '/standards/{standardId}/baselines/{baselineId}';
  _path = _path.replace('{standardId}', encodeURIComponent(String(standardId)));
  _path = _path.replace('{baselineId}', encodeURIComponent(String(baselineId)));
  return this.client.get(
    _path,
    { params: _queryParams })
    .then((response) => {
      // BaseApiClient uses validateStatus: () => true, so we must check status manually
      if (response.status >= 400) {
        throw CoreError.deserialize(response.data);
      }
      return ObjectSerializer.deserialize(response.data, 'BaselineExtended')
    })
    .catch((error) => {
      if (error.data) {
        throw CoreError.deserialize(error.data);
      } else {
        throw error;
      }
    });
  }
  async getBaselineElement(standardId: UUID, baselineId: UUID, elementId: UUID): Promise<BaselineElementExtended> {
  const _queryParams = {
      
  };
  const _bodyParams = {
      
  };
  let _path = '/standards/{standardId}/baselines/{baselineId}/elements/{elementId}';
  _path = _path.replace('{standardId}', encodeURIComponent(String(standardId)));
  _path = _path.replace('{baselineId}', encodeURIComponent(String(baselineId)));
  _path = _path.replace('{elementId}', encodeURIComponent(String(elementId)));
  return this.client.get(
    _path,
    { params: _queryParams })
    .then((response) => {
      // BaseApiClient uses validateStatus: () => true, so we must check status manually
      if (response.status >= 400) {
        throw CoreError.deserialize(response.data);
      }
      return ObjectSerializer.deserialize(response.data, 'BaselineElementExtended')
    })
    .catch((error) => {
      if (error.data) {
        throw CoreError.deserialize(error.data);
      } else {
        throw error;
      }
    });
  }
  async getBaselineFilterTree(standardId: UUID, baselineId: UUID): Promise<{ [key: string]: StandardFilterTreeNode; }> {
  const _queryParams = {
      
  };
  const _bodyParams = {
      
  };
  let _path = '/standards/{standardId}/baselines/{baselineId}/filterTree';
  _path = _path.replace('{standardId}', encodeURIComponent(String(standardId)));
  _path = _path.replace('{baselineId}', encodeURIComponent(String(baselineId)));
  return this.client.get(
    _path,
    { params: _queryParams })
    .then((response) => {
      // BaseApiClient uses validateStatus: () => true, so we must check status manually
      if (response.status >= 400) {
        throw CoreError.deserialize(response.data);
      }
      return ObjectSerializer.deserialize(response.data, '{ [key: string]: StandardFilterTreeNode; }')
    })
    .catch((error) => {
      if (error.data) {
        throw CoreError.deserialize(error.data);
      } else {
        throw error;
      }
    });
  }
  async getElement(standardId: UUID, elementId: UUID): Promise<ElementExtended> {
  const _queryParams = {
      
  };
  const _bodyParams = {
      
  };
  let _path = '/standards/{standardId}/elements/{elementId}';
  _path = _path.replace('{standardId}', encodeURIComponent(String(standardId)));
  _path = _path.replace('{elementId}', encodeURIComponent(String(elementId)));
  return this.client.get(
    _path,
    { params: _queryParams })
    .then((response) => {
      // BaseApiClient uses validateStatus: () => true, so we must check status manually
      if (response.status >= 400) {
        throw CoreError.deserialize(response.data);
      }
      return ObjectSerializer.deserialize(response.data, 'ElementExtended')
    })
    .catch((error) => {
      if (error.data) {
        throw CoreError.deserialize(error.data);
      } else {
        throw error;
      }
    });
  }
  async listBaselineElements(results: PagedResults<BaselineElementExtended>, standardId: UUID, baselineId: UUID, elementTypeId?: UUID, search?: string, sort?: SortObject): Promise<void> {
  const _body = {
      standardId,baselineId,elementTypeId,search,sort,
  };
  let _path = '/standards/{standardId}/baselines/{baselineId}/elements';
  _path = _path.replace('{standardId}', encodeURIComponent(String(standardId)));
  _path = _path.replace('{baselineId}', encodeURIComponent(String(baselineId)));
  return this.client.get(
    _path,
    {
      params: {
        ..._body,
        pageNumber: results.pageNumber,
        pageSize: results.pageSize,
      }
    })
    .then((response) => {
      // BaseApiClient uses validateStatus: () => true, so we must check status manually
      if (response.status >= 400) {
        throw CoreError.deserialize(response.data);
      }
      results.items = ObjectSerializer.deserialize(response.data, 'Array<BaselineElementExtended>');
      results.count = response.headers.count ? Number(response.headers.count) : -1;
      results.pageToken = response.headers.pagetoken ?? response.headers.pageToken;
      results.headers = this.headers;
      results.baseUrl = new URL(`${this.client.getUri()}/standards/{standardId}/baselines/{baselineId}/elements`);
      results.httpMethod = HttpMethod.Get;
      results.body = _body;
      results.mapper = (obj) => ObjectSerializer.deserialize(obj, 'BaselineElementExtended');
    })
    .catch((error) => {
      if (error.data) {
        throw CoreError.deserialize(error.data);
      } else {
        throw error;
      }
    });
  }
  async listBaselines(results: PagedResults<BaselineExtended>, standardId: UUID, search?: string, sort?: SortObject): Promise<void> {
  const _body = {
      standardId,search,sort,
  };
  let _path = '/standards/{standardId}/baselines';
  _path = _path.replace('{standardId}', encodeURIComponent(String(standardId)));
  return this.client.get(
    _path,
    {
      params: {
        ..._body,
        pageNumber: results.pageNumber,
        pageSize: results.pageSize,
      }
    })
    .then((response) => {
      // BaseApiClient uses validateStatus: () => true, so we must check status manually
      if (response.status >= 400) {
        throw CoreError.deserialize(response.data);
      }
      results.items = ObjectSerializer.deserialize(response.data, 'Array<BaselineExtended>');
      results.count = response.headers.count ? Number(response.headers.count) : -1;
      results.pageToken = response.headers.pagetoken ?? response.headers.pageToken;
      results.headers = this.headers;
      results.baseUrl = new URL(`${this.client.getUri()}/standards/{standardId}/baselines`);
      results.httpMethod = HttpMethod.Get;
      results.body = _body;
      results.mapper = (obj) => ObjectSerializer.deserialize(obj, 'BaselineExtended');
    })
    .catch((error) => {
      if (error.data) {
        throw CoreError.deserialize(error.data);
      } else {
        throw error;
      }
    });
  }
  async listElements(results: PagedResults<ElementExtended>, standardId: UUID, elementTypeId?: UUID, search?: string, packageCode?: string, sort?: SortObject): Promise<void> {
  const _body = {
      standardId,elementTypeId,search,packageCode,sort,
  };
  let _path = '/standards/{standardId}/elements';
  _path = _path.replace('{standardId}', encodeURIComponent(String(standardId)));
  return this.client.get(
    _path,
    {
      params: {
        ..._body,
        pageNumber: results.pageNumber,
        pageSize: results.pageSize,
      }
    })
    .then((response) => {
      // BaseApiClient uses validateStatus: () => true, so we must check status manually
      if (response.status >= 400) {
        throw CoreError.deserialize(response.data);
      }
      results.items = ObjectSerializer.deserialize(response.data, 'Array<ElementExtended>');
      results.count = response.headers.count ? Number(response.headers.count) : -1;
      results.pageToken = response.headers.pagetoken ?? response.headers.pageToken;
      results.headers = this.headers;
      results.baseUrl = new URL(`${this.client.getUri()}/standards/{standardId}/elements`);
      results.httpMethod = HttpMethod.Get;
      results.body = _body;
      results.mapper = (obj) => ObjectSerializer.deserialize(obj, 'ElementExtended');
    })
    .catch((error) => {
      if (error.data) {
        throw CoreError.deserialize(error.data);
      } else {
        throw error;
      }
    });
  }
  async list(results: PagedResults<StandardExtended>, standardType?: StandardTypeDef, status?: StandardStatusDef, search?: string, packageCode?: string, vspId?: UUID, sort?: SortObject): Promise<void> {
  const _body = {
      standardType,status,search,packageCode,vspId,sort,
  };
  let _path = '/standards';
  return this.client.get(
    _path,
    {
      params: {
        ..._body,
        pageNumber: results.pageNumber,
        pageSize: results.pageSize,
      }
    })
    .then((response) => {
      // BaseApiClient uses validateStatus: () => true, so we must check status manually
      if (response.status >= 400) {
        throw CoreError.deserialize(response.data);
      }
      results.items = ObjectSerializer.deserialize(response.data, 'Array<StandardExtended>');
      results.count = response.headers.count ? Number(response.headers.count) : -1;
      results.pageToken = response.headers.pagetoken ?? response.headers.pageToken;
      results.headers = this.headers;
      results.baseUrl = new URL(`${this.client.getUri()}/standards`);
      results.httpMethod = HttpMethod.Get;
      results.body = _body;
      results.mapper = (obj) => ObjectSerializer.deserialize(obj, 'StandardExtended');
    })
    .catch((error) => {
      if (error.data) {
        throw CoreError.deserialize(error.data);
      } else {
        throw error;
      }
    });
  }
  async searchElements(results: PagedResults<ElementExtended>, standardId: UUID, elementSearchRequestBody: ElementSearchRequestBody, sort?: SortObject): Promise<void> {
  const _body = {
      standardId,elementSearchRequestBody,sort,
  };
  let _path = '/standards/{standardId}/elementSearch';
  _path = _path.replace('{standardId}', encodeURIComponent(String(standardId)));
  return this.client.post(
    _path,
    {
      ..._body,
      pageNumber: results.pageNumber,
      pageSize: results.pageSize,
    })
    .then((response) => {
      // BaseApiClient uses validateStatus: () => true, so we must check status manually
      if (response.status >= 400) {
        throw CoreError.deserialize(response.data);
      }
      results.items = ObjectSerializer.deserialize(response.data, 'Array<ElementExtended>');
      results.count = response.headers.count ? Number(response.headers.count) : -1;
      results.pageToken = response.headers.pagetoken ?? response.headers.pageToken;
      results.headers = this.headers;
      results.baseUrl = new URL(`${this.client.getUri()}/standards/{standardId}/elementSearch`);
      results.httpMethod = HttpMethod.Post;
      results.body = _body;
      results.mapper = (obj) => ObjectSerializer.deserialize(obj, 'ElementExtended');
    })
    .catch((error) => {
      if (error.data) {
        throw CoreError.deserialize(error.data);
      } else {
        throw error;
      }
    });
  }
  async search(results: PagedResults<StandardExtended>, searchStandardBody: SearchStandardBody, sort?: SortObject): Promise<void> {
  const _body = {
      searchStandardBody,sort,
  };
  let _path = '/standardSearch';
  return this.client.post(
    _path,
    {
      ..._body,
      pageNumber: results.pageNumber,
      pageSize: results.pageSize,
    })
    .then((response) => {
      // BaseApiClient uses validateStatus: () => true, so we must check status manually
      if (response.status >= 400) {
        throw CoreError.deserialize(response.data);
      }
      results.items = ObjectSerializer.deserialize(response.data, 'Array<StandardExtended>');
      results.count = response.headers.count ? Number(response.headers.count) : -1;
      results.pageToken = response.headers.pagetoken ?? response.headers.pageToken;
      results.headers = this.headers;
      results.baseUrl = new URL(`${this.client.getUri()}/standardSearch`);
      results.httpMethod = HttpMethod.Post;
      results.body = _body;
      results.mapper = (obj) => ObjectSerializer.deserialize(obj, 'StandardExtended');
    })
    .catch((error) => {
      if (error.data) {
        throw CoreError.deserialize(error.data);
      } else {
        throw error;
      }
    });
  }
}
