/* eslint-disable */
// ===============================================
// This file is autogenerated - Please do not edit
// ===============================================
import { AxiosInstance } from 'axios';
import { CatalogPublishStatusEnumDef, NewProduct, NewProductComponent, NewProductEdition, PatchComplianceFeaturesBody, PatchComponentsBody, PatchEditionsBody, PatchProduct, PatchProductComponent, PatchProductEdition, PatchSegmentsBody, Product, ProductComponentExtended, ProductComponentVersionExtended, ProductEditionExtended, ProductEditionVersionExtended, ProductExtended, ProductExtendedGet, ProductVersionExtended, ProductVersionExtendedGet, SuggestProductOperationBody, Task, UpdateProduct, UpdateProductComponent, UpdateProductEdition } from '../model/index.js';
import { URL, EnumValue, IllegalArgumentError, PagedResults, Int32, UUID, CoreError, ParameterRequiredError, UnexpectedError, HttpMethod } from '@zerobias-org/types-core-js';
import { RequestFile, ObjectSerializer } from '../model/index.js';

export namespace ProductApi {
}

/**
 * ProductApi - interface
 * @export
 * @interface ProductApi
 */
export interface ProductApi {
  /**
   * Creates a new product with version
   * @summary Creates a new product with version
   * @param {NewProduct} newProduct 
   * @param {*} [options] Override http request option.
   * @throws {@link @zerobias-org/types-core-js#ParameterRequiredError} if any required parameter is not provided
   * @example
   * ```typescript
   * const result = await api.create(null);
   * ```
   * @openapi operation=createProduct path=/catalog/products method=POST
   * @memberof ProductApi
   */
  create(newProduct: NewProduct): Promise<ProductExtendedGet>;

  /**
   * Creates a new product component with version
   * @summary Creates a new product component with version
   * @param {UUID} productId 
   * @param {NewProductComponent} newProductComponent 
   * @param {*} [options] Override http request option.
   * @throws {@link @zerobias-org/types-core-js#ParameterRequiredError} if any required parameter is not provided
   * @example
   * ```typescript
   * const result = await api.createComponent('00000000-0000-0000-0000-000000000000', null);
   * ```
   * @openapi operation=createProductComponent path=/catalog/products/{productId}/components method=POST
   * @memberof ProductApi
   */
  createComponent(productId: UUID, newProductComponent: NewProductComponent): Promise<ProductComponentExtended>;

  /**
   * Creates a new product edition with version
   * @summary Creates a new product edition with version
   * @param {UUID} productId 
   * @param {NewProductEdition} newProductEdition 
   * @param {*} [options] Override http request option.
   * @throws {@link @zerobias-org/types-core-js#ParameterRequiredError} if any required parameter is not provided
   * @example
   * ```typescript
   * const result = await api.createEdition('00000000-0000-0000-0000-000000000000', null);
   * ```
   * @openapi operation=createProductEdition path=/catalog/products/{productId}/editions method=POST
   * @memberof ProductApi
   */
  createEdition(productId: UUID, newProductEdition: NewProductEdition): Promise<ProductEditionExtended>;

  /**
   * Delete a product
   * @summary Delete a product
   * @param {UUID} productId 
   * @param {*} [options] Override http request option.
   * @throws {@link @zerobias-org/types-core-js#ParameterRequiredError} if any required parameter is not provided
   * @example
   * ```typescript
   * const result = await api.delete('00000000-0000-0000-0000-000000000000');
   * ```
   * @openapi operation=deleteProduct path=/catalog/products/{productId} method=DELETE
   * @memberof ProductApi
   */
  delete(productId: UUID): Promise<void>;

  /**
   * Delete a product component
   * @summary Delete a product component
   * @param {UUID} productId 
   * @param {UUID} productComponentId 
   * @param {*} [options] Override http request option.
   * @throws {@link @zerobias-org/types-core-js#ParameterRequiredError} if any required parameter is not provided
   * @example
   * ```typescript
   * const result = await api.deleteComponent('00000000-0000-0000-0000-000000000000', '00000000-0000-0000-0000-000000000000');
   * ```
   * @openapi operation=deleteProductComponent path=/catalog/products/{productId}/components/{productComponentId} method=DELETE
   * @memberof ProductApi
   */
  deleteComponent(productId: UUID, productComponentId: UUID): Promise<void>;

  /**
   * Delete a product component version
   * @summary Delete a product component version
   * @param {UUID} productId 
   * @param {UUID} productComponentId 
   * @param {UUID} versionId 
   * @param {*} [options] Override http request option.
   * @throws {@link @zerobias-org/types-core-js#ParameterRequiredError} if any required parameter is not provided
   * @example
   * ```typescript
   * const result = await api.deleteComponentVersion('00000000-0000-0000-0000-000000000000', '00000000-0000-0000-0000-000000000000', '00000000-0000-0000-0000-000000000000');
   * ```
   * @openapi operation=deleteProductComponentVersion path=/catalog/products/{productId}/components/{productComponentId}/versions/{versionId} method=DELETE
   * @memberof ProductApi
   */
  deleteComponentVersion(productId: UUID, productComponentId: UUID, versionId: UUID): Promise<void>;

  /**
   * Delete a product edition
   * @summary Delete a product edition
   * @param {UUID} productId 
   * @param {UUID} productEditionId 
   * @param {*} [options] Override http request option.
   * @throws {@link @zerobias-org/types-core-js#ParameterRequiredError} if any required parameter is not provided
   * @example
   * ```typescript
   * const result = await api.deleteEdition('00000000-0000-0000-0000-000000000000', '00000000-0000-0000-0000-000000000000');
   * ```
   * @openapi operation=deleteProductEdition path=/catalog/products/{productId}/editions/{productEditionId} method=DELETE
   * @memberof ProductApi
   */
  deleteEdition(productId: UUID, productEditionId: UUID): Promise<void>;

  /**
   * Delete a product edition version
   * @summary Delete a product edition version
   * @param {UUID} productId 
   * @param {UUID} productEditionId 
   * @param {UUID} versionId 
   * @param {*} [options] Override http request option.
   * @throws {@link @zerobias-org/types-core-js#ParameterRequiredError} if any required parameter is not provided
   * @example
   * ```typescript
   * const result = await api.deleteEditionVersion('00000000-0000-0000-0000-000000000000', '00000000-0000-0000-0000-000000000000', '00000000-0000-0000-0000-000000000000');
   * ```
   * @openapi operation=deleteProductEditionVersion path=/catalog/products/{productId}/editions/{productEditionId}/versions/{versionId} method=DELETE
   * @memberof ProductApi
   */
  deleteEditionVersion(productId: UUID, productEditionId: UUID, versionId: UUID): Promise<void>;

  /**
   * Delete a product version
   * @summary Delete a product version
   * @param {UUID} productId 
   * @param {UUID} versionId 
   * @param {*} [options] Override http request option.
   * @throws {@link @zerobias-org/types-core-js#ParameterRequiredError} if any required parameter is not provided
   * @example
   * ```typescript
   * const result = await api.deleteVersion('00000000-0000-0000-0000-000000000000', '00000000-0000-0000-0000-000000000000');
   * ```
   * @openapi operation=deleteProductVersion path=/catalog/products/{productId}/versions/{versionId} method=DELETE
   * @memberof ProductApi
   */
  deleteVersion(productId: UUID, versionId: UUID): Promise<void>;

  /**
   * Retrieves a catalog product by its cpe string
   * @summary Retrieves a catalog product by its cpe string
   * @param {string} cpe The product cpe &#x60;vendor:code&#x60; id, or a cpe full version string
   * @param {*} [options] Override http request option.
   * @throws {@link @zerobias-org/types-core-js#ParameterRequiredError} if any required parameter is not provided
   * @example
   * ```typescript
   * const result = await api.getByCpe('cpe');
   * ```
   * @openapi operation=getByCpe path=/catalog/cpes/{cpe} method=GET
   * @memberof ProductApi
   */
  getByCpe(cpe: string): Promise<Product>;

  /**
   * Get specific product
   * @summary Get specific product
   * @param {UUID} productId 
   * @param {*} [options] Override http request option.
   * @throws {@link @zerobias-org/types-core-js#ParameterRequiredError} if any required parameter is not provided
   * @example
   * ```typescript
   * const result = await api.get('00000000-0000-0000-0000-000000000000');
   * ```
   * @openapi operation=getProduct path=/catalog/products/{productId} method=GET
   * @memberof ProductApi
   */
  get(productId: UUID): Promise<ProductExtendedGet>;

  /**
   * Get specific product component
   * @summary Get specific product component
   * @param {UUID} productId 
   * @param {UUID} productComponentId 
   * @param {*} [options] Override http request option.
   * @throws {@link @zerobias-org/types-core-js#ParameterRequiredError} if any required parameter is not provided
   * @example
   * ```typescript
   * const result = await api.getComponent('00000000-0000-0000-0000-000000000000', '00000000-0000-0000-0000-000000000000');
   * ```
   * @openapi operation=getProductComponent path=/catalog/products/{productId}/components/{productComponentId} method=GET
   * @memberof ProductApi
   */
  getComponent(productId: UUID, productComponentId: UUID): Promise<ProductComponentExtended>;

  /**
   * Get specific product component version
   * @summary Get specific product component version
   * @param {UUID} productId 
   * @param {UUID} productComponentId 
   * @param {UUID} versionId 
   * @param {*} [options] Override http request option.
   * @throws {@link @zerobias-org/types-core-js#ParameterRequiredError} if any required parameter is not provided
   * @example
   * ```typescript
   * const result = await api.getComponentVersion('00000000-0000-0000-0000-000000000000', '00000000-0000-0000-0000-000000000000', '00000000-0000-0000-0000-000000000000');
   * ```
   * @openapi operation=getProductComponentVersion path=/catalog/products/{productId}/components/{productComponentId}/versions/{versionId} method=GET
   * @memberof ProductApi
   */
  getComponentVersion(productId: UUID, productComponentId: UUID, versionId: UUID): Promise<ProductComponentVersionExtended>;

  /**
   * Get specific product component version
   * @summary Get specific product component version
   * @param {UUID} productComponentVersionId 
   * @param {*} [options] Override http request option.
   * @throws {@link @zerobias-org/types-core-js#ParameterRequiredError} if any required parameter is not provided
   * @example
   * ```typescript
   * const result = await api.getProductComponentVersionDirect('00000000-0000-0000-0000-000000000000');
   * ```
   * @openapi operation=getProductComponentVersionDirect path=/catalog/productComponentVersions/{productComponentVersionId} method=GET
   * @memberof ProductApi
   */
  getProductComponentVersionDirect(productComponentVersionId: UUID): Promise<ProductComponentVersionExtended>;

  /**
   * Get specific product edition
   * @summary Get specific product edition
   * @param {UUID} productId 
   * @param {UUID} productEditionId 
   * @param {*} [options] Override http request option.
   * @throws {@link @zerobias-org/types-core-js#ParameterRequiredError} if any required parameter is not provided
   * @example
   * ```typescript
   * const result = await api.getEdition('00000000-0000-0000-0000-000000000000', '00000000-0000-0000-0000-000000000000');
   * ```
   * @openapi operation=getProductEdition path=/catalog/products/{productId}/editions/{productEditionId} method=GET
   * @memberof ProductApi
   */
  getEdition(productId: UUID, productEditionId: UUID): Promise<ProductEditionExtended>;

  /**
   * Get specific product edition version
   * @summary Get specific product edition version
   * @param {UUID} productId 
   * @param {UUID} productEditionId 
   * @param {UUID} versionId 
   * @param {*} [options] Override http request option.
   * @throws {@link @zerobias-org/types-core-js#ParameterRequiredError} if any required parameter is not provided
   * @example
   * ```typescript
   * const result = await api.getEditionVersion('00000000-0000-0000-0000-000000000000', '00000000-0000-0000-0000-000000000000', '00000000-0000-0000-0000-000000000000');
   * ```
   * @openapi operation=getProductEditionVersion path=/catalog/products/{productId}/editions/{productEditionId}/versions/{versionId} method=GET
   * @memberof ProductApi
   */
  getEditionVersion(productId: UUID, productEditionId: UUID, versionId: UUID): Promise<ProductEditionVersionExtended>;

  /**
   * Get specific product edition version
   * @summary Get specific product edition version
   * @param {UUID} productEditionVersionId 
   * @param {*} [options] Override http request option.
   * @throws {@link @zerobias-org/types-core-js#ParameterRequiredError} if any required parameter is not provided
   * @example
   * ```typescript
   * const result = await api.getProductEditionVersionDirect('00000000-0000-0000-0000-000000000000');
   * ```
   * @openapi operation=getProductEditionVersionDirect path=/catalog/productEditionVersions/{productEditionVersionId} method=GET
   * @memberof ProductApi
   */
  getProductEditionVersionDirect(productEditionVersionId: UUID): Promise<ProductEditionVersionExtended>;

  /**
   * Get specific product version
   * @summary Get specific product version
   * @param {UUID} productId 
   * @param {UUID} versionId 
   * @param {*} [options] Override http request option.
   * @throws {@link @zerobias-org/types-core-js#ParameterRequiredError} if any required parameter is not provided
   * @example
   * ```typescript
   * const result = await api.getVersion('00000000-0000-0000-0000-000000000000', '00000000-0000-0000-0000-000000000000');
   * ```
   * @openapi operation=getProductVersion path=/catalog/products/{productId}/versions/{versionId} method=GET
   * @memberof ProductApi
   */
  getVersion(productId: UUID, versionId: UUID): Promise<ProductVersionExtendedGet>;

  /**
   * Get specific product version
   * @summary Get specific product version
   * @param {UUID} productVersionId 
   * @param {*} [options] Override http request option.
   * @throws {@link @zerobias-org/types-core-js#ParameterRequiredError} if any required parameter is not provided
   * @example
   * ```typescript
   * const result = await api.getProductVersionDirect('00000000-0000-0000-0000-000000000000');
   * ```
   * @openapi operation=getProductVersionDirect path=/catalog/productVersions/{productVersionId} method=GET
   * @memberof ProductApi
   */
  getProductVersionDirect(productVersionId: UUID): Promise<ProductVersionExtendedGet>;

  /**
   * List product Cpe Version strings
   * @summary List product Cpe Version strings
   * @param {UUID} id The product id
   * @param {number} [pageNumber] The requested page. This value is 1-indexed.
   * @param {number} [pageSize] The number of items in each page of data.
   * @param {*} [options] Override http request option.
   * @throws {@link @zerobias-org/types-core-js#ParameterRequiredError} if any required parameter is not provided
   * @example
   * ```typescript
   * const result = await api.listCpes('00000000-0000-0000-0000-000000000000', 1, 1);
   * ```
   * @openapi operation=listCpes path=/catalog/products/{id}/cpes method=GET
   * @memberof ProductApi
   */
  listCpes(id: UUID, pageNumber?: number, pageSize?: number): Promise<PagedResults<string>>;

  /**
   * List product component versions
   * @summary List product component versions
   * @param {UUID} productId 
   * @param {UUID} productComponentId 
   * @param {number} [pageNumber] The requested page. This value is 1-indexed.
   * @param {number} [pageSize] The number of items in each page of data.
   * @param {*} [options] Override http request option.
   * @throws {@link @zerobias-org/types-core-js#ParameterRequiredError} if any required parameter is not provided
   * @example
   * ```typescript
   * const result = await api.listComponentVersions('00000000-0000-0000-0000-000000000000', '00000000-0000-0000-0000-000000000000', 1, 1);
   * ```
   * @openapi operation=listProductComponentVersions path=/catalog/products/{productId}/components/{productComponentId}/versions method=GET
   * @memberof ProductApi
   */
  listComponentVersions(productId: UUID, productComponentId: UUID, pageNumber?: number, pageSize?: number): Promise<PagedResults<ProductComponentVersionExtended>>;

  /**
   * List product edition versions
   * @summary List product edition versions
   * @param {UUID} productId 
   * @param {UUID} productEditionId 
   * @param {number} [pageNumber] The requested page. This value is 1-indexed.
   * @param {number} [pageSize] The number of items in each page of data.
   * @param {*} [options] Override http request option.
   * @throws {@link @zerobias-org/types-core-js#ParameterRequiredError} if any required parameter is not provided
   * @example
   * ```typescript
   * const result = await api.listEditionVersions('00000000-0000-0000-0000-000000000000', '00000000-0000-0000-0000-000000000000', 1, 1);
   * ```
   * @openapi operation=listProductEditionVersions path=/catalog/products/{productId}/editions/{productEditionId}/versions method=GET
   * @memberof ProductApi
   */
  listEditionVersions(productId: UUID, productEditionId: UUID, pageNumber?: number, pageSize?: number): Promise<PagedResults<ProductEditionVersionExtended>>;

  /**
   * List product versions
   * @summary List product versions
   * @param {UUID} productId 
   * @param {number} [pageNumber] The requested page. This value is 1-indexed.
   * @param {number} [pageSize] The number of items in each page of data.
   * @param {*} [options] Override http request option.
   * @throws {@link @zerobias-org/types-core-js#ParameterRequiredError} if any required parameter is not provided
   * @example
   * ```typescript
   * const result = await api.listVersions('00000000-0000-0000-0000-000000000000', 1, 1);
   * ```
   * @openapi operation=listProductVersions path=/catalog/products/{productId}/versions method=GET
   * @memberof ProductApi
   */
  listVersions(productId: UUID, pageNumber?: number, pageSize?: number): Promise<PagedResults<ProductVersionExtended>>;

  /**
   * List products
   * @summary List products
   * @param {number} [pageNumber] The requested page. This value is 1-indexed.
   * @param {number} [pageSize] The number of items in each page of data.
   * @param {UUID} [vendorId] 
   * @param {UUID} [suiteId] 
   * @param {CatalogPublishStatusEnum} [status] 
   * @param {string} [search] 
   * @param {*} [options] Override http request option.
   * @throws {@link @zerobias-org/types-core-js#ParameterRequiredError} if any required parameter is not provided
   * @example
   * ```typescript
   * const result = await api.list(1, 1, '00000000-0000-0000-0000-000000000000', '00000000-0000-0000-0000-000000000000', null, 'search');
   * ```
   * @openapi operation=listProducts path=/catalog/products method=GET
   * @memberof ProductApi
   */
  list(pageNumber?: number, pageSize?: number, vendorId?: UUID, suiteId?: UUID, status?: CatalogPublishStatusEnumDef, search?: string): Promise<PagedResults<ProductExtended>>;

  /**
   * Adds and/or removes components from a product edition
   * @summary Adds and/or removes components from a product edition
   * @param {UUID} productId 
   * @param {UUID} productEditionId 
   * @param {PatchComponentsBody} patchComponentsBody 
   * @param {*} [options] Override http request option.
   * @throws {@link @zerobias-org/types-core-js#ParameterRequiredError} if any required parameter is not provided
   * @example
   * ```typescript
   * const result = await api.patchEditionComponents('00000000-0000-0000-0000-000000000000', '00000000-0000-0000-0000-000000000000', null);
   * ```
   * @openapi operation=patchEditionComponents path=/catalog/products/{productId}/editions/{productEditionId}/components method=PATCH
   * @memberof ProductApi
   */
  patchEditionComponents(productId: UUID, productEditionId: UUID, patchComponentsBody: PatchComponentsBody): Promise<ProductEditionExtended>;

  /**
   * Patch a product
   * @summary Patch a product
   * @param {UUID} productId 
   * @param {PatchProduct} patchProduct 
   * @param {*} [options] Override http request option.
   * @throws {@link @zerobias-org/types-core-js#ParameterRequiredError} if any required parameter is not provided
   * @example
   * ```typescript
   * const result = await api.patch('00000000-0000-0000-0000-000000000000', null);
   * ```
   * @openapi operation=patchProduct path=/catalog/products/{productId} method=PATCH
   * @memberof ProductApi
   */
  patch(productId: UUID, patchProduct: PatchProduct): Promise<ProductExtendedGet>;

  /**
   * Patch a product component
   * @summary Patch a product component
   * @param {UUID} productId 
   * @param {UUID} productComponentId 
   * @param {PatchProductComponent} patchProductComponent 
   * @param {*} [options] Override http request option.
   * @throws {@link @zerobias-org/types-core-js#ParameterRequiredError} if any required parameter is not provided
   * @example
   * ```typescript
   * const result = await api.patchComponent('00000000-0000-0000-0000-000000000000', '00000000-0000-0000-0000-000000000000', null);
   * ```
   * @openapi operation=patchProductComponent path=/catalog/products/{productId}/components/{productComponentId} method=PATCH
   * @memberof ProductApi
   */
  patchComponent(productId: UUID, productComponentId: UUID, patchProductComponent: PatchProductComponent): Promise<ProductComponentExtended>;

  /**
   * Adds and/or removes components from a product
   * @summary Adds and/or removes components from a product
   * @param {UUID} productId 
   * @param {PatchComponentsBody} patchComponentsBody 
   * @param {*} [options] Override http request option.
   * @throws {@link @zerobias-org/types-core-js#ParameterRequiredError} if any required parameter is not provided
   * @example
   * ```typescript
   * const result = await api.patchProductComponents('00000000-0000-0000-0000-000000000000', null);
   * ```
   * @openapi operation=patchProductComponents path=/catalog/products/{productId}/components method=PATCH
   * @memberof ProductApi
   */
  patchProductComponents(productId: UUID, patchComponentsBody: PatchComponentsBody): Promise<ProductExtendedGet>;

  /**
   * Patch a product edition
   * @summary Patch a product edition
   * @param {UUID} productId 
   * @param {UUID} productEditionId 
   * @param {PatchProductEdition} patchProductEdition 
   * @param {*} [options] Override http request option.
   * @throws {@link @zerobias-org/types-core-js#ParameterRequiredError} if any required parameter is not provided
   * @example
   * ```typescript
   * const result = await api.patchEdition('00000000-0000-0000-0000-000000000000', '00000000-0000-0000-0000-000000000000', null);
   * ```
   * @openapi operation=patchProductEdition path=/catalog/products/{productId}/editions/{productEditionId} method=PATCH
   * @memberof ProductApi
   */
  patchEdition(productId: UUID, productEditionId: UUID, patchProductEdition: PatchProductEdition): Promise<ProductEditionExtended>;

  /**
   * Adds and/or removes features from a product edition
   * @summary Adds and/or removes features from a product edition
   * @param {UUID} productId 
   * @param {UUID} productEditionId 
   * @param {PatchComplianceFeaturesBody} patchComplianceFeaturesBody 
   * @param {*} [options] Override http request option.
   * @throws {@link @zerobias-org/types-core-js#ParameterRequiredError} if any required parameter is not provided
   * @example
   * ```typescript
   * const result = await api.patchEditionFeatures('00000000-0000-0000-0000-000000000000', '00000000-0000-0000-0000-000000000000', null);
   * ```
   * @openapi operation=patchProductEditionFeatures path=/catalog/products/{productId}/editions/{productEditionId}/features method=PATCH
   * @memberof ProductApi
   */
  patchEditionFeatures(productId: UUID, productEditionId: UUID, patchComplianceFeaturesBody: PatchComplianceFeaturesBody): Promise<ProductEditionExtended>;

  /**
   * Adds and/or removes editions from a product
   * @summary Adds and/or removes editions from a product
   * @param {UUID} productId 
   * @param {PatchEditionsBody} patchEditionsBody 
   * @param {*} [options] Override http request option.
   * @throws {@link @zerobias-org/types-core-js#ParameterRequiredError} if any required parameter is not provided
   * @example
   * ```typescript
   * const result = await api.patchProductEditions('00000000-0000-0000-0000-000000000000', null);
   * ```
   * @openapi operation=patchProductEditions path=/catalog/products/{productId}/editions method=PATCH
   * @memberof ProductApi
   */
  patchProductEditions(productId: UUID, patchEditionsBody: PatchEditionsBody): Promise<ProductExtendedGet>;

  /**
   * Adds and/or removes segments from a product
   * @summary Adds and/or removes segments from a product
   * @param {UUID} productId 
   * @param {PatchSegmentsBody} patchSegmentsBody 
   * @param {*} [options] Override http request option.
   * @throws {@link @zerobias-org/types-core-js#ParameterRequiredError} if any required parameter is not provided
   * @example
   * ```typescript
   * const result = await api.patchSegments('00000000-0000-0000-0000-000000000000', null);
   * ```
   * @openapi operation=patchProductSegments path=/catalog/products/{productId}/segments method=PATCH
   * @memberof ProductApi
   */
  patchSegments(productId: UUID, patchSegmentsBody: PatchSegmentsBody): Promise<ProductExtendedGet>;

  /**
   * Suggests a new product operation
   * @summary Suggests a new product operation
   * @param {UUID} id 
   * @param {SuggestProductOperationBody} suggestProductOperationBody 
   * @param {*} [options] Override http request option.
   * @throws {@link @zerobias-org/types-core-js#ParameterRequiredError} if any required parameter is not provided
   * @example
   * ```typescript
   * const result = await api.suggestOperation('00000000-0000-0000-0000-000000000000', null);
   * ```
   * @openapi operation=suggestProductOperation path=/catalog/products/{id}/suggestOperation method=POST
   * @memberof ProductApi
   */
  suggestOperation(id: UUID, suggestProductOperationBody: SuggestProductOperationBody): Promise<Task>;

  /**
   * Update a product component status
   * @summary Update a product component status
   * @param {UUID} productId 
   * @param {UUID} productComponentId 
   * @param {UpdateProductComponent} updateProductComponent 
   * @param {*} [options] Override http request option.
   * @throws {@link @zerobias-org/types-core-js#ParameterRequiredError} if any required parameter is not provided
   * @example
   * ```typescript
   * const result = await api.updateComponentStatus('00000000-0000-0000-0000-000000000000', '00000000-0000-0000-0000-000000000000', null);
   * ```
   * @openapi operation=updateProductComponentStatus path=/catalog/products/{productId}/components/{productComponentId} method=PUT
   * @memberof ProductApi
   */
  updateComponentStatus(productId: UUID, productComponentId: UUID, updateProductComponent: UpdateProductComponent): Promise<ProductComponentExtended>;

  /**
   * Update a product edition status
   * @summary Update a product edition status
   * @param {UUID} productId 
   * @param {UUID} productEditionId 
   * @param {UpdateProductEdition} updateProductEdition 
   * @param {*} [options] Override http request option.
   * @throws {@link @zerobias-org/types-core-js#ParameterRequiredError} if any required parameter is not provided
   * @example
   * ```typescript
   * const result = await api.updateEditionStatus('00000000-0000-0000-0000-000000000000', '00000000-0000-0000-0000-000000000000', null);
   * ```
   * @openapi operation=updateProductEditionStatus path=/catalog/products/{productId}/editions/{productEditionId} method=PUT
   * @memberof ProductApi
   */
  updateEditionStatus(productId: UUID, productEditionId: UUID, updateProductEdition: UpdateProductEdition): Promise<ProductEditionExtended>;

  /**
   * Update a product status
   * @summary Update a product status
   * @param {UUID} productId 
   * @param {UpdateProduct} updateProduct 
   * @param {*} [options] Override http request option.
   * @throws {@link @zerobias-org/types-core-js#ParameterRequiredError} if any required parameter is not provided
   * @example
   * ```typescript
   * const result = await api.updateStatus('00000000-0000-0000-0000-000000000000', null);
   * ```
   * @openapi operation=updateProductStatus path=/catalog/products/{productId} method=PUT
   * @memberof ProductApi
   */
  updateStatus(productId: UUID, updateProduct: UpdateProduct): Promise<ProductExtendedGet>;

}

/**
 * ProductProducerApi - interface
 * Producer interface for Product
 * @export
 * @interface ProductProducerApi
 */
export interface ProductProducerApi {
  /**
  * Creates a new product with version
  * @summary Creates a new product with version
  * @param {NewProduct} newProduct 
  * @param {*} [options] Override http request option.
  * @throws {@link @zerobias-org/types-core-js#ParameterRequiredError} if any required parameter is not provided
  * @openapi operation=createProduct path=/catalog/products method=POST
  * @memberof Product
  */
  create(newProduct: NewProduct): Promise<ProductExtendedGet>;
  /**
  * Creates a new product component with version
  * @summary Creates a new product component with version
  * @param {UUID} productId 
  * @param {NewProductComponent} newProductComponent 
  * @param {*} [options] Override http request option.
  * @throws {@link @zerobias-org/types-core-js#ParameterRequiredError} if any required parameter is not provided
  * @openapi operation=createProductComponent path=/catalog/products/{productId}/components method=POST
  * @memberof Product
  */
  createComponent(productId: UUID, newProductComponent: NewProductComponent): Promise<ProductComponentExtended>;
  /**
  * Creates a new product edition with version
  * @summary Creates a new product edition with version
  * @param {UUID} productId 
  * @param {NewProductEdition} newProductEdition 
  * @param {*} [options] Override http request option.
  * @throws {@link @zerobias-org/types-core-js#ParameterRequiredError} if any required parameter is not provided
  * @openapi operation=createProductEdition path=/catalog/products/{productId}/editions method=POST
  * @memberof Product
  */
  createEdition(productId: UUID, newProductEdition: NewProductEdition): Promise<ProductEditionExtended>;
  /**
  * Delete a product
  * @summary Delete a product
  * @param {UUID} productId 
  * @param {*} [options] Override http request option.
  * @throws {@link @zerobias-org/types-core-js#ParameterRequiredError} if any required parameter is not provided
  * @openapi operation=deleteProduct path=/catalog/products/{productId} method=DELETE
  * @memberof Product
  */
  delete(productId: UUID): Promise<void>;
  /**
  * Delete a product component
  * @summary Delete a product component
  * @param {UUID} productId 
  * @param {UUID} productComponentId 
  * @param {*} [options] Override http request option.
  * @throws {@link @zerobias-org/types-core-js#ParameterRequiredError} if any required parameter is not provided
  * @openapi operation=deleteProductComponent path=/catalog/products/{productId}/components/{productComponentId} method=DELETE
  * @memberof Product
  */
  deleteComponent(productId: UUID, productComponentId: UUID): Promise<void>;
  /**
  * Delete a product component version
  * @summary Delete a product component version
  * @param {UUID} productId 
  * @param {UUID} productComponentId 
  * @param {UUID} versionId 
  * @param {*} [options] Override http request option.
  * @throws {@link @zerobias-org/types-core-js#ParameterRequiredError} if any required parameter is not provided
  * @openapi operation=deleteProductComponentVersion path=/catalog/products/{productId}/components/{productComponentId}/versions/{versionId} method=DELETE
  * @memberof Product
  */
  deleteComponentVersion(productId: UUID, productComponentId: UUID, versionId: UUID): Promise<void>;
  /**
  * Delete a product edition
  * @summary Delete a product edition
  * @param {UUID} productId 
  * @param {UUID} productEditionId 
  * @param {*} [options] Override http request option.
  * @throws {@link @zerobias-org/types-core-js#ParameterRequiredError} if any required parameter is not provided
  * @openapi operation=deleteProductEdition path=/catalog/products/{productId}/editions/{productEditionId} method=DELETE
  * @memberof Product
  */
  deleteEdition(productId: UUID, productEditionId: UUID): Promise<void>;
  /**
  * Delete a product edition version
  * @summary Delete a product edition version
  * @param {UUID} productId 
  * @param {UUID} productEditionId 
  * @param {UUID} versionId 
  * @param {*} [options] Override http request option.
  * @throws {@link @zerobias-org/types-core-js#ParameterRequiredError} if any required parameter is not provided
  * @openapi operation=deleteProductEditionVersion path=/catalog/products/{productId}/editions/{productEditionId}/versions/{versionId} method=DELETE
  * @memberof Product
  */
  deleteEditionVersion(productId: UUID, productEditionId: UUID, versionId: UUID): Promise<void>;
  /**
  * Delete a product version
  * @summary Delete a product version
  * @param {UUID} productId 
  * @param {UUID} versionId 
  * @param {*} [options] Override http request option.
  * @throws {@link @zerobias-org/types-core-js#ParameterRequiredError} if any required parameter is not provided
  * @openapi operation=deleteProductVersion path=/catalog/products/{productId}/versions/{versionId} method=DELETE
  * @memberof Product
  */
  deleteVersion(productId: UUID, versionId: UUID): Promise<void>;
  /**
  * Retrieves a catalog product by its cpe string
  * @summary Retrieves a catalog product by its cpe string
  * @param {string} cpe The product cpe &#x60;vendor:code&#x60; id, or a cpe full version string
  * @param {*} [options] Override http request option.
  * @throws {@link @zerobias-org/types-core-js#ParameterRequiredError} if any required parameter is not provided
  * @openapi operation=getByCpe path=/catalog/cpes/{cpe} method=GET
  * @memberof Product
  */
  getByCpe(cpe: string): Promise<Product>;
  /**
  * Get specific product
  * @summary Get specific product
  * @param {UUID} productId 
  * @param {*} [options] Override http request option.
  * @throws {@link @zerobias-org/types-core-js#ParameterRequiredError} if any required parameter is not provided
  * @openapi operation=getProduct path=/catalog/products/{productId} method=GET
  * @memberof Product
  */
  get(productId: UUID): Promise<ProductExtendedGet>;
  /**
  * Get specific product component
  * @summary Get specific product component
  * @param {UUID} productId 
  * @param {UUID} productComponentId 
  * @param {*} [options] Override http request option.
  * @throws {@link @zerobias-org/types-core-js#ParameterRequiredError} if any required parameter is not provided
  * @openapi operation=getProductComponent path=/catalog/products/{productId}/components/{productComponentId} method=GET
  * @memberof Product
  */
  getComponent(productId: UUID, productComponentId: UUID): Promise<ProductComponentExtended>;
  /**
  * Get specific product component version
  * @summary Get specific product component version
  * @param {UUID} productId 
  * @param {UUID} productComponentId 
  * @param {UUID} versionId 
  * @param {*} [options] Override http request option.
  * @throws {@link @zerobias-org/types-core-js#ParameterRequiredError} if any required parameter is not provided
  * @openapi operation=getProductComponentVersion path=/catalog/products/{productId}/components/{productComponentId}/versions/{versionId} method=GET
  * @memberof Product
  */
  getComponentVersion(productId: UUID, productComponentId: UUID, versionId: UUID): Promise<ProductComponentVersionExtended>;
  /**
  * Get specific product component version
  * @summary Get specific product component version
  * @param {UUID} productComponentVersionId 
  * @param {*} [options] Override http request option.
  * @throws {@link @zerobias-org/types-core-js#ParameterRequiredError} if any required parameter is not provided
  * @openapi operation=getProductComponentVersionDirect path=/catalog/productComponentVersions/{productComponentVersionId} method=GET
  * @memberof Product
  */
  getProductComponentVersionDirect(productComponentVersionId: UUID): Promise<ProductComponentVersionExtended>;
  /**
  * Get specific product edition
  * @summary Get specific product edition
  * @param {UUID} productId 
  * @param {UUID} productEditionId 
  * @param {*} [options] Override http request option.
  * @throws {@link @zerobias-org/types-core-js#ParameterRequiredError} if any required parameter is not provided
  * @openapi operation=getProductEdition path=/catalog/products/{productId}/editions/{productEditionId} method=GET
  * @memberof Product
  */
  getEdition(productId: UUID, productEditionId: UUID): Promise<ProductEditionExtended>;
  /**
  * Get specific product edition version
  * @summary Get specific product edition version
  * @param {UUID} productId 
  * @param {UUID} productEditionId 
  * @param {UUID} versionId 
  * @param {*} [options] Override http request option.
  * @throws {@link @zerobias-org/types-core-js#ParameterRequiredError} if any required parameter is not provided
  * @openapi operation=getProductEditionVersion path=/catalog/products/{productId}/editions/{productEditionId}/versions/{versionId} method=GET
  * @memberof Product
  */
  getEditionVersion(productId: UUID, productEditionId: UUID, versionId: UUID): Promise<ProductEditionVersionExtended>;
  /**
  * Get specific product edition version
  * @summary Get specific product edition version
  * @param {UUID} productEditionVersionId 
  * @param {*} [options] Override http request option.
  * @throws {@link @zerobias-org/types-core-js#ParameterRequiredError} if any required parameter is not provided
  * @openapi operation=getProductEditionVersionDirect path=/catalog/productEditionVersions/{productEditionVersionId} method=GET
  * @memberof Product
  */
  getProductEditionVersionDirect(productEditionVersionId: UUID): Promise<ProductEditionVersionExtended>;
  /**
  * Get specific product version
  * @summary Get specific product version
  * @param {UUID} productId 
  * @param {UUID} versionId 
  * @param {*} [options] Override http request option.
  * @throws {@link @zerobias-org/types-core-js#ParameterRequiredError} if any required parameter is not provided
  * @openapi operation=getProductVersion path=/catalog/products/{productId}/versions/{versionId} method=GET
  * @memberof Product
  */
  getVersion(productId: UUID, versionId: UUID): Promise<ProductVersionExtendedGet>;
  /**
  * Get specific product version
  * @summary Get specific product version
  * @param {UUID} productVersionId 
  * @param {*} [options] Override http request option.
  * @throws {@link @zerobias-org/types-core-js#ParameterRequiredError} if any required parameter is not provided
  * @openapi operation=getProductVersionDirect path=/catalog/productVersions/{productVersionId} method=GET
  * @memberof Product
  */
  getProductVersionDirect(productVersionId: UUID): Promise<ProductVersionExtendedGet>;
  /**
  * List product Cpe Version strings
  * @summary List product Cpe Version strings
  * @param {UUID} id The product id
  * @param {*} [options] Override http request option.
  * @throws {@link @zerobias-org/types-core-js#ParameterRequiredError} if any required parameter is not provided
  * @openapi operation=listCpes path=/catalog/products/{id}/cpes method=GET
  * @memberof Product
  */
  listCpes(results: PagedResults<string>, id: UUID): Promise<void>;
  /**
  * List product component versions
  * @summary List product component versions
  * @param {UUID} productId 
  * @param {UUID} productComponentId 
  * @param {*} [options] Override http request option.
  * @throws {@link @zerobias-org/types-core-js#ParameterRequiredError} if any required parameter is not provided
  * @openapi operation=listProductComponentVersions path=/catalog/products/{productId}/components/{productComponentId}/versions method=GET
  * @memberof Product
  */
  listComponentVersions(results: PagedResults<ProductComponentVersionExtended>, productId: UUID, productComponentId: UUID): Promise<void>;
  /**
  * List product edition versions
  * @summary List product edition versions
  * @param {UUID} productId 
  * @param {UUID} productEditionId 
  * @param {*} [options] Override http request option.
  * @throws {@link @zerobias-org/types-core-js#ParameterRequiredError} if any required parameter is not provided
  * @openapi operation=listProductEditionVersions path=/catalog/products/{productId}/editions/{productEditionId}/versions method=GET
  * @memberof Product
  */
  listEditionVersions(results: PagedResults<ProductEditionVersionExtended>, productId: UUID, productEditionId: UUID): Promise<void>;
  /**
  * List product versions
  * @summary List product versions
  * @param {UUID} productId 
  * @param {*} [options] Override http request option.
  * @throws {@link @zerobias-org/types-core-js#ParameterRequiredError} if any required parameter is not provided
  * @openapi operation=listProductVersions path=/catalog/products/{productId}/versions method=GET
  * @memberof Product
  */
  listVersions(results: PagedResults<ProductVersionExtended>, productId: UUID): Promise<void>;
  /**
  * List products
  * @summary List products
  * @param {UUID} [vendorId] 
  * @param {UUID} [suiteId] 
  * @param {CatalogPublishStatusEnum} [status] 
  * @param {string} [search] 
  * @param {*} [options] Override http request option.
  * @throws {@link @zerobias-org/types-core-js#ParameterRequiredError} if any required parameter is not provided
  * @openapi operation=listProducts path=/catalog/products method=GET
  * @memberof Product
  */
  list(results: PagedResults<ProductExtended>, vendorId?: UUID, suiteId?: UUID, status?: CatalogPublishStatusEnumDef, search?: string): Promise<void>;
  /**
  * Adds and/or removes components from a product edition
  * @summary Adds and/or removes components from a product edition
  * @param {UUID} productId 
  * @param {UUID} productEditionId 
  * @param {PatchComponentsBody} patchComponentsBody 
  * @param {*} [options] Override http request option.
  * @throws {@link @zerobias-org/types-core-js#ParameterRequiredError} if any required parameter is not provided
  * @openapi operation=patchEditionComponents path=/catalog/products/{productId}/editions/{productEditionId}/components method=PATCH
  * @memberof Product
  */
  patchEditionComponents(productId: UUID, productEditionId: UUID, patchComponentsBody: PatchComponentsBody): Promise<ProductEditionExtended>;
  /**
  * Patch a product
  * @summary Patch a product
  * @param {UUID} productId 
  * @param {PatchProduct} patchProduct 
  * @param {*} [options] Override http request option.
  * @throws {@link @zerobias-org/types-core-js#ParameterRequiredError} if any required parameter is not provided
  * @openapi operation=patchProduct path=/catalog/products/{productId} method=PATCH
  * @memberof Product
  */
  patch(productId: UUID, patchProduct: PatchProduct): Promise<ProductExtendedGet>;
  /**
  * Patch a product component
  * @summary Patch a product component
  * @param {UUID} productId 
  * @param {UUID} productComponentId 
  * @param {PatchProductComponent} patchProductComponent 
  * @param {*} [options] Override http request option.
  * @throws {@link @zerobias-org/types-core-js#ParameterRequiredError} if any required parameter is not provided
  * @openapi operation=patchProductComponent path=/catalog/products/{productId}/components/{productComponentId} method=PATCH
  * @memberof Product
  */
  patchComponent(productId: UUID, productComponentId: UUID, patchProductComponent: PatchProductComponent): Promise<ProductComponentExtended>;
  /**
  * Adds and/or removes components from a product
  * @summary Adds and/or removes components from a product
  * @param {UUID} productId 
  * @param {PatchComponentsBody} patchComponentsBody 
  * @param {*} [options] Override http request option.
  * @throws {@link @zerobias-org/types-core-js#ParameterRequiredError} if any required parameter is not provided
  * @openapi operation=patchProductComponents path=/catalog/products/{productId}/components method=PATCH
  * @memberof Product
  */
  patchProductComponents(productId: UUID, patchComponentsBody: PatchComponentsBody): Promise<ProductExtendedGet>;
  /**
  * Patch a product edition
  * @summary Patch a product edition
  * @param {UUID} productId 
  * @param {UUID} productEditionId 
  * @param {PatchProductEdition} patchProductEdition 
  * @param {*} [options] Override http request option.
  * @throws {@link @zerobias-org/types-core-js#ParameterRequiredError} if any required parameter is not provided
  * @openapi operation=patchProductEdition path=/catalog/products/{productId}/editions/{productEditionId} method=PATCH
  * @memberof Product
  */
  patchEdition(productId: UUID, productEditionId: UUID, patchProductEdition: PatchProductEdition): Promise<ProductEditionExtended>;
  /**
  * Adds and/or removes features from a product edition
  * @summary Adds and/or removes features from a product edition
  * @param {UUID} productId 
  * @param {UUID} productEditionId 
  * @param {PatchComplianceFeaturesBody} patchComplianceFeaturesBody 
  * @param {*} [options] Override http request option.
  * @throws {@link @zerobias-org/types-core-js#ParameterRequiredError} if any required parameter is not provided
  * @openapi operation=patchProductEditionFeatures path=/catalog/products/{productId}/editions/{productEditionId}/features method=PATCH
  * @memberof Product
  */
  patchEditionFeatures(productId: UUID, productEditionId: UUID, patchComplianceFeaturesBody: PatchComplianceFeaturesBody): Promise<ProductEditionExtended>;
  /**
  * Adds and/or removes editions from a product
  * @summary Adds and/or removes editions from a product
  * @param {UUID} productId 
  * @param {PatchEditionsBody} patchEditionsBody 
  * @param {*} [options] Override http request option.
  * @throws {@link @zerobias-org/types-core-js#ParameterRequiredError} if any required parameter is not provided
  * @openapi operation=patchProductEditions path=/catalog/products/{productId}/editions method=PATCH
  * @memberof Product
  */
  patchProductEditions(productId: UUID, patchEditionsBody: PatchEditionsBody): Promise<ProductExtendedGet>;
  /**
  * Adds and/or removes segments from a product
  * @summary Adds and/or removes segments from a product
  * @param {UUID} productId 
  * @param {PatchSegmentsBody} patchSegmentsBody 
  * @param {*} [options] Override http request option.
  * @throws {@link @zerobias-org/types-core-js#ParameterRequiredError} if any required parameter is not provided
  * @openapi operation=patchProductSegments path=/catalog/products/{productId}/segments method=PATCH
  * @memberof Product
  */
  patchSegments(productId: UUID, patchSegmentsBody: PatchSegmentsBody): Promise<ProductExtendedGet>;
  /**
  * Suggests a new product operation
  * @summary Suggests a new product operation
  * @param {UUID} id 
  * @param {SuggestProductOperationBody} suggestProductOperationBody 
  * @param {*} [options] Override http request option.
  * @throws {@link @zerobias-org/types-core-js#ParameterRequiredError} if any required parameter is not provided
  * @openapi operation=suggestProductOperation path=/catalog/products/{id}/suggestOperation method=POST
  * @memberof Product
  */
  suggestOperation(id: UUID, suggestProductOperationBody: SuggestProductOperationBody): Promise<Task>;
  /**
  * Update a product component status
  * @summary Update a product component status
  * @param {UUID} productId 
  * @param {UUID} productComponentId 
  * @param {UpdateProductComponent} updateProductComponent 
  * @param {*} [options] Override http request option.
  * @throws {@link @zerobias-org/types-core-js#ParameterRequiredError} if any required parameter is not provided
  * @openapi operation=updateProductComponentStatus path=/catalog/products/{productId}/components/{productComponentId} method=PUT
  * @memberof Product
  */
  updateComponentStatus(productId: UUID, productComponentId: UUID, updateProductComponent: UpdateProductComponent): Promise<ProductComponentExtended>;
  /**
  * Update a product edition status
  * @summary Update a product edition status
  * @param {UUID} productId 
  * @param {UUID} productEditionId 
  * @param {UpdateProductEdition} updateProductEdition 
  * @param {*} [options] Override http request option.
  * @throws {@link @zerobias-org/types-core-js#ParameterRequiredError} if any required parameter is not provided
  * @openapi operation=updateProductEditionStatus path=/catalog/products/{productId}/editions/{productEditionId} method=PUT
  * @memberof Product
  */
  updateEditionStatus(productId: UUID, productEditionId: UUID, updateProductEdition: UpdateProductEdition): Promise<ProductEditionExtended>;
  /**
  * Update a product status
  * @summary Update a product status
  * @param {UUID} productId 
  * @param {UpdateProduct} updateProduct 
  * @param {*} [options] Override http request option.
  * @throws {@link @zerobias-org/types-core-js#ParameterRequiredError} if any required parameter is not provided
  * @openapi operation=updateProductStatus path=/catalog/products/{productId} method=PUT
  * @memberof Product
  */
  updateStatus(productId: UUID, updateProduct: UpdateProduct): Promise<ProductExtendedGet>;
}

export class ProductApiMappingImpl implements ProductApi {
  private producer: ProductProducerApi;
  constructor(producer: ProductProducerApi) {
    this.producer = producer;
  }

  /**
   * Creates a new product with version
   * @summary Creates a new product with version
   * @param newProduct 
   * @openapi operation=createProduct path=/catalog/products method=POST
   */
  public async create(newProduct: NewProduct): Promise<ProductExtendedGet> {
    // verify required parameter 'newProduct' is not null or undefined
    if (newProduct === null || newProduct === undefined) {
      throw new ParameterRequiredError('newProduct');
    }
    return this.producer.create(newProduct);
  }
  /**
   * Creates a new product component with version
   * @summary Creates a new product component with version
   * @param productId 
   * @param newProductComponent 
   * @openapi operation=createProductComponent path=/catalog/products/{productId}/components method=POST
   */
  public async createComponent(productId: UUID, newProductComponent: NewProductComponent): Promise<ProductComponentExtended> {
    // verify required parameter 'productId' is not null or undefined
    if (productId === null || productId === undefined) {
      throw new ParameterRequiredError('productId');
    }
    // verify required parameter 'newProductComponent' is not null or undefined
    if (newProductComponent === null || newProductComponent === undefined) {
      throw new ParameterRequiredError('newProductComponent');
    }
    return this.producer.createComponent(productId, newProductComponent);
  }
  /**
   * Creates a new product edition with version
   * @summary Creates a new product edition with version
   * @param productId 
   * @param newProductEdition 
   * @openapi operation=createProductEdition path=/catalog/products/{productId}/editions method=POST
   */
  public async createEdition(productId: UUID, newProductEdition: NewProductEdition): Promise<ProductEditionExtended> {
    // verify required parameter 'productId' is not null or undefined
    if (productId === null || productId === undefined) {
      throw new ParameterRequiredError('productId');
    }
    // verify required parameter 'newProductEdition' is not null or undefined
    if (newProductEdition === null || newProductEdition === undefined) {
      throw new ParameterRequiredError('newProductEdition');
    }
    return this.producer.createEdition(productId, newProductEdition);
  }
  /**
   * Delete a product
   * @summary Delete a product
   * @param productId 
   * @openapi operation=deleteProduct path=/catalog/products/{productId} method=DELETE
   */
  public async delete(productId: UUID): Promise<void> {
    // verify required parameter 'productId' is not null or undefined
    if (productId === null || productId === undefined) {
      throw new ParameterRequiredError('productId');
    }
    return this.producer.delete(productId);
  }
  /**
   * Delete a product component
   * @summary Delete a product component
   * @param productId 
   * @param productComponentId 
   * @openapi operation=deleteProductComponent path=/catalog/products/{productId}/components/{productComponentId} method=DELETE
   */
  public async deleteComponent(productId: UUID, productComponentId: UUID): Promise<void> {
    // verify required parameter 'productId' is not null or undefined
    if (productId === null || productId === undefined) {
      throw new ParameterRequiredError('productId');
    }
    // verify required parameter 'productComponentId' is not null or undefined
    if (productComponentId === null || productComponentId === undefined) {
      throw new ParameterRequiredError('productComponentId');
    }
    return this.producer.deleteComponent(productId, productComponentId);
  }
  /**
   * Delete a product component version
   * @summary Delete a product component version
   * @param productId 
   * @param productComponentId 
   * @param versionId 
   * @openapi operation=deleteProductComponentVersion path=/catalog/products/{productId}/components/{productComponentId}/versions/{versionId} method=DELETE
   */
  public async deleteComponentVersion(productId: UUID, productComponentId: UUID, versionId: UUID): Promise<void> {
    // verify required parameter 'productId' is not null or undefined
    if (productId === null || productId === undefined) {
      throw new ParameterRequiredError('productId');
    }
    // verify required parameter 'productComponentId' is not null or undefined
    if (productComponentId === null || productComponentId === undefined) {
      throw new ParameterRequiredError('productComponentId');
    }
    // verify required parameter 'versionId' is not null or undefined
    if (versionId === null || versionId === undefined) {
      throw new ParameterRequiredError('versionId');
    }
    return this.producer.deleteComponentVersion(productId, productComponentId, versionId);
  }
  /**
   * Delete a product edition
   * @summary Delete a product edition
   * @param productId 
   * @param productEditionId 
   * @openapi operation=deleteProductEdition path=/catalog/products/{productId}/editions/{productEditionId} method=DELETE
   */
  public async deleteEdition(productId: UUID, productEditionId: UUID): Promise<void> {
    // verify required parameter 'productId' is not null or undefined
    if (productId === null || productId === undefined) {
      throw new ParameterRequiredError('productId');
    }
    // verify required parameter 'productEditionId' is not null or undefined
    if (productEditionId === null || productEditionId === undefined) {
      throw new ParameterRequiredError('productEditionId');
    }
    return this.producer.deleteEdition(productId, productEditionId);
  }
  /**
   * Delete a product edition version
   * @summary Delete a product edition version
   * @param productId 
   * @param productEditionId 
   * @param versionId 
   * @openapi operation=deleteProductEditionVersion path=/catalog/products/{productId}/editions/{productEditionId}/versions/{versionId} method=DELETE
   */
  public async deleteEditionVersion(productId: UUID, productEditionId: UUID, versionId: UUID): Promise<void> {
    // verify required parameter 'productId' is not null or undefined
    if (productId === null || productId === undefined) {
      throw new ParameterRequiredError('productId');
    }
    // verify required parameter 'productEditionId' is not null or undefined
    if (productEditionId === null || productEditionId === undefined) {
      throw new ParameterRequiredError('productEditionId');
    }
    // verify required parameter 'versionId' is not null or undefined
    if (versionId === null || versionId === undefined) {
      throw new ParameterRequiredError('versionId');
    }
    return this.producer.deleteEditionVersion(productId, productEditionId, versionId);
  }
  /**
   * Delete a product version
   * @summary Delete a product version
   * @param productId 
   * @param versionId 
   * @openapi operation=deleteProductVersion path=/catalog/products/{productId}/versions/{versionId} method=DELETE
   */
  public async deleteVersion(productId: UUID, versionId: UUID): Promise<void> {
    // verify required parameter 'productId' is not null or undefined
    if (productId === null || productId === undefined) {
      throw new ParameterRequiredError('productId');
    }
    // verify required parameter 'versionId' is not null or undefined
    if (versionId === null || versionId === undefined) {
      throw new ParameterRequiredError('versionId');
    }
    return this.producer.deleteVersion(productId, versionId);
  }
  /**
   * Retrieves a catalog product by its cpe string
   * @summary Retrieves a catalog product by its cpe string
   * @param cpe The product cpe &#x60;vendor:code&#x60; id, or a cpe full version string
   * @openapi operation=getByCpe path=/catalog/cpes/{cpe} method=GET
   */
  public async getByCpe(cpe: string): Promise<Product> {
    // verify required parameter 'cpe' is not null or undefined
    if (cpe === null || cpe === undefined || cpe === '') {
      throw new ParameterRequiredError('cpe');
    }
    return this.producer.getByCpe(cpe);
  }
  /**
   * Get specific product
   * @summary Get specific product
   * @param productId 
   * @openapi operation=getProduct path=/catalog/products/{productId} method=GET
   */
  public async get(productId: UUID): Promise<ProductExtendedGet> {
    // verify required parameter 'productId' is not null or undefined
    if (productId === null || productId === undefined) {
      throw new ParameterRequiredError('productId');
    }
    return this.producer.get(productId);
  }
  /**
   * Get specific product component
   * @summary Get specific product component
   * @param productId 
   * @param productComponentId 
   * @openapi operation=getProductComponent path=/catalog/products/{productId}/components/{productComponentId} method=GET
   */
  public async getComponent(productId: UUID, productComponentId: UUID): Promise<ProductComponentExtended> {
    // verify required parameter 'productId' is not null or undefined
    if (productId === null || productId === undefined) {
      throw new ParameterRequiredError('productId');
    }
    // verify required parameter 'productComponentId' is not null or undefined
    if (productComponentId === null || productComponentId === undefined) {
      throw new ParameterRequiredError('productComponentId');
    }
    return this.producer.getComponent(productId, productComponentId);
  }
  /**
   * Get specific product component version
   * @summary Get specific product component version
   * @param productId 
   * @param productComponentId 
   * @param versionId 
   * @openapi operation=getProductComponentVersion path=/catalog/products/{productId}/components/{productComponentId}/versions/{versionId} method=GET
   */
  public async getComponentVersion(productId: UUID, productComponentId: UUID, versionId: UUID): Promise<ProductComponentVersionExtended> {
    // verify required parameter 'productId' is not null or undefined
    if (productId === null || productId === undefined) {
      throw new ParameterRequiredError('productId');
    }
    // verify required parameter 'productComponentId' is not null or undefined
    if (productComponentId === null || productComponentId === undefined) {
      throw new ParameterRequiredError('productComponentId');
    }
    // verify required parameter 'versionId' is not null or undefined
    if (versionId === null || versionId === undefined) {
      throw new ParameterRequiredError('versionId');
    }
    return this.producer.getComponentVersion(productId, productComponentId, versionId);
  }
  /**
   * Get specific product component version
   * @summary Get specific product component version
   * @param productComponentVersionId 
   * @openapi operation=getProductComponentVersionDirect path=/catalog/productComponentVersions/{productComponentVersionId} method=GET
   */
  public async getProductComponentVersionDirect(productComponentVersionId: UUID): Promise<ProductComponentVersionExtended> {
    // verify required parameter 'productComponentVersionId' is not null or undefined
    if (productComponentVersionId === null || productComponentVersionId === undefined) {
      throw new ParameterRequiredError('productComponentVersionId');
    }
    return this.producer.getProductComponentVersionDirect(productComponentVersionId);
  }
  /**
   * Get specific product edition
   * @summary Get specific product edition
   * @param productId 
   * @param productEditionId 
   * @openapi operation=getProductEdition path=/catalog/products/{productId}/editions/{productEditionId} method=GET
   */
  public async getEdition(productId: UUID, productEditionId: UUID): Promise<ProductEditionExtended> {
    // verify required parameter 'productId' is not null or undefined
    if (productId === null || productId === undefined) {
      throw new ParameterRequiredError('productId');
    }
    // verify required parameter 'productEditionId' is not null or undefined
    if (productEditionId === null || productEditionId === undefined) {
      throw new ParameterRequiredError('productEditionId');
    }
    return this.producer.getEdition(productId, productEditionId);
  }
  /**
   * Get specific product edition version
   * @summary Get specific product edition version
   * @param productId 
   * @param productEditionId 
   * @param versionId 
   * @openapi operation=getProductEditionVersion path=/catalog/products/{productId}/editions/{productEditionId}/versions/{versionId} method=GET
   */
  public async getEditionVersion(productId: UUID, productEditionId: UUID, versionId: UUID): Promise<ProductEditionVersionExtended> {
    // verify required parameter 'productId' is not null or undefined
    if (productId === null || productId === undefined) {
      throw new ParameterRequiredError('productId');
    }
    // verify required parameter 'productEditionId' is not null or undefined
    if (productEditionId === null || productEditionId === undefined) {
      throw new ParameterRequiredError('productEditionId');
    }
    // verify required parameter 'versionId' is not null or undefined
    if (versionId === null || versionId === undefined) {
      throw new ParameterRequiredError('versionId');
    }
    return this.producer.getEditionVersion(productId, productEditionId, versionId);
  }
  /**
   * Get specific product edition version
   * @summary Get specific product edition version
   * @param productEditionVersionId 
   * @openapi operation=getProductEditionVersionDirect path=/catalog/productEditionVersions/{productEditionVersionId} method=GET
   */
  public async getProductEditionVersionDirect(productEditionVersionId: UUID): Promise<ProductEditionVersionExtended> {
    // verify required parameter 'productEditionVersionId' is not null or undefined
    if (productEditionVersionId === null || productEditionVersionId === undefined) {
      throw new ParameterRequiredError('productEditionVersionId');
    }
    return this.producer.getProductEditionVersionDirect(productEditionVersionId);
  }
  /**
   * Get specific product version
   * @summary Get specific product version
   * @param productId 
   * @param versionId 
   * @openapi operation=getProductVersion path=/catalog/products/{productId}/versions/{versionId} method=GET
   */
  public async getVersion(productId: UUID, versionId: UUID): Promise<ProductVersionExtendedGet> {
    // verify required parameter 'productId' is not null or undefined
    if (productId === null || productId === undefined) {
      throw new ParameterRequiredError('productId');
    }
    // verify required parameter 'versionId' is not null or undefined
    if (versionId === null || versionId === undefined) {
      throw new ParameterRequiredError('versionId');
    }
    return this.producer.getVersion(productId, versionId);
  }
  /**
   * Get specific product version
   * @summary Get specific product version
   * @param productVersionId 
   * @openapi operation=getProductVersionDirect path=/catalog/productVersions/{productVersionId} method=GET
   */
  public async getProductVersionDirect(productVersionId: UUID): Promise<ProductVersionExtendedGet> {
    // verify required parameter 'productVersionId' is not null or undefined
    if (productVersionId === null || productVersionId === undefined) {
      throw new ParameterRequiredError('productVersionId');
    }
    return this.producer.getProductVersionDirect(productVersionId);
  }
  /**
   * List product Cpe Version strings
   * @summary List product Cpe Version strings
   * @param id The product id
   * @param pageNumber The requested page. This value is 1-indexed.
   * @param pageSize The number of items in each page of data.
   * @openapi operation=listCpes path=/catalog/products/{id}/cpes method=GET
   */
  public async listCpes(id: UUID, pageNumber: number = 1, pageSize: number = 50): Promise<PagedResults<string>> {
    // verify required parameter 'id' is not null or undefined
    if (id === null || id === undefined) {
      throw new ParameterRequiredError('id');
    }
    if (pageNumber) {
      await Int32.parse(pageNumber);
    }
    if (pageSize) {
      await Int32.parse(pageSize);
    }
    const bag = new PagedResults<string>();
    bag.pageNumber = pageNumber;
    bag.pageSize = pageSize;
    await this.producer.listCpes(bag, id);
    if (bag.items === null || bag.items === undefined) {
      throw new UnexpectedError("Producers must return 'items' for PagedResults queries");
    }
    return bag;
  }
  /**
   * List product component versions
   * @summary List product component versions
   * @param productId 
   * @param productComponentId 
   * @param pageNumber The requested page. This value is 1-indexed.
   * @param pageSize The number of items in each page of data.
   * @openapi operation=listProductComponentVersions path=/catalog/products/{productId}/components/{productComponentId}/versions method=GET
   */
  public async listComponentVersions(productId: UUID, productComponentId: UUID, pageNumber: number = 1, pageSize: number = 50): Promise<PagedResults<ProductComponentVersionExtended>> {
    // verify required parameter 'productId' is not null or undefined
    if (productId === null || productId === undefined) {
      throw new ParameterRequiredError('productId');
    }
    // verify required parameter 'productComponentId' is not null or undefined
    if (productComponentId === null || productComponentId === undefined) {
      throw new ParameterRequiredError('productComponentId');
    }
    if (pageNumber) {
      await Int32.parse(pageNumber);
    }
    if (pageSize) {
      await Int32.parse(pageSize);
    }
    const bag = new PagedResults<ProductComponentVersionExtended>();
    bag.pageNumber = pageNumber;
    bag.pageSize = pageSize;
    await this.producer.listComponentVersions(bag, productId, productComponentId);
    if (bag.items === null || bag.items === undefined) {
      throw new UnexpectedError("Producers must return 'items' for PagedResults queries");
    }
    return bag;
  }
  /**
   * List product edition versions
   * @summary List product edition versions
   * @param productId 
   * @param productEditionId 
   * @param pageNumber The requested page. This value is 1-indexed.
   * @param pageSize The number of items in each page of data.
   * @openapi operation=listProductEditionVersions path=/catalog/products/{productId}/editions/{productEditionId}/versions method=GET
   */
  public async listEditionVersions(productId: UUID, productEditionId: UUID, pageNumber: number = 1, pageSize: number = 50): Promise<PagedResults<ProductEditionVersionExtended>> {
    // verify required parameter 'productId' is not null or undefined
    if (productId === null || productId === undefined) {
      throw new ParameterRequiredError('productId');
    }
    // verify required parameter 'productEditionId' is not null or undefined
    if (productEditionId === null || productEditionId === undefined) {
      throw new ParameterRequiredError('productEditionId');
    }
    if (pageNumber) {
      await Int32.parse(pageNumber);
    }
    if (pageSize) {
      await Int32.parse(pageSize);
    }
    const bag = new PagedResults<ProductEditionVersionExtended>();
    bag.pageNumber = pageNumber;
    bag.pageSize = pageSize;
    await this.producer.listEditionVersions(bag, productId, productEditionId);
    if (bag.items === null || bag.items === undefined) {
      throw new UnexpectedError("Producers must return 'items' for PagedResults queries");
    }
    return bag;
  }
  /**
   * List product versions
   * @summary List product versions
   * @param productId 
   * @param pageNumber The requested page. This value is 1-indexed.
   * @param pageSize The number of items in each page of data.
   * @openapi operation=listProductVersions path=/catalog/products/{productId}/versions method=GET
   */
  public async listVersions(productId: UUID, pageNumber: number = 1, pageSize: number = 50): Promise<PagedResults<ProductVersionExtended>> {
    // verify required parameter 'productId' is not null or undefined
    if (productId === null || productId === undefined) {
      throw new ParameterRequiredError('productId');
    }
    if (pageNumber) {
      await Int32.parse(pageNumber);
    }
    if (pageSize) {
      await Int32.parse(pageSize);
    }
    const bag = new PagedResults<ProductVersionExtended>();
    bag.pageNumber = pageNumber;
    bag.pageSize = pageSize;
    await this.producer.listVersions(bag, productId);
    if (bag.items === null || bag.items === undefined) {
      throw new UnexpectedError("Producers must return 'items' for PagedResults queries");
    }
    return bag;
  }
  /**
   * List products
   * @summary List products
   * @param pageNumber The requested page. This value is 1-indexed.
   * @param pageSize The number of items in each page of data.
   * @param vendorId 
   * @param suiteId 
   * @param status 
   * @param search 
   * @openapi operation=listProducts path=/catalog/products method=GET
   */
  public async list(pageNumber: number = 1, pageSize: number = 50, vendorId?: UUID, suiteId?: UUID, status?: CatalogPublishStatusEnumDef, search?: string): Promise<PagedResults<ProductExtended>> {
    if (pageNumber) {
      await Int32.parse(pageNumber);
    }
    if (pageSize) {
      await Int32.parse(pageSize);
    }
    const bag = new PagedResults<ProductExtended>();
    bag.pageNumber = pageNumber;
    bag.pageSize = pageSize;
    await this.producer.list(bag, vendorId, suiteId, status, search);
    if (bag.items === null || bag.items === undefined) {
      throw new UnexpectedError("Producers must return 'items' for PagedResults queries");
    }
    return bag;
  }
  /**
   * Adds and/or removes components from a product edition
   * @summary Adds and/or removes components from a product edition
   * @param productId 
   * @param productEditionId 
   * @param patchComponentsBody 
   * @openapi operation=patchEditionComponents path=/catalog/products/{productId}/editions/{productEditionId}/components method=PATCH
   */
  public async patchEditionComponents(productId: UUID, productEditionId: UUID, patchComponentsBody: PatchComponentsBody): Promise<ProductEditionExtended> {
    // verify required parameter 'productId' is not null or undefined
    if (productId === null || productId === undefined) {
      throw new ParameterRequiredError('productId');
    }
    // verify required parameter 'productEditionId' is not null or undefined
    if (productEditionId === null || productEditionId === undefined) {
      throw new ParameterRequiredError('productEditionId');
    }
    // verify required parameter 'patchComponentsBody' is not null or undefined
    if (patchComponentsBody === null || patchComponentsBody === undefined) {
      throw new ParameterRequiredError('patchComponentsBody');
    }
    return this.producer.patchEditionComponents(productId, productEditionId, patchComponentsBody);
  }
  /**
   * Patch a product
   * @summary Patch a product
   * @param productId 
   * @param patchProduct 
   * @openapi operation=patchProduct path=/catalog/products/{productId} method=PATCH
   */
  public async patch(productId: UUID, patchProduct: PatchProduct): Promise<ProductExtendedGet> {
    // verify required parameter 'productId' is not null or undefined
    if (productId === null || productId === undefined) {
      throw new ParameterRequiredError('productId');
    }
    // verify required parameter 'patchProduct' is not null or undefined
    if (patchProduct === null || patchProduct === undefined) {
      throw new ParameterRequiredError('patchProduct');
    }
    return this.producer.patch(productId, patchProduct);
  }
  /**
   * Patch a product component
   * @summary Patch a product component
   * @param productId 
   * @param productComponentId 
   * @param patchProductComponent 
   * @openapi operation=patchProductComponent path=/catalog/products/{productId}/components/{productComponentId} method=PATCH
   */
  public async patchComponent(productId: UUID, productComponentId: UUID, patchProductComponent: PatchProductComponent): Promise<ProductComponentExtended> {
    // verify required parameter 'productId' is not null or undefined
    if (productId === null || productId === undefined) {
      throw new ParameterRequiredError('productId');
    }
    // verify required parameter 'productComponentId' is not null or undefined
    if (productComponentId === null || productComponentId === undefined) {
      throw new ParameterRequiredError('productComponentId');
    }
    // verify required parameter 'patchProductComponent' is not null or undefined
    if (patchProductComponent === null || patchProductComponent === undefined) {
      throw new ParameterRequiredError('patchProductComponent');
    }
    return this.producer.patchComponent(productId, productComponentId, patchProductComponent);
  }
  /**
   * Adds and/or removes components from a product
   * @summary Adds and/or removes components from a product
   * @param productId 
   * @param patchComponentsBody 
   * @openapi operation=patchProductComponents path=/catalog/products/{productId}/components method=PATCH
   */
  public async patchProductComponents(productId: UUID, patchComponentsBody: PatchComponentsBody): Promise<ProductExtendedGet> {
    // verify required parameter 'productId' is not null or undefined
    if (productId === null || productId === undefined) {
      throw new ParameterRequiredError('productId');
    }
    // verify required parameter 'patchComponentsBody' is not null or undefined
    if (patchComponentsBody === null || patchComponentsBody === undefined) {
      throw new ParameterRequiredError('patchComponentsBody');
    }
    return this.producer.patchProductComponents(productId, patchComponentsBody);
  }
  /**
   * Patch a product edition
   * @summary Patch a product edition
   * @param productId 
   * @param productEditionId 
   * @param patchProductEdition 
   * @openapi operation=patchProductEdition path=/catalog/products/{productId}/editions/{productEditionId} method=PATCH
   */
  public async patchEdition(productId: UUID, productEditionId: UUID, patchProductEdition: PatchProductEdition): Promise<ProductEditionExtended> {
    // verify required parameter 'productId' is not null or undefined
    if (productId === null || productId === undefined) {
      throw new ParameterRequiredError('productId');
    }
    // verify required parameter 'productEditionId' is not null or undefined
    if (productEditionId === null || productEditionId === undefined) {
      throw new ParameterRequiredError('productEditionId');
    }
    // verify required parameter 'patchProductEdition' is not null or undefined
    if (patchProductEdition === null || patchProductEdition === undefined) {
      throw new ParameterRequiredError('patchProductEdition');
    }
    return this.producer.patchEdition(productId, productEditionId, patchProductEdition);
  }
  /**
   * Adds and/or removes features from a product edition
   * @summary Adds and/or removes features from a product edition
   * @param productId 
   * @param productEditionId 
   * @param patchComplianceFeaturesBody 
   * @openapi operation=patchProductEditionFeatures path=/catalog/products/{productId}/editions/{productEditionId}/features method=PATCH
   */
  public async patchEditionFeatures(productId: UUID, productEditionId: UUID, patchComplianceFeaturesBody: PatchComplianceFeaturesBody): Promise<ProductEditionExtended> {
    // verify required parameter 'productId' is not null or undefined
    if (productId === null || productId === undefined) {
      throw new ParameterRequiredError('productId');
    }
    // verify required parameter 'productEditionId' is not null or undefined
    if (productEditionId === null || productEditionId === undefined) {
      throw new ParameterRequiredError('productEditionId');
    }
    // verify required parameter 'patchComplianceFeaturesBody' is not null or undefined
    if (patchComplianceFeaturesBody === null || patchComplianceFeaturesBody === undefined) {
      throw new ParameterRequiredError('patchComplianceFeaturesBody');
    }
    return this.producer.patchEditionFeatures(productId, productEditionId, patchComplianceFeaturesBody);
  }
  /**
   * Adds and/or removes editions from a product
   * @summary Adds and/or removes editions from a product
   * @param productId 
   * @param patchEditionsBody 
   * @openapi operation=patchProductEditions path=/catalog/products/{productId}/editions method=PATCH
   */
  public async patchProductEditions(productId: UUID, patchEditionsBody: PatchEditionsBody): Promise<ProductExtendedGet> {
    // verify required parameter 'productId' is not null or undefined
    if (productId === null || productId === undefined) {
      throw new ParameterRequiredError('productId');
    }
    // verify required parameter 'patchEditionsBody' is not null or undefined
    if (patchEditionsBody === null || patchEditionsBody === undefined) {
      throw new ParameterRequiredError('patchEditionsBody');
    }
    return this.producer.patchProductEditions(productId, patchEditionsBody);
  }
  /**
   * Adds and/or removes segments from a product
   * @summary Adds and/or removes segments from a product
   * @param productId 
   * @param patchSegmentsBody 
   * @openapi operation=patchProductSegments path=/catalog/products/{productId}/segments method=PATCH
   */
  public async patchSegments(productId: UUID, patchSegmentsBody: PatchSegmentsBody): Promise<ProductExtendedGet> {
    // verify required parameter 'productId' is not null or undefined
    if (productId === null || productId === undefined) {
      throw new ParameterRequiredError('productId');
    }
    // verify required parameter 'patchSegmentsBody' is not null or undefined
    if (patchSegmentsBody === null || patchSegmentsBody === undefined) {
      throw new ParameterRequiredError('patchSegmentsBody');
    }
    return this.producer.patchSegments(productId, patchSegmentsBody);
  }
  /**
   * Suggests a new product operation
   * @summary Suggests a new product operation
   * @param id 
   * @param suggestProductOperationBody 
   * @openapi operation=suggestProductOperation path=/catalog/products/{id}/suggestOperation method=POST
   */
  public async suggestOperation(id: UUID, suggestProductOperationBody: SuggestProductOperationBody): Promise<Task> {
    // verify required parameter 'id' is not null or undefined
    if (id === null || id === undefined) {
      throw new ParameterRequiredError('id');
    }
    // verify required parameter 'suggestProductOperationBody' is not null or undefined
    if (suggestProductOperationBody === null || suggestProductOperationBody === undefined) {
      throw new ParameterRequiredError('suggestProductOperationBody');
    }
    return this.producer.suggestOperation(id, suggestProductOperationBody);
  }
  /**
   * Update a product component status
   * @summary Update a product component status
   * @param productId 
   * @param productComponentId 
   * @param updateProductComponent 
   * @openapi operation=updateProductComponentStatus path=/catalog/products/{productId}/components/{productComponentId} method=PUT
   */
  public async updateComponentStatus(productId: UUID, productComponentId: UUID, updateProductComponent: UpdateProductComponent): Promise<ProductComponentExtended> {
    // verify required parameter 'productId' is not null or undefined
    if (productId === null || productId === undefined) {
      throw new ParameterRequiredError('productId');
    }
    // verify required parameter 'productComponentId' is not null or undefined
    if (productComponentId === null || productComponentId === undefined) {
      throw new ParameterRequiredError('productComponentId');
    }
    // verify required parameter 'updateProductComponent' is not null or undefined
    if (updateProductComponent === null || updateProductComponent === undefined) {
      throw new ParameterRequiredError('updateProductComponent');
    }
    return this.producer.updateComponentStatus(productId, productComponentId, updateProductComponent);
  }
  /**
   * Update a product edition status
   * @summary Update a product edition status
   * @param productId 
   * @param productEditionId 
   * @param updateProductEdition 
   * @openapi operation=updateProductEditionStatus path=/catalog/products/{productId}/editions/{productEditionId} method=PUT
   */
  public async updateEditionStatus(productId: UUID, productEditionId: UUID, updateProductEdition: UpdateProductEdition): Promise<ProductEditionExtended> {
    // verify required parameter 'productId' is not null or undefined
    if (productId === null || productId === undefined) {
      throw new ParameterRequiredError('productId');
    }
    // verify required parameter 'productEditionId' is not null or undefined
    if (productEditionId === null || productEditionId === undefined) {
      throw new ParameterRequiredError('productEditionId');
    }
    // verify required parameter 'updateProductEdition' is not null or undefined
    if (updateProductEdition === null || updateProductEdition === undefined) {
      throw new ParameterRequiredError('updateProductEdition');
    }
    return this.producer.updateEditionStatus(productId, productEditionId, updateProductEdition);
  }
  /**
   * Update a product status
   * @summary Update a product status
   * @param productId 
   * @param updateProduct 
   * @openapi operation=updateProductStatus path=/catalog/products/{productId} method=PUT
   */
  public async updateStatus(productId: UUID, updateProduct: UpdateProduct): Promise<ProductExtendedGet> {
    // verify required parameter 'productId' is not null or undefined
    if (productId === null || productId === undefined) {
      throw new ParameterRequiredError('productId');
    }
    // verify required parameter 'updateProduct' is not null or undefined
    if (updateProduct === null || updateProduct === undefined) {
      throw new ParameterRequiredError('updateProduct');
    }
    return this.producer.updateStatus(productId, updateProduct);
  }
}

/**
 * Wrap producer with mapping implementation
 */
export function wrapProductProducer(producer: ProductProducerApi): ProductApi {
  return new ProductApiMappingImpl(producer);
}

/**
 * ProductApiHttpImpl - Direct HTTP implementation
 *
 * Makes direct HTTP calls to the API using Axios.
 * Used by SDK clients for platform service access.
 */
export class ProductApiHttpImpl implements ProductProducerApi {
  private client: AxiosInstance;
  private headers: Record<string, string>;

  constructor(client: AxiosInstance, headers: Record<string, string> = {}) {
    this.client = client;
    this.headers = headers;
  }

  async create(newProduct: NewProduct): Promise<ProductExtendedGet> {
  const _queryParams = {
      
  };
  const _bodyParams = {
      ...newProduct,
  };
  let _path = '/catalog/products';
  return this.client.post(
    _path,
    _bodyParams)
    .then((response) => {
      // BaseApiClient uses validateStatus: () => true, so we must check status manually
      if (response.status >= 400) {
        throw CoreError.deserialize(response.data);
      }
      return ObjectSerializer.deserialize(response.data, 'ProductExtendedGet')
    })
    .catch((error) => {
      if (error.data) {
        throw CoreError.deserialize(error.data);
      } else {
        throw error;
      }
    });
  }
  async createComponent(productId: UUID, newProductComponent: NewProductComponent): Promise<ProductComponentExtended> {
  const _queryParams = {
      
  };
  const _bodyParams = {
      newProductComponent,
  };
  let _path = '/catalog/products/{productId}/components';
  _path = _path.replace('{productId}', encodeURIComponent(String(productId)));
  return this.client.post(
    _path,
    _bodyParams)
    .then((response) => {
      // BaseApiClient uses validateStatus: () => true, so we must check status manually
      if (response.status >= 400) {
        throw CoreError.deserialize(response.data);
      }
      return ObjectSerializer.deserialize(response.data, 'ProductComponentExtended')
    })
    .catch((error) => {
      if (error.data) {
        throw CoreError.deserialize(error.data);
      } else {
        throw error;
      }
    });
  }
  async createEdition(productId: UUID, newProductEdition: NewProductEdition): Promise<ProductEditionExtended> {
  const _queryParams = {
      
  };
  const _bodyParams = {
      newProductEdition,
  };
  let _path = '/catalog/products/{productId}/editions';
  _path = _path.replace('{productId}', encodeURIComponent(String(productId)));
  return this.client.post(
    _path,
    _bodyParams)
    .then((response) => {
      // BaseApiClient uses validateStatus: () => true, so we must check status manually
      if (response.status >= 400) {
        throw CoreError.deserialize(response.data);
      }
      return ObjectSerializer.deserialize(response.data, 'ProductEditionExtended')
    })
    .catch((error) => {
      if (error.data) {
        throw CoreError.deserialize(error.data);
      } else {
        throw error;
      }
    });
  }
  async delete(productId: UUID): Promise<void> {
  const _queryParams = {
      
  };
  const _bodyParams = {
      
  };
  let _path = '/catalog/products/{productId}';
  _path = _path.replace('{productId}', encodeURIComponent(String(productId)));
  return this.client.delete(
    _path,
    { params: _queryParams })
    .then((response) => {
      // BaseApiClient uses validateStatus: () => true, so we must check status manually
      if (response.status >= 400) {
        throw CoreError.deserialize(response.data);
      }
      return ObjectSerializer.deserialize(response.data, '')
    })
    .catch((error) => {
      if (error.data) {
        throw CoreError.deserialize(error.data);
      } else {
        throw error;
      }
    });
  }
  async deleteComponent(productId: UUID, productComponentId: UUID): Promise<void> {
  const _queryParams = {
      
  };
  const _bodyParams = {
      
  };
  let _path = '/catalog/products/{productId}/components/{productComponentId}';
  _path = _path.replace('{productId}', encodeURIComponent(String(productId)));
  _path = _path.replace('{productComponentId}', encodeURIComponent(String(productComponentId)));
  return this.client.delete(
    _path,
    { params: _queryParams })
    .then((response) => {
      // BaseApiClient uses validateStatus: () => true, so we must check status manually
      if (response.status >= 400) {
        throw CoreError.deserialize(response.data);
      }
      return ObjectSerializer.deserialize(response.data, '')
    })
    .catch((error) => {
      if (error.data) {
        throw CoreError.deserialize(error.data);
      } else {
        throw error;
      }
    });
  }
  async deleteComponentVersion(productId: UUID, productComponentId: UUID, versionId: UUID): Promise<void> {
  const _queryParams = {
      
  };
  const _bodyParams = {
      
  };
  let _path = '/catalog/products/{productId}/components/{productComponentId}/versions/{versionId}';
  _path = _path.replace('{productId}', encodeURIComponent(String(productId)));
  _path = _path.replace('{productComponentId}', encodeURIComponent(String(productComponentId)));
  _path = _path.replace('{versionId}', encodeURIComponent(String(versionId)));
  return this.client.delete(
    _path,
    { params: _queryParams })
    .then((response) => {
      // BaseApiClient uses validateStatus: () => true, so we must check status manually
      if (response.status >= 400) {
        throw CoreError.deserialize(response.data);
      }
      return ObjectSerializer.deserialize(response.data, '')
    })
    .catch((error) => {
      if (error.data) {
        throw CoreError.deserialize(error.data);
      } else {
        throw error;
      }
    });
  }
  async deleteEdition(productId: UUID, productEditionId: UUID): Promise<void> {
  const _queryParams = {
      
  };
  const _bodyParams = {
      
  };
  let _path = '/catalog/products/{productId}/editions/{productEditionId}';
  _path = _path.replace('{productId}', encodeURIComponent(String(productId)));
  _path = _path.replace('{productEditionId}', encodeURIComponent(String(productEditionId)));
  return this.client.delete(
    _path,
    { params: _queryParams })
    .then((response) => {
      // BaseApiClient uses validateStatus: () => true, so we must check status manually
      if (response.status >= 400) {
        throw CoreError.deserialize(response.data);
      }
      return ObjectSerializer.deserialize(response.data, '')
    })
    .catch((error) => {
      if (error.data) {
        throw CoreError.deserialize(error.data);
      } else {
        throw error;
      }
    });
  }
  async deleteEditionVersion(productId: UUID, productEditionId: UUID, versionId: UUID): Promise<void> {
  const _queryParams = {
      
  };
  const _bodyParams = {
      
  };
  let _path = '/catalog/products/{productId}/editions/{productEditionId}/versions/{versionId}';
  _path = _path.replace('{productId}', encodeURIComponent(String(productId)));
  _path = _path.replace('{productEditionId}', encodeURIComponent(String(productEditionId)));
  _path = _path.replace('{versionId}', encodeURIComponent(String(versionId)));
  return this.client.delete(
    _path,
    { params: _queryParams })
    .then((response) => {
      // BaseApiClient uses validateStatus: () => true, so we must check status manually
      if (response.status >= 400) {
        throw CoreError.deserialize(response.data);
      }
      return ObjectSerializer.deserialize(response.data, '')
    })
    .catch((error) => {
      if (error.data) {
        throw CoreError.deserialize(error.data);
      } else {
        throw error;
      }
    });
  }
  async deleteVersion(productId: UUID, versionId: UUID): Promise<void> {
  const _queryParams = {
      
  };
  const _bodyParams = {
      
  };
  let _path = '/catalog/products/{productId}/versions/{versionId}';
  _path = _path.replace('{productId}', encodeURIComponent(String(productId)));
  _path = _path.replace('{versionId}', encodeURIComponent(String(versionId)));
  return this.client.delete(
    _path,
    { params: _queryParams })
    .then((response) => {
      // BaseApiClient uses validateStatus: () => true, so we must check status manually
      if (response.status >= 400) {
        throw CoreError.deserialize(response.data);
      }
      return ObjectSerializer.deserialize(response.data, '')
    })
    .catch((error) => {
      if (error.data) {
        throw CoreError.deserialize(error.data);
      } else {
        throw error;
      }
    });
  }
  async getByCpe(cpe: string): Promise<Product> {
  const _queryParams = {
      
  };
  const _bodyParams = {
      
  };
  let _path = '/catalog/cpes/{cpe}';
  _path = _path.replace('{cpe}', encodeURIComponent(String(cpe)));
  return this.client.get(
    _path,
    { params: _queryParams })
    .then((response) => {
      // BaseApiClient uses validateStatus: () => true, so we must check status manually
      if (response.status >= 400) {
        throw CoreError.deserialize(response.data);
      }
      return ObjectSerializer.deserialize(response.data, 'Product')
    })
    .catch((error) => {
      if (error.data) {
        throw CoreError.deserialize(error.data);
      } else {
        throw error;
      }
    });
  }
  async get(productId: UUID): Promise<ProductExtendedGet> {
  const _queryParams = {
      
  };
  const _bodyParams = {
      
  };
  let _path = '/catalog/products/{productId}';
  _path = _path.replace('{productId}', encodeURIComponent(String(productId)));
  return this.client.get(
    _path,
    { params: _queryParams })
    .then((response) => {
      // BaseApiClient uses validateStatus: () => true, so we must check status manually
      if (response.status >= 400) {
        throw CoreError.deserialize(response.data);
      }
      return ObjectSerializer.deserialize(response.data, 'ProductExtendedGet')
    })
    .catch((error) => {
      if (error.data) {
        throw CoreError.deserialize(error.data);
      } else {
        throw error;
      }
    });
  }
  async getComponent(productId: UUID, productComponentId: UUID): Promise<ProductComponentExtended> {
  const _queryParams = {
      
  };
  const _bodyParams = {
      
  };
  let _path = '/catalog/products/{productId}/components/{productComponentId}';
  _path = _path.replace('{productId}', encodeURIComponent(String(productId)));
  _path = _path.replace('{productComponentId}', encodeURIComponent(String(productComponentId)));
  return this.client.get(
    _path,
    { params: _queryParams })
    .then((response) => {
      // BaseApiClient uses validateStatus: () => true, so we must check status manually
      if (response.status >= 400) {
        throw CoreError.deserialize(response.data);
      }
      return ObjectSerializer.deserialize(response.data, 'ProductComponentExtended')
    })
    .catch((error) => {
      if (error.data) {
        throw CoreError.deserialize(error.data);
      } else {
        throw error;
      }
    });
  }
  async getComponentVersion(productId: UUID, productComponentId: UUID, versionId: UUID): Promise<ProductComponentVersionExtended> {
  const _queryParams = {
      
  };
  const _bodyParams = {
      
  };
  let _path = '/catalog/products/{productId}/components/{productComponentId}/versions/{versionId}';
  _path = _path.replace('{productId}', encodeURIComponent(String(productId)));
  _path = _path.replace('{productComponentId}', encodeURIComponent(String(productComponentId)));
  _path = _path.replace('{versionId}', encodeURIComponent(String(versionId)));
  return this.client.get(
    _path,
    { params: _queryParams })
    .then((response) => {
      // BaseApiClient uses validateStatus: () => true, so we must check status manually
      if (response.status >= 400) {
        throw CoreError.deserialize(response.data);
      }
      return ObjectSerializer.deserialize(response.data, 'ProductComponentVersionExtended')
    })
    .catch((error) => {
      if (error.data) {
        throw CoreError.deserialize(error.data);
      } else {
        throw error;
      }
    });
  }
  async getProductComponentVersionDirect(productComponentVersionId: UUID): Promise<ProductComponentVersionExtended> {
  const _queryParams = {
      
  };
  const _bodyParams = {
      
  };
  let _path = '/catalog/productComponentVersions/{productComponentVersionId}';
  _path = _path.replace('{productComponentVersionId}', encodeURIComponent(String(productComponentVersionId)));
  return this.client.get(
    _path,
    { params: _queryParams })
    .then((response) => {
      // BaseApiClient uses validateStatus: () => true, so we must check status manually
      if (response.status >= 400) {
        throw CoreError.deserialize(response.data);
      }
      return ObjectSerializer.deserialize(response.data, 'ProductComponentVersionExtended')
    })
    .catch((error) => {
      if (error.data) {
        throw CoreError.deserialize(error.data);
      } else {
        throw error;
      }
    });
  }
  async getEdition(productId: UUID, productEditionId: UUID): Promise<ProductEditionExtended> {
  const _queryParams = {
      
  };
  const _bodyParams = {
      
  };
  let _path = '/catalog/products/{productId}/editions/{productEditionId}';
  _path = _path.replace('{productId}', encodeURIComponent(String(productId)));
  _path = _path.replace('{productEditionId}', encodeURIComponent(String(productEditionId)));
  return this.client.get(
    _path,
    { params: _queryParams })
    .then((response) => {
      // BaseApiClient uses validateStatus: () => true, so we must check status manually
      if (response.status >= 400) {
        throw CoreError.deserialize(response.data);
      }
      return ObjectSerializer.deserialize(response.data, 'ProductEditionExtended')
    })
    .catch((error) => {
      if (error.data) {
        throw CoreError.deserialize(error.data);
      } else {
        throw error;
      }
    });
  }
  async getEditionVersion(productId: UUID, productEditionId: UUID, versionId: UUID): Promise<ProductEditionVersionExtended> {
  const _queryParams = {
      
  };
  const _bodyParams = {
      
  };
  let _path = '/catalog/products/{productId}/editions/{productEditionId}/versions/{versionId}';
  _path = _path.replace('{productId}', encodeURIComponent(String(productId)));
  _path = _path.replace('{productEditionId}', encodeURIComponent(String(productEditionId)));
  _path = _path.replace('{versionId}', encodeURIComponent(String(versionId)));
  return this.client.get(
    _path,
    { params: _queryParams })
    .then((response) => {
      // BaseApiClient uses validateStatus: () => true, so we must check status manually
      if (response.status >= 400) {
        throw CoreError.deserialize(response.data);
      }
      return ObjectSerializer.deserialize(response.data, 'ProductEditionVersionExtended')
    })
    .catch((error) => {
      if (error.data) {
        throw CoreError.deserialize(error.data);
      } else {
        throw error;
      }
    });
  }
  async getProductEditionVersionDirect(productEditionVersionId: UUID): Promise<ProductEditionVersionExtended> {
  const _queryParams = {
      
  };
  const _bodyParams = {
      
  };
  let _path = '/catalog/productEditionVersions/{productEditionVersionId}';
  _path = _path.replace('{productEditionVersionId}', encodeURIComponent(String(productEditionVersionId)));
  return this.client.get(
    _path,
    { params: _queryParams })
    .then((response) => {
      // BaseApiClient uses validateStatus: () => true, so we must check status manually
      if (response.status >= 400) {
        throw CoreError.deserialize(response.data);
      }
      return ObjectSerializer.deserialize(response.data, 'ProductEditionVersionExtended')
    })
    .catch((error) => {
      if (error.data) {
        throw CoreError.deserialize(error.data);
      } else {
        throw error;
      }
    });
  }
  async getVersion(productId: UUID, versionId: UUID): Promise<ProductVersionExtendedGet> {
  const _queryParams = {
      
  };
  const _bodyParams = {
      
  };
  let _path = '/catalog/products/{productId}/versions/{versionId}';
  _path = _path.replace('{productId}', encodeURIComponent(String(productId)));
  _path = _path.replace('{versionId}', encodeURIComponent(String(versionId)));
  return this.client.get(
    _path,
    { params: _queryParams })
    .then((response) => {
      // BaseApiClient uses validateStatus: () => true, so we must check status manually
      if (response.status >= 400) {
        throw CoreError.deserialize(response.data);
      }
      return ObjectSerializer.deserialize(response.data, 'ProductVersionExtendedGet')
    })
    .catch((error) => {
      if (error.data) {
        throw CoreError.deserialize(error.data);
      } else {
        throw error;
      }
    });
  }
  async getProductVersionDirect(productVersionId: UUID): Promise<ProductVersionExtendedGet> {
  const _queryParams = {
      
  };
  const _bodyParams = {
      
  };
  let _path = '/catalog/productVersions/{productVersionId}';
  _path = _path.replace('{productVersionId}', encodeURIComponent(String(productVersionId)));
  return this.client.get(
    _path,
    { params: _queryParams })
    .then((response) => {
      // BaseApiClient uses validateStatus: () => true, so we must check status manually
      if (response.status >= 400) {
        throw CoreError.deserialize(response.data);
      }
      return ObjectSerializer.deserialize(response.data, 'ProductVersionExtendedGet')
    })
    .catch((error) => {
      if (error.data) {
        throw CoreError.deserialize(error.data);
      } else {
        throw error;
      }
    });
  }
  async listCpes(results: PagedResults<string>, id: UUID): Promise<void> {
  const _body = {
      id,
  };
  let _path = '/catalog/products/{id}/cpes';
  _path = _path.replace('{id}', encodeURIComponent(String(id)));
  return this.client.get(
    _path,
    {
      params: {
        ..._body,
        pageNumber: results.pageNumber,
        pageSize: results.pageSize,
      }
    })
    .then((response) => {
      // BaseApiClient uses validateStatus: () => true, so we must check status manually
      if (response.status >= 400) {
        throw CoreError.deserialize(response.data);
      }
      results.items = ObjectSerializer.deserialize(response.data, 'Array<string>');
      results.count = response.headers.count ? Number(response.headers.count) : -1;
      results.pageToken = response.headers.pagetoken ?? response.headers.pageToken;
      results.headers = this.headers;
      results.baseUrl = new URL(`${this.client.getUri()}/catalog/products/{id}/cpes`);
      results.httpMethod = HttpMethod.Get;
      results.body = _body;
      results.mapper = (obj) => ObjectSerializer.deserialize(obj, 'string');
    })
    .catch((error) => {
      if (error.data) {
        throw CoreError.deserialize(error.data);
      } else {
        throw error;
      }
    });
  }
  async listComponentVersions(results: PagedResults<ProductComponentVersionExtended>, productId: UUID, productComponentId: UUID): Promise<void> {
  const _body = {
      productId,productComponentId,
  };
  let _path = '/catalog/products/{productId}/components/{productComponentId}/versions';
  _path = _path.replace('{productId}', encodeURIComponent(String(productId)));
  _path = _path.replace('{productComponentId}', encodeURIComponent(String(productComponentId)));
  return this.client.get(
    _path,
    {
      params: {
        ..._body,
        pageNumber: results.pageNumber,
        pageSize: results.pageSize,
      }
    })
    .then((response) => {
      // BaseApiClient uses validateStatus: () => true, so we must check status manually
      if (response.status >= 400) {
        throw CoreError.deserialize(response.data);
      }
      results.items = ObjectSerializer.deserialize(response.data, 'Array<ProductComponentVersionExtended>');
      results.count = response.headers.count ? Number(response.headers.count) : -1;
      results.pageToken = response.headers.pagetoken ?? response.headers.pageToken;
      results.headers = this.headers;
      results.baseUrl = new URL(`${this.client.getUri()}/catalog/products/{productId}/components/{productComponentId}/versions`);
      results.httpMethod = HttpMethod.Get;
      results.body = _body;
      results.mapper = (obj) => ObjectSerializer.deserialize(obj, 'ProductComponentVersionExtended');
    })
    .catch((error) => {
      if (error.data) {
        throw CoreError.deserialize(error.data);
      } else {
        throw error;
      }
    });
  }
  async listEditionVersions(results: PagedResults<ProductEditionVersionExtended>, productId: UUID, productEditionId: UUID): Promise<void> {
  const _body = {
      productId,productEditionId,
  };
  let _path = '/catalog/products/{productId}/editions/{productEditionId}/versions';
  _path = _path.replace('{productId}', encodeURIComponent(String(productId)));
  _path = _path.replace('{productEditionId}', encodeURIComponent(String(productEditionId)));
  return this.client.get(
    _path,
    {
      params: {
        ..._body,
        pageNumber: results.pageNumber,
        pageSize: results.pageSize,
      }
    })
    .then((response) => {
      // BaseApiClient uses validateStatus: () => true, so we must check status manually
      if (response.status >= 400) {
        throw CoreError.deserialize(response.data);
      }
      results.items = ObjectSerializer.deserialize(response.data, 'Array<ProductEditionVersionExtended>');
      results.count = response.headers.count ? Number(response.headers.count) : -1;
      results.pageToken = response.headers.pagetoken ?? response.headers.pageToken;
      results.headers = this.headers;
      results.baseUrl = new URL(`${this.client.getUri()}/catalog/products/{productId}/editions/{productEditionId}/versions`);
      results.httpMethod = HttpMethod.Get;
      results.body = _body;
      results.mapper = (obj) => ObjectSerializer.deserialize(obj, 'ProductEditionVersionExtended');
    })
    .catch((error) => {
      if (error.data) {
        throw CoreError.deserialize(error.data);
      } else {
        throw error;
      }
    });
  }
  async listVersions(results: PagedResults<ProductVersionExtended>, productId: UUID): Promise<void> {
  const _body = {
      productId,
  };
  let _path = '/catalog/products/{productId}/versions';
  _path = _path.replace('{productId}', encodeURIComponent(String(productId)));
  return this.client.get(
    _path,
    {
      params: {
        ..._body,
        pageNumber: results.pageNumber,
        pageSize: results.pageSize,
      }
    })
    .then((response) => {
      // BaseApiClient uses validateStatus: () => true, so we must check status manually
      if (response.status >= 400) {
        throw CoreError.deserialize(response.data);
      }
      results.items = ObjectSerializer.deserialize(response.data, 'Array<ProductVersionExtended>');
      results.count = response.headers.count ? Number(response.headers.count) : -1;
      results.pageToken = response.headers.pagetoken ?? response.headers.pageToken;
      results.headers = this.headers;
      results.baseUrl = new URL(`${this.client.getUri()}/catalog/products/{productId}/versions`);
      results.httpMethod = HttpMethod.Get;
      results.body = _body;
      results.mapper = (obj) => ObjectSerializer.deserialize(obj, 'ProductVersionExtended');
    })
    .catch((error) => {
      if (error.data) {
        throw CoreError.deserialize(error.data);
      } else {
        throw error;
      }
    });
  }
  async list(results: PagedResults<ProductExtended>, vendorId?: UUID, suiteId?: UUID, status?: CatalogPublishStatusEnumDef, search?: string): Promise<void> {
  const _body = {
      vendorId,suiteId,status,search,
  };
  let _path = '/catalog/products';
  return this.client.get(
    _path,
    {
      params: {
        ..._body,
        pageNumber: results.pageNumber,
        pageSize: results.pageSize,
      }
    })
    .then((response) => {
      // BaseApiClient uses validateStatus: () => true, so we must check status manually
      if (response.status >= 400) {
        throw CoreError.deserialize(response.data);
      }
      results.items = ObjectSerializer.deserialize(response.data, 'Array<ProductExtended>');
      results.count = response.headers.count ? Number(response.headers.count) : -1;
      results.pageToken = response.headers.pagetoken ?? response.headers.pageToken;
      results.headers = this.headers;
      results.baseUrl = new URL(`${this.client.getUri()}/catalog/products`);
      results.httpMethod = HttpMethod.Get;
      results.body = _body;
      results.mapper = (obj) => ObjectSerializer.deserialize(obj, 'ProductExtended');
    })
    .catch((error) => {
      if (error.data) {
        throw CoreError.deserialize(error.data);
      } else {
        throw error;
      }
    });
  }
  async patchEditionComponents(productId: UUID, productEditionId: UUID, patchComponentsBody: PatchComponentsBody): Promise<ProductEditionExtended> {
  const _queryParams = {
      
  };
  const _bodyParams = {
      patchComponentsBody,
  };
  let _path = '/catalog/products/{productId}/editions/{productEditionId}/components';
  _path = _path.replace('{productId}', encodeURIComponent(String(productId)));
  _path = _path.replace('{productEditionId}', encodeURIComponent(String(productEditionId)));
  return this.client.patch(
    _path,
    _bodyParams)
    .then((response) => {
      // BaseApiClient uses validateStatus: () => true, so we must check status manually
      if (response.status >= 400) {
        throw CoreError.deserialize(response.data);
      }
      return ObjectSerializer.deserialize(response.data, 'ProductEditionExtended')
    })
    .catch((error) => {
      if (error.data) {
        throw CoreError.deserialize(error.data);
      } else {
        throw error;
      }
    });
  }
  async patch(productId: UUID, patchProduct: PatchProduct): Promise<ProductExtendedGet> {
  const _queryParams = {
      
  };
  const _bodyParams = {
      patchProduct,
  };
  let _path = '/catalog/products/{productId}';
  _path = _path.replace('{productId}', encodeURIComponent(String(productId)));
  return this.client.patch(
    _path,
    _bodyParams)
    .then((response) => {
      // BaseApiClient uses validateStatus: () => true, so we must check status manually
      if (response.status >= 400) {
        throw CoreError.deserialize(response.data);
      }
      return ObjectSerializer.deserialize(response.data, 'ProductExtendedGet')
    })
    .catch((error) => {
      if (error.data) {
        throw CoreError.deserialize(error.data);
      } else {
        throw error;
      }
    });
  }
  async patchComponent(productId: UUID, productComponentId: UUID, patchProductComponent: PatchProductComponent): Promise<ProductComponentExtended> {
  const _queryParams = {
      
  };
  const _bodyParams = {
      patchProductComponent,
  };
  let _path = '/catalog/products/{productId}/components/{productComponentId}';
  _path = _path.replace('{productId}', encodeURIComponent(String(productId)));
  _path = _path.replace('{productComponentId}', encodeURIComponent(String(productComponentId)));
  return this.client.patch(
    _path,
    _bodyParams)
    .then((response) => {
      // BaseApiClient uses validateStatus: () => true, so we must check status manually
      if (response.status >= 400) {
        throw CoreError.deserialize(response.data);
      }
      return ObjectSerializer.deserialize(response.data, 'ProductComponentExtended')
    })
    .catch((error) => {
      if (error.data) {
        throw CoreError.deserialize(error.data);
      } else {
        throw error;
      }
    });
  }
  async patchProductComponents(productId: UUID, patchComponentsBody: PatchComponentsBody): Promise<ProductExtendedGet> {
  const _queryParams = {
      
  };
  const _bodyParams = {
      patchComponentsBody,
  };
  let _path = '/catalog/products/{productId}/components';
  _path = _path.replace('{productId}', encodeURIComponent(String(productId)));
  return this.client.patch(
    _path,
    _bodyParams)
    .then((response) => {
      // BaseApiClient uses validateStatus: () => true, so we must check status manually
      if (response.status >= 400) {
        throw CoreError.deserialize(response.data);
      }
      return ObjectSerializer.deserialize(response.data, 'ProductExtendedGet')
    })
    .catch((error) => {
      if (error.data) {
        throw CoreError.deserialize(error.data);
      } else {
        throw error;
      }
    });
  }
  async patchEdition(productId: UUID, productEditionId: UUID, patchProductEdition: PatchProductEdition): Promise<ProductEditionExtended> {
  const _queryParams = {
      
  };
  const _bodyParams = {
      patchProductEdition,
  };
  let _path = '/catalog/products/{productId}/editions/{productEditionId}';
  _path = _path.replace('{productId}', encodeURIComponent(String(productId)));
  _path = _path.replace('{productEditionId}', encodeURIComponent(String(productEditionId)));
  return this.client.patch(
    _path,
    _bodyParams)
    .then((response) => {
      // BaseApiClient uses validateStatus: () => true, so we must check status manually
      if (response.status >= 400) {
        throw CoreError.deserialize(response.data);
      }
      return ObjectSerializer.deserialize(response.data, 'ProductEditionExtended')
    })
    .catch((error) => {
      if (error.data) {
        throw CoreError.deserialize(error.data);
      } else {
        throw error;
      }
    });
  }
  async patchEditionFeatures(productId: UUID, productEditionId: UUID, patchComplianceFeaturesBody: PatchComplianceFeaturesBody): Promise<ProductEditionExtended> {
  const _queryParams = {
      
  };
  const _bodyParams = {
      patchComplianceFeaturesBody,
  };
  let _path = '/catalog/products/{productId}/editions/{productEditionId}/features';
  _path = _path.replace('{productId}', encodeURIComponent(String(productId)));
  _path = _path.replace('{productEditionId}', encodeURIComponent(String(productEditionId)));
  return this.client.patch(
    _path,
    _bodyParams)
    .then((response) => {
      // BaseApiClient uses validateStatus: () => true, so we must check status manually
      if (response.status >= 400) {
        throw CoreError.deserialize(response.data);
      }
      return ObjectSerializer.deserialize(response.data, 'ProductEditionExtended')
    })
    .catch((error) => {
      if (error.data) {
        throw CoreError.deserialize(error.data);
      } else {
        throw error;
      }
    });
  }
  async patchProductEditions(productId: UUID, patchEditionsBody: PatchEditionsBody): Promise<ProductExtendedGet> {
  const _queryParams = {
      
  };
  const _bodyParams = {
      patchEditionsBody,
  };
  let _path = '/catalog/products/{productId}/editions';
  _path = _path.replace('{productId}', encodeURIComponent(String(productId)));
  return this.client.patch(
    _path,
    _bodyParams)
    .then((response) => {
      // BaseApiClient uses validateStatus: () => true, so we must check status manually
      if (response.status >= 400) {
        throw CoreError.deserialize(response.data);
      }
      return ObjectSerializer.deserialize(response.data, 'ProductExtendedGet')
    })
    .catch((error) => {
      if (error.data) {
        throw CoreError.deserialize(error.data);
      } else {
        throw error;
      }
    });
  }
  async patchSegments(productId: UUID, patchSegmentsBody: PatchSegmentsBody): Promise<ProductExtendedGet> {
  const _queryParams = {
      
  };
  const _bodyParams = {
      patchSegmentsBody,
  };
  let _path = '/catalog/products/{productId}/segments';
  _path = _path.replace('{productId}', encodeURIComponent(String(productId)));
  return this.client.patch(
    _path,
    _bodyParams)
    .then((response) => {
      // BaseApiClient uses validateStatus: () => true, so we must check status manually
      if (response.status >= 400) {
        throw CoreError.deserialize(response.data);
      }
      return ObjectSerializer.deserialize(response.data, 'ProductExtendedGet')
    })
    .catch((error) => {
      if (error.data) {
        throw CoreError.deserialize(error.data);
      } else {
        throw error;
      }
    });
  }
  async suggestOperation(id: UUID, suggestProductOperationBody: SuggestProductOperationBody): Promise<Task> {
  const _queryParams = {
      
  };
  const _bodyParams = {
      suggestProductOperationBody,
  };
  let _path = '/catalog/products/{id}/suggestOperation';
  _path = _path.replace('{id}', encodeURIComponent(String(id)));
  return this.client.post(
    _path,
    _bodyParams)
    .then((response) => {
      // BaseApiClient uses validateStatus: () => true, so we must check status manually
      if (response.status >= 400) {
        throw CoreError.deserialize(response.data);
      }
      return ObjectSerializer.deserialize(response.data, 'Task')
    })
    .catch((error) => {
      if (error.data) {
        throw CoreError.deserialize(error.data);
      } else {
        throw error;
      }
    });
  }
  async updateComponentStatus(productId: UUID, productComponentId: UUID, updateProductComponent: UpdateProductComponent): Promise<ProductComponentExtended> {
  const _queryParams = {
      
  };
  const _bodyParams = {
      updateProductComponent,
  };
  let _path = '/catalog/products/{productId}/components/{productComponentId}';
  _path = _path.replace('{productId}', encodeURIComponent(String(productId)));
  _path = _path.replace('{productComponentId}', encodeURIComponent(String(productComponentId)));
  return this.client.put(
    _path,
    _bodyParams)
    .then((response) => {
      // BaseApiClient uses validateStatus: () => true, so we must check status manually
      if (response.status >= 400) {
        throw CoreError.deserialize(response.data);
      }
      return ObjectSerializer.deserialize(response.data, 'ProductComponentExtended')
    })
    .catch((error) => {
      if (error.data) {
        throw CoreError.deserialize(error.data);
      } else {
        throw error;
      }
    });
  }
  async updateEditionStatus(productId: UUID, productEditionId: UUID, updateProductEdition: UpdateProductEdition): Promise<ProductEditionExtended> {
  const _queryParams = {
      
  };
  const _bodyParams = {
      updateProductEdition,
  };
  let _path = '/catalog/products/{productId}/editions/{productEditionId}';
  _path = _path.replace('{productId}', encodeURIComponent(String(productId)));
  _path = _path.replace('{productEditionId}', encodeURIComponent(String(productEditionId)));
  return this.client.put(
    _path,
    _bodyParams)
    .then((response) => {
      // BaseApiClient uses validateStatus: () => true, so we must check status manually
      if (response.status >= 400) {
        throw CoreError.deserialize(response.data);
      }
      return ObjectSerializer.deserialize(response.data, 'ProductEditionExtended')
    })
    .catch((error) => {
      if (error.data) {
        throw CoreError.deserialize(error.data);
      } else {
        throw error;
      }
    });
  }
  async updateStatus(productId: UUID, updateProduct: UpdateProduct): Promise<ProductExtendedGet> {
  const _queryParams = {
      
  };
  const _bodyParams = {
      updateProduct,
  };
  let _path = '/catalog/products/{productId}';
  _path = _path.replace('{productId}', encodeURIComponent(String(productId)));
  return this.client.put(
    _path,
    _bodyParams)
    .then((response) => {
      // BaseApiClient uses validateStatus: () => true, so we must check status manually
      if (response.status >= 400) {
        throw CoreError.deserialize(response.data);
      }
      return ObjectSerializer.deserialize(response.data, 'ProductExtendedGet')
    })
    .catch((error) => {
      if (error.data) {
        throw CoreError.deserialize(error.data);
      } else {
        throw error;
      }
    });
  }
}
