/* eslint-disable */
// ===============================================
// This file is autogenerated - Please do not edit
// ===============================================
import { AxiosInstance } from 'axios';
import { AlertSubscriptionExtended, Audit, AuditExtended, AuditStatusEnumDef, AuditTypeEnumDef, Boundary, BoundaryAlertBotExtended, BoundaryAlertExtended, BoundaryAlertSubjectExtended, BoundaryAlertView, BoundaryAuditMetrics, BoundaryComponentExtended, BoundaryConnectionForList, BoundaryConnectionOverview, BoundaryCrosswalkVersionExtended, BoundaryDomainSummary, BoundaryEvent, BoundaryEvidence, BoundaryEvidenceSortColumnsDef, BoundaryEvidenceStatusEnumDef, BoundaryExtended, BoundaryFrameworkControlTreeNode, BoundaryFrameworkControlsOverview, BoundaryKeywordSearchBody, BoundaryKeywordSearchForClassResult, BoundaryKeywordSearchResult, BoundaryMetric, BoundaryObjectCountFilter, BoundaryObjectCountResult, BoundaryObjectSearchFilter, BoundaryObjectSearchResultsMetadata, BoundaryPartyRoleExtended, BoundaryProduct, BoundaryProductAny, BoundaryProductExtended, BoundaryProductForList, BoundaryProductForListStatusDef, BoundaryProductOverview, BoundaryProductPipeline, BoundaryProductProcessedResponse, BoundaryProductTarget, BoundaryProductTargetProcessedResponse, BoundaryRoleExtended, BoundarySearchFilter, BoundarySearchResult, BoundaryStandardBaselineExtended, BoundaryStatusEnumDef, BoundarySuggestedProduct, BoundarySuggestedProductOverview, BoundaryTaskMetrics, BoundaryTeam, BoundaryTeamDomainSummary, BoundaryTeamMetrics, BoundaryTeamScfControl, BoundaryTeamScfControlEvidenceDefinitionImplementation, BoundaryTeamScfControlOverview, BoundaryTypeEnumDef, CatalogPublishStatusEnumDef, CreateBoundaryEvidenceCounts, DeleteBoundaryProduct, DeleteBoundaryProductTarget, ElementExtended, EnableBoundaryTeamScfControlEvidenceDefinition, ExecuteGraphqlQuery, ExecuteGraphqlQueryResult, ExtendedBoundaryEvent, ExtendedBoundaryEvidence, ExtendedBoundaryProduct, ExtendedBoundaryProductTarget, ExtendedBoundaryScfControl, NewAlertSubscription, NewBoundary, NewBoundaryAlertBot, NewBoundaryCrosswalkVersion, NewBoundaryEvent, NewBoundaryParty, NewBoundaryPartyRole, NewBoundaryProduct, NewBoundaryProductTarget, NewBoundaryStandardBaseline, NewBoundaryStandardBaselineElements, NewBoundaryTeam, NewSuggestedProduct, PartyExtended, PartyTypeEnumDef, Pipeline, PipelineAdminStatusEnumDef, PipelineExecutionStatusEnumDef, PipelineFormatEnumDef, RaciRollup, ScfDomain, SortObject, SortOrderOptionsDef, StandardFilterTreeNode, SuggestedProduct, TestExtended, TestResultEnumDef, UpdateBoundary, UpdateBoundaryAlertBot, UpdateBoundaryEvidence, UpdateBoundaryProduct, UpdateBoundaryScfControl, UpdateBoundaryTeam, UpdateBoundaryTeamScfControl, UpdateBoundaryTeamScfControlEvidenceDefinition, UpsertBoundaryProducts } from '../model/index.js';
import { URL, EnumValue, IllegalArgumentError, PagedResults, Int32, UUID, CoreError, ParameterRequiredError, UnexpectedError, HttpMethod } from '@zerobias-org/types-core-js';
import { RequestFile, ObjectSerializer } from '../model/index.js';

export namespace BoundaryApi {
}

/**
 * BoundaryApi - interface
 * @export
 * @interface BoundaryApi
 */
export interface BoundaryApi {
  /**
   * Add crosswalk versions to boundary
   * @summary Add crosswalk versions to boundary
   * @param {UUID} boundaryId 
   * @param {NewBoundaryCrosswalkVersion} newBoundaryCrosswalkVersion 
   * @param {*} [options] Override http request option.
   * @throws {@link @zerobias-org/types-core-js#ParameterRequiredError} if any required parameter is not provided
   * @example
   * ```typescript
   * const result = await api.addCrosswalkVersion('00000000-0000-0000-0000-000000000000', null);
   * ```
   * @openapi operation=addBoundaryCrosswalkVersion path=/app/boundaries/{boundaryId}/crosswalkVersions method=POST
   * @memberof BoundaryApi
   */
  addCrosswalkVersion(boundaryId: UUID, newBoundaryCrosswalkVersion: NewBoundaryCrosswalkVersion): Promise<BoundaryCrosswalkVersionExtended>;

  /**
   * Add standard baseline to boundary
   * @summary Add standard baseline to boundary
   * @param {UUID} boundaryId 
   * @param {NewBoundaryStandardBaseline} newBoundaryStandardBaseline 
   * @param {*} [options] Override http request option.
   * @throws {@link @zerobias-org/types-core-js#ParameterRequiredError} if any required parameter is not provided
   * @example
   * ```typescript
   * const result = await api.addStandardBaseline('00000000-0000-0000-0000-000000000000', null);
   * ```
   * @openapi operation=addBoundaryStandardBaseline path=/app/boundaries/{boundaryId}/standardBaselines method=POST
   * @memberof BoundaryApi
   */
  addStandardBaseline(boundaryId: UUID, newBoundaryStandardBaseline: NewBoundaryStandardBaseline): Promise<BoundaryStandardBaselineExtended>;

  /**
   * Choose elements that are in scope for boundary standard baseline
   * @summary Choose elements that are in scope for boundary standard baseline
   * @param {UUID} boundaryId 
   * @param {UUID} boundaryStandardBaselineId 
   * @param {NewBoundaryStandardBaselineElements} newBoundaryStandardBaselineElements 
   * @param {*} [options] Override http request option.
   * @throws {@link @zerobias-org/types-core-js#ParameterRequiredError} if any required parameter is not provided
   * @example
   * ```typescript
   * const result = await api.addStandardBaselineElements('00000000-0000-0000-0000-000000000000', '00000000-0000-0000-0000-000000000000', null);
   * ```
   * @openapi operation=addBoundaryStandardBaselineElements path=/app/boundaries/{boundaryId}/standardBaselines/{boundaryStandardBaselineId}/elements method=POST
   * @memberof BoundaryApi
   */
  addStandardBaselineElements(boundaryId: UUID, boundaryStandardBaselineId: UUID, newBoundaryStandardBaselineElements: NewBoundaryStandardBaselineElements): Promise<Array<ElementExtended>>;

  /**
   * Removes a subscription from a boundary alert bot
   * @summary Removes a subscription from a boundary alert bot
   * @param {UUID} boundaryId 
   * @param {UUID} boundaryAlertBotId 
   * @param {UUID} subscriptionId 
   * @param {*} [options] Override http request option.
   * @throws {@link @zerobias-org/types-core-js#ParameterRequiredError} if any required parameter is not provided
   * @example
   * ```typescript
   * const result = await api.deleteSubscription('00000000-0000-0000-0000-000000000000', '00000000-0000-0000-0000-000000000000', '00000000-0000-0000-0000-000000000000');
   * ```
   * @openapi operation=boundaryAlertBotDeleteSubscription path=/app/boundaries/{boundaryId}/alertBots/{boundaryAlertBotId}/subscriptions/{subscriptionId} method=DELETE
   * @memberof BoundaryApi
   */
  deleteSubscription(boundaryId: UUID, boundaryAlertBotId: UUID, subscriptionId: UUID): Promise<void>;

  /**
   * Adds a subscription to a boundary alert bot
   * @summary Adds a subscription to a boundary alert bot
   * @param {UUID} boundaryId 
   * @param {UUID} boundaryAlertBotId 
   * @param {NewAlertSubscription} newAlertSubscription 
   * @param {*} [options] Override http request option.
   * @throws {@link @zerobias-org/types-core-js#ParameterRequiredError} if any required parameter is not provided
   * @example
   * ```typescript
   * const result = await api.addSubscription('00000000-0000-0000-0000-000000000000', '00000000-0000-0000-0000-000000000000', null);
   * ```
   * @openapi operation=boundaryAlertBotSubscribeToAlerts path=/app/boundaries/{boundaryId}/alertBots/{boundaryAlertBotId}/subscriptions method=POST
   * @memberof BoundaryApi
   */
  addSubscription(boundaryId: UUID, boundaryAlertBotId: UUID, newAlertSubscription: NewAlertSubscription): Promise<AlertSubscriptionExtended>;

  /**
   * Executes a query within the given boundary. (not implemented)
   * @summary Executes a query within the given boundary. (not implemented)
   * @param {UUID} boundaryId 
   * @param {UUID} queryId the queryId or queryVersionId to execute. If given a queryId the latest version of that query will be executed
   * @param {ExecuteGraphqlQuery} executeGraphqlQuery 
   * @param {*} [options] Override http request option.
   * @throws {@link @zerobias-org/types-core-js#ParameterRequiredError} if any required parameter is not provided
   * @example
   * ```typescript
   * const result = await api.boundaryExecuteQuery('00000000-0000-0000-0000-000000000000', '00000000-0000-0000-0000-000000000000', null);
   * ```
   * @openapi operation=boundaryExecuteQuery path=/app/boundaries/{boundaryId}/queries/{queryId} method=PUT
   * @memberof BoundaryApi
   */
  boundaryExecuteQuery(boundaryId: UUID, queryId: UUID, executeGraphqlQuery: ExecuteGraphqlQuery): Promise<ExecuteGraphqlQueryResult>;

  /**
   * Searches for filters, queries, and keywords within boundary for given keyword
   * @summary Searches for filters, queries, and keywords within boundary for given keyword
   * @param {UUID} boundaryId 
   * @param {BoundaryKeywordSearchBody} boundaryKeywordSearchBody Filters to apply to the search.
   * @param {*} [options] Override http request option.
   * @throws {@link @zerobias-org/types-core-js#ParameterRequiredError} if any required parameter is not provided
   * @example
   * ```typescript
   * const result = await api.boundaryKeywordSearch('00000000-0000-0000-0000-000000000000', null);
   * ```
   * @openapi operation=boundaryKeywordSearch path=/boundaries/{boundaryId}/keywordSearch method=POST
   * @memberof BoundaryApi
   */
  boundaryKeywordSearch(boundaryId: UUID, boundaryKeywordSearchBody: BoundaryKeywordSearchBody): Promise<BoundaryKeywordSearchResult>;

  /**
   * Searches for keywords within boundary for given class and keyword
   * @summary Searches for keywords within boundary for given class and keyword
   * @param {UUID} boundaryId 
   * @param {UUID} classId 
   * @param {BoundaryKeywordSearchBody} boundaryKeywordSearchBody Filters to apply to the search.
   * @param {*} [options] Override http request option.
   * @throws {@link @zerobias-org/types-core-js#ParameterRequiredError} if any required parameter is not provided
   * @example
   * ```typescript
   * const result = await api.boundaryKeywordSearchForClass('00000000-0000-0000-0000-000000000000', '00000000-0000-0000-0000-000000000000', null);
   * ```
   * @openapi operation=boundaryKeywordSearchForClass path=/boundaries/{boundaryId}/keywordSearch/{classId} method=POST
   * @memberof BoundaryApi
   */
  boundaryKeywordSearchForClass(boundaryId: UUID, classId: UUID, boundaryKeywordSearchBody: BoundaryKeywordSearchBody): Promise<BoundaryKeywordSearchForClassResult>;

  /**
   * Retrieves object counts for class given in filter
   * @summary Retrieves object counts for class given in filter
   * @param {UUID} boundaryId 
   * @param {BoundaryObjectCountFilter} boundaryObjectCountFilter 
   * @param {*} [options] Override http request option.
   * @throws {@link @zerobias-org/types-core-js#ParameterRequiredError} if any required parameter is not provided
   * @example
   * ```typescript
   * const result = await api.boundaryObjectCount('00000000-0000-0000-0000-000000000000', null);
   * ```
   * @openapi operation=boundaryObjectCount path=/boundaries/{boundaryId}/objectCount method=POST
   * @memberof BoundaryApi
   */
  boundaryObjectCount(boundaryId: UUID, boundaryObjectCountFilter: BoundaryObjectCountFilter): Promise<BoundaryObjectCountResult>;

  /**
   * Search through objects within a boundary
   * @summary Search through objects within a boundary
   * @param {UUID} boundaryId 
   * @param {BoundaryObjectSearchFilter} boundaryObjectSearchFilter Filters to apply to the search.
   * @param {number} [pageNumber] The requested page. This value is 1-indexed.
   * @param {number} [pageSize] The number of items in each page of data.
   * @param {*} [options] Override http request option.
   * @throws {@link @zerobias-org/types-core-js#ParameterRequiredError} if any required parameter is not provided
   * @example
   * ```typescript
   * const result = await api.boundaryObjectSearch('00000000-0000-0000-0000-000000000000', null, 1, 1);
   * ```
   * @openapi operation=boundaryObjectSearch path=/boundaries/{boundaryId}/objectSearch method=POST
   * @memberof BoundaryApi
   */
  boundaryObjectSearch(boundaryId: UUID, boundaryObjectSearchFilter: BoundaryObjectSearchFilter, pageNumber?: number, pageSize?: number): Promise<PagedResults<BoundarySearchResult>>;

  /**
   * Search through objects within a boundary and returns metadata about results that would be returned by objectSearch
   * @summary Search through objects within a boundary and returns metadata about results that would be returned by objectSearch
   * @param {UUID} boundaryId 
   * @param {BoundaryObjectSearchFilter} boundaryObjectSearchFilter Filters to apply to the search.
   * @param {*} [options] Override http request option.
   * @throws {@link @zerobias-org/types-core-js#ParameterRequiredError} if any required parameter is not provided
   * @example
   * ```typescript
   * const result = await api.boundaryObjectSearchMetadata('00000000-0000-0000-0000-000000000000', null);
   * ```
   * @openapi operation=boundaryObjectSearchMetadata path=/boundaries/{boundaryId}/objectSearchMetadata method=POST
   * @memberof BoundaryApi
   */
  boundaryObjectSearchMetadata(boundaryId: UUID, boundaryObjectSearchFilter: BoundaryObjectSearchFilter): Promise<BoundaryObjectSearchResultsMetadata>;

  /**
   * Search accross objects, resources and tags within a boundary
   * @summary Search accross objects, resources and tags within a boundary
   * @param {UUID} boundaryId 
   * @param {BoundarySearchFilter} boundarySearchFilter Filters to apply to the search.
   * @param {number} [pageNumber] The requested page. This value is 1-indexed.
   * @param {number} [pageSize] The number of items in each page of data.
   * @param {*} [options] Override http request option.
   * @throws {@link @zerobias-org/types-core-js#ParameterRequiredError} if any required parameter is not provided
   * @example
   * ```typescript
   * const result = await api.boundarySearch('00000000-0000-0000-0000-000000000000', null, 1, 1);
   * ```
   * @openapi operation=boundarySearch path=/boundaries/{boundaryId}/search method=POST
   * @memberof BoundaryApi
   */
  boundarySearch(boundaryId: UUID, boundarySearchFilter: BoundarySearchFilter, pageNumber?: number, pageSize?: number): Promise<PagedResults<BoundarySearchResult>>;

  /**
   * Create a new boundary
   * @summary Create a new boundary
   * @param {NewBoundary} newBoundary 
   * @param {*} [options] Override http request option.
   * @throws {@link @zerobias-org/types-core-js#ParameterRequiredError} if any required parameter is not provided
   * @example
   * ```typescript
   * const result = await api.createBoundary(null);
   * ```
   * @openapi operation=createBoundary path=/boundaries method=POST
   * @memberof BoundaryApi
   */
  createBoundary(newBoundary: NewBoundary): Promise<Boundary>;

  /**
   * Create a new boundary Event
   * @summary Create a new boundary Event
   * @param {UUID} boundaryId 
   * @param {NewBoundaryEvent} newBoundaryEvent 
   * @param {*} [options] Override http request option.
   * @throws {@link @zerobias-org/types-core-js#ParameterRequiredError} if any required parameter is not provided
   * @example
   * ```typescript
   * const result = await api.createBoundaryEvent('00000000-0000-0000-0000-000000000000', null);
   * ```
   * @openapi operation=createBoundaryEvent path=/boundaries/{boundaryId}/events method=POST
   * @memberof BoundaryApi
   */
  createBoundaryEvent(boundaryId: UUID, newBoundaryEvent: NewBoundaryEvent): Promise<BoundaryEvent>;

  /**
   * Create a new boundary Event
   * @summary Create a new boundary Event
   * @param {UUID} boundaryId 
   * @param {*} [options] Override http request option.
   * @throws {@link @zerobias-org/types-core-js#ParameterRequiredError} if any required parameter is not provided
   * @example
   * ```typescript
   * const result = await api.createBoundaryEvidence('00000000-0000-0000-0000-000000000000');
   * ```
   * @openapi operation=createBoundaryEvidence path=/boundaries/{boundaryId}/evidence method=POST
   * @memberof BoundaryApi
   */
  createBoundaryEvidence(boundaryId: UUID): Promise<CreateBoundaryEvidenceCounts>;

  /**
   * Create a new boundary party
   * @summary Create a new boundary party
   * @param {UUID} boundaryId 
   * @param {NewBoundaryParty} newBoundaryParty 
   * @param {*} [options] Override http request option.
   * @throws {@link @zerobias-org/types-core-js#ParameterRequiredError} if any required parameter is not provided
   * @example
   * ```typescript
   * const result = await api.createBoundaryParty('00000000-0000-0000-0000-000000000000', null);
   * ```
   * @openapi operation=createBoundaryParty path=/boundaries/{boundaryId}/parties method=POST
   * @memberof BoundaryApi
   */
  createBoundaryParty(boundaryId: UUID, newBoundaryParty: NewBoundaryParty): Promise<PartyExtended>;

  /**
   * Create new boundary party role
   * @summary Create new boundary party role
   * @param {UUID} boundaryId 
   * @param {NewBoundaryPartyRole} newBoundaryPartyRole 
   * @param {*} [options] Override http request option.
   * @throws {@link @zerobias-org/types-core-js#ParameterRequiredError} if any required parameter is not provided
   * @example
   * ```typescript
   * const result = await api.createBoundaryPartyRole('00000000-0000-0000-0000-000000000000', null);
   * ```
   * @openapi operation=createBoundaryPartyRole path=/app/boundaries/{boundaryId}/partyRoles method=POST
   * @memberof BoundaryApi
   */
  createBoundaryPartyRole(boundaryId: UUID, newBoundaryPartyRole: NewBoundaryPartyRole): Promise<BoundaryPartyRoleExtended>;

  /**
   * Create a new boundary product
   * @summary Create a new boundary product
   * @param {UUID} boundaryId 
   * @param {NewBoundaryProduct} newBoundaryProduct 
   * @param {*} [options] Override http request option.
   * @throws {@link @zerobias-org/types-core-js#ParameterRequiredError} if any required parameter is not provided
   * @example
   * ```typescript
   * const result = await api.createBoundaryProduct('00000000-0000-0000-0000-000000000000', null);
   * ```
   * @openapi operation=createBoundaryProduct path=/boundaries/{boundaryId}/products method=POST
   * @memberof BoundaryApi
   */
  createBoundaryProduct(boundaryId: UUID, newBoundaryProduct: NewBoundaryProduct): Promise<BoundaryProductProcessedResponse>;

  /**
   * Create a new boundary product target
   * @summary Create a new boundary product target
   * @param {UUID} boundaryId 
   * @param {UUID} boundaryProductId 
   * @param {NewBoundaryProductTarget} newBoundaryProductTarget 
   * @param {*} [options] Override http request option.
   * @throws {@link @zerobias-org/types-core-js#ParameterRequiredError} if any required parameter is not provided
   * @example
   * ```typescript
   * const result = await api.createBoundaryProductTarget('00000000-0000-0000-0000-000000000000', '00000000-0000-0000-0000-000000000000', null);
   * ```
   * @openapi operation=createBoundaryProductTarget path=/boundaries/{boundaryId}/products/{boundaryProductId}/targets method=POST
   * @memberof BoundaryApi
   */
  createBoundaryProductTarget(boundaryId: UUID, boundaryProductId: UUID, newBoundaryProductTarget: NewBoundaryProductTarget): Promise<BoundaryProductTargetProcessedResponse>;

  /**
   * Create a new boundary team
   * @summary Create a new boundary team
   * @param {UUID} boundaryId 
   * @param {NewBoundaryTeam} newBoundaryTeam 
   * @param {*} [options] Override http request option.
   * @throws {@link @zerobias-org/types-core-js#ParameterRequiredError} if any required parameter is not provided
   * @example
   * ```typescript
   * const result = await api.createBoundaryTeam('00000000-0000-0000-0000-000000000000', null);
   * ```
   * @openapi operation=createBoundaryTeam path=/boundaries/{boundaryId}/teams method=POST
   * @memberof BoundaryApi
   */
  createBoundaryTeam(boundaryId: UUID, newBoundaryTeam: NewBoundaryTeam): Promise<BoundaryTeam>;

  /**
   * Create a new suggested product
   * @summary Create a new suggested product
   * @param {UUID} boundaryId 
   * @param {NewSuggestedProduct} newSuggestedProduct 
   * @param {*} [options] Override http request option.
   * @throws {@link @zerobias-org/types-core-js#ParameterRequiredError} if any required parameter is not provided
   * @example
   * ```typescript
   * const result = await api.createSuggestedProduct('00000000-0000-0000-0000-000000000000', null);
   * ```
   * @openapi operation=createSuggestedProduct path=/boundaries/{boundaryId}/suggestedProducts method=POST
   * @memberof BoundaryApi
   */
  createSuggestedProduct(boundaryId: UUID, newSuggestedProduct: NewSuggestedProduct): Promise<SuggestedProduct>;

  /**
   * Deletes a boundary
   * @summary Deletes a boundary
   * @param {UUID} boundaryId 
   * @param {*} [options] Override http request option.
   * @throws {@link @zerobias-org/types-core-js#ParameterRequiredError} if any required parameter is not provided
   * @example
   * ```typescript
   * const result = await api.deleteBoundary('00000000-0000-0000-0000-000000000000');
   * ```
   * @openapi operation=deleteBoundary path=/boundaries/{boundaryId} method=DELETE
   * @memberof BoundaryApi
   */
  deleteBoundary(boundaryId: UUID): Promise<void>;

  /**
   * Deletes a boundary query alert bot
   * @summary Deletes a boundary query alert bot
   * @param {UUID} boundaryId 
   * @param {UUID} boundaryAlertBotId 
   * @param {*} [options] Override http request option.
   * @throws {@link @zerobias-org/types-core-js#ParameterRequiredError} if any required parameter is not provided
   * @example
   * ```typescript
   * const result = await api.deleteAlertBot('00000000-0000-0000-0000-000000000000', '00000000-0000-0000-0000-000000000000');
   * ```
   * @openapi operation=deleteBoundaryAlertBot path=/app/boundaries/{boundaryId}/alertBots/{boundaryAlertBotId} method=DELETE
   * @memberof BoundaryApi
   */
  deleteAlertBot(boundaryId: UUID, boundaryAlertBotId: UUID): Promise<void>;

  /**
   * Delete boundary party role
   * @summary Delete boundary party role
   * @param {UUID} boundaryId 
   * @param {UUID} roleId 
   * @param {UUID} partyId 
   * @param {*} [options] Override http request option.
   * @throws {@link @zerobias-org/types-core-js#ParameterRequiredError} if any required parameter is not provided
   * @example
   * ```typescript
   * const result = await api.deleteBoundaryPartyRole('00000000-0000-0000-0000-000000000000', '00000000-0000-0000-0000-000000000000', '00000000-0000-0000-0000-000000000000');
   * ```
   * @openapi operation=deleteBoundaryPartyRole path=/app/boundaries/{boundaryId}/parties/{partyId}/roles/{roleId} method=DELETE
   * @memberof BoundaryApi
   */
  deleteBoundaryPartyRole(boundaryId: UUID, roleId: UUID, partyId: UUID): Promise<void>;

  /**
   * Delete boundary party roles by boundary id
   * @summary Delete boundary party roles by boundary id
   * @param {UUID} boundaryId 
   * @param {*} [options] Override http request option.
   * @throws {@link @zerobias-org/types-core-js#ParameterRequiredError} if any required parameter is not provided
   * @example
   * ```typescript
   * const result = await api.deleteBoundaryPartyRoles('00000000-0000-0000-0000-000000000000');
   * ```
   * @openapi operation=deleteBoundaryPartyRoles path=/app/boundaries/{boundaryId}/partyRoles method=DELETE
   * @memberof BoundaryApi
   */
  deleteBoundaryPartyRoles(boundaryId: UUID): Promise<void>;

  /**
   * Deletes target for a boundary product
   * @summary Deletes target for a boundary product
   * @param {UUID} boundaryId 
   * @param {UUID} boundaryProductId 
   * @param {DeleteBoundaryProductTarget} deleteBoundaryProductTarget 
   * @param {*} [options] Override http request option.
   * @throws {@link @zerobias-org/types-core-js#ParameterRequiredError} if any required parameter is not provided
   * @example
   * ```typescript
   * const result = await api.deleteBoundaryProductTargets('00000000-0000-0000-0000-000000000000', '00000000-0000-0000-0000-000000000000', null);
   * ```
   * @openapi operation=deleteBoundaryProductTargets path=/boundaries/{boundaryId}/products/{boundaryProductId}/targets method=DELETE
   * @memberof BoundaryApi
   */
  deleteBoundaryProductTargets(boundaryId: UUID, boundaryProductId: UUID, deleteBoundaryProductTarget: DeleteBoundaryProductTarget): Promise<BoundaryProductTargetProcessedResponse>;

  /**
   * Deletes products for a boundary
   * @summary Deletes products for a boundary
   * @param {UUID} boundaryId 
   * @param {DeleteBoundaryProduct} deleteBoundaryProduct 
   * @param {*} [options] Override http request option.
   * @throws {@link @zerobias-org/types-core-js#ParameterRequiredError} if any required parameter is not provided
   * @example
   * ```typescript
   * const result = await api.deleteBoundaryProducts('00000000-0000-0000-0000-000000000000', null);
   * ```
   * @openapi operation=deleteBoundaryProducts path=/boundaries/{boundaryId}/products method=DELETE
   * @memberof BoundaryApi
   */
  deleteBoundaryProducts(boundaryId: UUID, deleteBoundaryProduct: DeleteBoundaryProduct): Promise<BoundaryProductProcessedResponse>;

  /**
   * Deletes a boundary team
   * @summary Deletes a boundary team
   * @param {UUID} boundaryId 
   * @param {UUID} teamId 
   * @param {*} [options] Override http request option.
   * @throws {@link @zerobias-org/types-core-js#ParameterRequiredError} if any required parameter is not provided
   * @example
   * ```typescript
   * const result = await api.deleteBoundaryTeam('00000000-0000-0000-0000-000000000000', '00000000-0000-0000-0000-000000000000');
   * ```
   * @openapi operation=deleteBoundaryTeam path=/boundaries/{boundaryId}/teams/{teamId} method=DELETE
   * @memberof BoundaryApi
   */
  deleteBoundaryTeam(boundaryId: UUID, teamId: UUID): Promise<void>;

  /**
   * Deletes events for a boundary
   * @summary Deletes events for a boundary
   * @param {UUID} boundaryId 
   * @param {*} [options] Override http request option.
   * @throws {@link @zerobias-org/types-core-js#ParameterRequiredError} if any required parameter is not provided
   * @example
   * ```typescript
   * const result = await api.deleteEventsForBoundary('00000000-0000-0000-0000-000000000000');
   * ```
   * @openapi operation=deleteEventsForBoundary path=/boundaries/{boundaryId}/events method=DELETE
   * @memberof BoundaryApi
   */
  deleteEventsForBoundary(boundaryId: UUID): Promise<void>;

  /**
   * Disables a boundary team scf control evidence definition implementation
   * @summary Disables a boundary team scf control evidence definition implementation
   * @param {UUID} boundaryId 
   * @param {UUID} teamId 
   * @param {UUID} scfControlId 
   * @param {UUID} evidenceDefinitionId 
   * @param {*} [options] Override http request option.
   * @throws {@link @zerobias-org/types-core-js#ParameterRequiredError} if any required parameter is not provided
   * @example
   * ```typescript
   * const result = await api.disableBoundaryTeamScfControlEvidenceDefinition('00000000-0000-0000-0000-000000000000', '00000000-0000-0000-0000-000000000000', '00000000-0000-0000-0000-000000000000', '00000000-0000-0000-0000-000000000000');
   * ```
   * @openapi operation=disableBoundaryTeamScfControlEvidenceDefinition path=/boundaries/{boundaryId}/teams/{teamId}/scfControlTree/{scfControlId}/evidenceDefinitions/{evidenceDefinitionId} method=DELETE
   * @memberof BoundaryApi
   */
  disableBoundaryTeamScfControlEvidenceDefinition(boundaryId: UUID, teamId: UUID, scfControlId: UUID, evidenceDefinitionId: UUID): Promise<void>;

  /**
   * Enables a boundary team scf control evidence definition implementation
   * @summary Enables a boundary team scf control evidence definition implementation
   * @param {UUID} boundaryId 
   * @param {UUID} teamId 
   * @param {UUID} scfControlId 
   * @param {EnableBoundaryTeamScfControlEvidenceDefinition} enableBoundaryTeamScfControlEvidenceDefinition 
   * @param {*} [options] Override http request option.
   * @throws {@link @zerobias-org/types-core-js#ParameterRequiredError} if any required parameter is not provided
   * @example
   * ```typescript
   * const result = await api.enableBoundaryTeamScfControlEvidenceDefinition('00000000-0000-0000-0000-000000000000', '00000000-0000-0000-0000-000000000000', '00000000-0000-0000-0000-000000000000', null);
   * ```
   * @openapi operation=enableBoundaryTeamScfControlEvidenceDefinition path=/boundaries/{boundaryId}/teams/{teamId}/scfControlTree/{scfControlId}/evidenceDefinitions method=POST
   * @memberof BoundaryApi
   */
  enableBoundaryTeamScfControlEvidenceDefinition(boundaryId: UUID, teamId: UUID, scfControlId: UUID, enableBoundaryTeamScfControlEvidenceDefinition: EnableBoundaryTeamScfControlEvidenceDefinition): Promise<BoundaryTeamScfControlEvidenceDefinitionImplementation>;

  /**
   * Retrieves a boundary product
   * @summary Retrieves a boundary product
   * @param {UUID} boundaryId 
   * @param {UUID} boundaryProductId 
   * @param {*} [options] Override http request option.
   * @throws {@link @zerobias-org/types-core-js#ParameterRequiredError} if any required parameter is not provided
   * @example
   * ```typescript
   * const result = await api.getAnyBoundaryProduct('00000000-0000-0000-0000-000000000000', '00000000-0000-0000-0000-000000000000');
   * ```
   * @openapi operation=getAnyBoundaryProduct path=/boundaries/{boundaryId}/allProducts/{boundaryProductId} method=GET
   * @memberof BoundaryApi
   */
  getAnyBoundaryProduct(boundaryId: UUID, boundaryProductId: UUID): Promise<BoundaryProductAny>;

  /**
   * Retrieves a boundary
   * @summary Retrieves a boundary
   * @param {UUID} boundaryId 
   * @param {*} [options] Override http request option.
   * @throws {@link @zerobias-org/types-core-js#ParameterRequiredError} if any required parameter is not provided
   * @example
   * ```typescript
   * const result = await api.getBoundary('00000000-0000-0000-0000-000000000000');
   * ```
   * @openapi operation=getBoundary path=/boundaries/{boundaryId} method=GET
   * @memberof BoundaryApi
   */
  getBoundary(boundaryId: UUID): Promise<BoundaryExtended>;

  /**
   * 
   * @summary Retrieves extended information about a boundary alert
   * @param {UUID} boundaryId The ID of the boundary
   * @param {UUID} id The ID of the alert to fetch
   * @param {*} [options] Override http request option.
   * @throws {@link @zerobias-org/types-core-js#ParameterRequiredError} if any required parameter is not provided
   * @example
   * ```typescript
   * const result = await api.getBoundaryAlert('00000000-0000-0000-0000-000000000000', '00000000-0000-0000-0000-000000000000');
   * ```
   * @openapi operation=getBoundaryAlert path=/app/boundaries/{boundaryId}/alerts/{id} method=GET
   * @memberof BoundaryApi
   */
  getBoundaryAlert(boundaryId: UUID, id: UUID): Promise<BoundaryAlertExtended>;

  /**
   * Get boundary component
   * @summary Get boundary component
   * @param {UUID} boundaryId 
   * @param {UUID} componentId 
   * @param {*} [options] Override http request option.
   * @throws {@link @zerobias-org/types-core-js#ParameterRequiredError} if any required parameter is not provided
   * @example
   * ```typescript
   * const result = await api.getBoundaryComponent('00000000-0000-0000-0000-000000000000', '00000000-0000-0000-0000-000000000000');
   * ```
   * @openapi operation=getBoundaryComponent path=/app/boundaries/{boundaryId}/components/{componentId} method=GET
   * @memberof BoundaryApi
   */
  getBoundaryComponent(boundaryId: UUID, componentId: UUID): Promise<BoundaryComponentExtended>;

  /**
   * Retrieves a boundary product
   * @summary Retrieves a boundary product
   * @param {UUID} boundaryId 
   * @param {UUID} connectionId 
   * @param {*} [options] Override http request option.
   * @throws {@link @zerobias-org/types-core-js#ParameterRequiredError} if any required parameter is not provided
   * @example
   * ```typescript
   * const result = await api.getBoundaryConnectionOverview('00000000-0000-0000-0000-000000000000', '00000000-0000-0000-0000-000000000000');
   * ```
   * @openapi operation=getBoundaryConnectionOverview path=/boundaries/{boundaryId}/connections/{connectionId} method=GET
   * @memberof BoundaryApi
   */
  getBoundaryConnectionOverview(boundaryId: UUID, connectionId: UUID): Promise<BoundaryConnectionOverview>;

  /**
   * Retrieves domains summary info for a boundary
   * @summary Retrieves domains summary info for a boundary
   * @param {UUID} boundaryId 
   * @param {UUID} [sourceId] 
   * @param {*} [options] Override http request option.
   * @throws {@link @zerobias-org/types-core-js#ParameterRequiredError} if any required parameter is not provided
   * @example
   * ```typescript
   * const result = await api.getBoundaryDomainSummary('00000000-0000-0000-0000-000000000000', '00000000-0000-0000-0000-000000000000');
   * ```
   * @openapi operation=getBoundaryDomainSummary path=/boundaries/{boundaryId}/domains method=GET
   * @memberof BoundaryApi
   */
  getBoundaryDomainSummary(boundaryId: UUID, sourceId?: UUID): Promise<BoundaryDomainSummary>;

  /**
   * Retrieves a boundary evidence record
   * @summary Retrieves a boundary evidence record
   * @param {UUID} boundaryId 
   * @param {UUID} evidenceId 
   * @param {*} [options] Override http request option.
   * @throws {@link @zerobias-org/types-core-js#ParameterRequiredError} if any required parameter is not provided
   * @example
   * ```typescript
   * const result = await api.getBoundaryEvidence('00000000-0000-0000-0000-000000000000', '00000000-0000-0000-0000-000000000000');
   * ```
   * @openapi operation=getBoundaryEvidence path=/boundaries/{boundaryId}/evidence/{evidenceId} method=GET
   * @memberof BoundaryApi
   */
  getBoundaryEvidence(boundaryId: UUID, evidenceId: UUID): Promise<BoundaryEvidence & ExtendedBoundaryEvidence>;

  /**
   * Retrieves metrics of the data for a specific boundary
   * @summary Retrieves metrics of the data for a specific boundary
   * @param {UUID} boundaryId 
   * @param {*} [options] Override http request option.
   * @throws {@link @zerobias-org/types-core-js#ParameterRequiredError} if any required parameter is not provided
   * @example
   * ```typescript
   * const result = await api.getBoundaryMetrics('00000000-0000-0000-0000-000000000000');
   * ```
   * @openapi operation=getBoundaryMetrics path=/boundaries/{boundaryId}/metrics method=GET
   * @memberof BoundaryApi
   */
  getBoundaryMetrics(boundaryId: UUID): Promise<BoundaryMetric>;

  /**
   * Retrieves a party for a boundary
   * @summary Retrieves a party for a boundary
   * @param {UUID} boundaryId 
   * @param {UUID} partyId 
   * @param {*} [options] Override http request option.
   * @throws {@link @zerobias-org/types-core-js#ParameterRequiredError} if any required parameter is not provided
   * @example
   * ```typescript
   * const result = await api.getBoundaryParty('00000000-0000-0000-0000-000000000000', '00000000-0000-0000-0000-000000000000');
   * ```
   * @openapi operation=getBoundaryParty path=/boundaries/{boundaryId}/parties/{partyId} method=GET
   * @memberof BoundaryApi
   */
  getBoundaryParty(boundaryId: UUID, partyId: UUID): Promise<PartyExtended>;

  /**
   * Get boundary party role
   * @summary Get boundary party role
   * @param {UUID} boundaryId 
   * @param {UUID} roleId 
   * @param {UUID} partyId 
   * @param {*} [options] Override http request option.
   * @throws {@link @zerobias-org/types-core-js#ParameterRequiredError} if any required parameter is not provided
   * @example
   * ```typescript
   * const result = await api.getBoundaryPartyRole('00000000-0000-0000-0000-000000000000', '00000000-0000-0000-0000-000000000000', '00000000-0000-0000-0000-000000000000');
   * ```
   * @openapi operation=getBoundaryPartyRole path=/app/boundaries/{boundaryId}/parties/{partyId}/roles/{roleId} method=GET
   * @memberof BoundaryApi
   */
  getBoundaryPartyRole(boundaryId: UUID, roleId: UUID, partyId: UUID): Promise<BoundaryPartyRoleExtended>;

  /**
   * Retrieves a boundary product
   * @summary Retrieves a boundary product
   * @param {UUID} boundaryId 
   * @param {UUID} boundaryProductId 
   * @param {*} [options] Override http request option.
   * @throws {@link @zerobias-org/types-core-js#ParameterRequiredError} if any required parameter is not provided
   * @example
   * ```typescript
   * const result = await api.getBoundaryProduct('00000000-0000-0000-0000-000000000000', '00000000-0000-0000-0000-000000000000');
   * ```
   * @openapi operation=getBoundaryProduct path=/boundaries/{boundaryId}/products/{boundaryProductId} method=GET
   * @memberof BoundaryApi
   */
  getBoundaryProduct(boundaryId: UUID, boundaryProductId: UUID): Promise<BoundaryProduct & ExtendedBoundaryProduct>;

  /**
   * Retrieves a boundary product
   * @summary Retrieves a boundary product
   * @param {UUID} boundaryId 
   * @param {UUID} boundaryProductId 
   * @param {UUID} connectionId 
   * @param {*} [options] Override http request option.
   * @throws {@link @zerobias-org/types-core-js#ParameterRequiredError} if any required parameter is not provided
   * @example
   * ```typescript
   * const result = await api.getBoundaryProductConnectionOverview('00000000-0000-0000-0000-000000000000', '00000000-0000-0000-0000-000000000000', '00000000-0000-0000-0000-000000000000');
   * ```
   * @openapi operation=getBoundaryProductConnectionOverview path=/boundaries/{boundaryId}/products/{boundaryProductId}/connections/{connectionId} method=GET
   * @memberof BoundaryApi
   */
  getBoundaryProductConnectionOverview(boundaryId: UUID, boundaryProductId: UUID, connectionId: UUID): Promise<BoundaryConnectionOverview>;

  /**
   * Retrieves a boundary product overview
   * @summary Retrieves a boundary product overview
   * @param {UUID} boundaryId 
   * @param {UUID} boundaryProductId 
   * @param {*} [options] Override http request option.
   * @throws {@link @zerobias-org/types-core-js#ParameterRequiredError} if any required parameter is not provided
   * @example
   * ```typescript
   * const result = await api.getBoundaryProductOverview('00000000-0000-0000-0000-000000000000', '00000000-0000-0000-0000-000000000000');
   * ```
   * @openapi operation=getBoundaryProductOverview path=/boundaries/{boundaryId}/products/{boundaryProductId}/overviews method=GET
   * @memberof BoundaryApi
   */
  getBoundaryProductOverview(boundaryId: UUID, boundaryProductId: UUID): Promise<BoundaryProductOverview>;

  /**
   * Retrieves a scf control for a boundary
   * @summary Retrieves a scf control for a boundary
   * @param {UUID} boundaryId 
   * @param {UUID} boundaryScfControlId 
   * @param {*} [options] Override http request option.
   * @throws {@link @zerobias-org/types-core-js#ParameterRequiredError} if any required parameter is not provided
   * @example
   * ```typescript
   * const result = await api.getBoundaryScfControl('00000000-0000-0000-0000-000000000000', '00000000-0000-0000-0000-000000000000');
   * ```
   * @openapi operation=getBoundaryScfControl path=/boundaries/{boundaryId}/scfControls/{boundaryScfControlId} method=GET
   * @memberof BoundaryApi
   */
  getBoundaryScfControl(boundaryId: UUID, boundaryScfControlId: UUID): Promise<ExtendedBoundaryScfControl>;

  /**
   * Get standard baseline that has been added to a boundary
   * @summary Get standard baseline that has been added to a boundary
   * @param {UUID} boundaryId 
   * @param {UUID} boundaryStandardBaselineId 
   * @param {*} [options] Override http request option.
   * @throws {@link @zerobias-org/types-core-js#ParameterRequiredError} if any required parameter is not provided
   * @example
   * ```typescript
   * const result = await api.getStandardBaseline('00000000-0000-0000-0000-000000000000', '00000000-0000-0000-0000-000000000000');
   * ```
   * @openapi operation=getBoundaryStandardBaseline path=/app/boundaries/{boundaryId}/standardBaselines/{boundaryStandardBaselineId} method=GET
   * @memberof BoundaryApi
   */
  getStandardBaseline(boundaryId: UUID, boundaryStandardBaselineId: UUID): Promise<BoundaryStandardBaselineExtended>;

  /**
   * Get element by standard and baseline and element id
   * @summary Get element by standard and baseline and element id
   * @param {UUID} boundaryId 
   * @param {UUID} boundaryStandardBaselineId 
   * @param {*} [options] Override http request option.
   * @throws {@link @zerobias-org/types-core-js#ParameterRequiredError} if any required parameter is not provided
   * @example
   * ```typescript
   * const result = await api.getStandardBaselineFilterTree('00000000-0000-0000-0000-000000000000', '00000000-0000-0000-0000-000000000000');
   * ```
   * @openapi operation=getBoundaryStandardBaselineFilterTree path=/app/boundaries/{boundaryId}/standardBaselines/{boundaryStandardBaselineId}/filterTree method=GET
   * @memberof BoundaryApi
   */
  getStandardBaselineFilterTree(boundaryId: UUID, boundaryStandardBaselineId: UUID): Promise<{ [key: string]: StandardFilterTreeNode; }>;

  /**
   * Retrieves a boundary suggested product overview
   * @summary Retrieves a boundary suggested product overview
   * @param {UUID} boundaryId 
   * @param {UUID} boundarySuggestedProductId 
   * @param {*} [options] Override http request option.
   * @throws {@link @zerobias-org/types-core-js#ParameterRequiredError} if any required parameter is not provided
   * @example
   * ```typescript
   * const result = await api.getBoundarySuggestedProductOverview('00000000-0000-0000-0000-000000000000', '00000000-0000-0000-0000-000000000000');
   * ```
   * @openapi operation=getBoundarySuggestedProductOverview path=/boundaries/{boundaryId}/suggestedProducts/{boundarySuggestedProductId}/overviews method=GET
   * @memberof BoundaryApi
   */
  getBoundarySuggestedProductOverview(boundaryId: UUID, boundarySuggestedProductId: UUID): Promise<BoundarySuggestedProductOverview>;

  /**
   * Retrieves task metrics for a specific boundary
   * @summary Retrieves task metrics for a specific boundary
   * @param {UUID} boundaryId 
   * @param {number} [pageNumber] The requested page. This value is 1-indexed.
   * @param {number} [pageSize] The number of items in each page of data.
   * @param {*} [options] Override http request option.
   * @throws {@link @zerobias-org/types-core-js#ParameterRequiredError} if any required parameter is not provided
   * @example
   * ```typescript
   * const result = await api.getBoundaryTaskMetrics('00000000-0000-0000-0000-000000000000', 1, 1);
   * ```
   * @openapi operation=getBoundaryTaskMetrics path=/boundaries/{boundaryId}/taskMetrics method=GET
   * @memberof BoundaryApi
   */
  getBoundaryTaskMetrics(boundaryId: UUID, pageNumber?: number, pageSize?: number): Promise<BoundaryTaskMetrics>;

  /**
   * Retrieves a team for a boundary
   * @summary Retrieves a team for a boundary
   * @param {UUID} boundaryId 
   * @param {UUID} teamId 
   * @param {*} [options] Override http request option.
   * @throws {@link @zerobias-org/types-core-js#ParameterRequiredError} if any required parameter is not provided
   * @example
   * ```typescript
   * const result = await api.getBoundaryTeam('00000000-0000-0000-0000-000000000000', '00000000-0000-0000-0000-000000000000');
   * ```
   * @openapi operation=getBoundaryTeam path=/boundaries/{boundaryId}/teams/{teamId} method=GET
   * @memberof BoundaryApi
   */
  getBoundaryTeam(boundaryId: UUID, teamId: UUID): Promise<BoundaryTeam>;

  /**
   * Retrieves domains summary info for a boundary team
   * @summary Retrieves domains summary info for a boundary team
   * @param {UUID} boundaryId 
   * @param {UUID} teamId 
   * @param {UUID} [sourceId] 
   * @param {*} [options] Override http request option.
   * @throws {@link @zerobias-org/types-core-js#ParameterRequiredError} if any required parameter is not provided
   * @example
   * ```typescript
   * const result = await api.getBoundaryTeamDomainSummary('00000000-0000-0000-0000-000000000000', '00000000-0000-0000-0000-000000000000', '00000000-0000-0000-0000-000000000000');
   * ```
   * @openapi operation=getBoundaryTeamDomainSummary path=/boundaries/{boundaryId}/teams/{teamId}/domains method=GET
   * @memberof BoundaryApi
   */
  getBoundaryTeamDomainSummary(boundaryId: UUID, teamId: UUID, sourceId?: UUID): Promise<BoundaryTeamDomainSummary>;

  /**
   * Retrieves a teams metrics for a boundary
   * @summary Retrieves a teams metrics for a boundary
   * @param {UUID} boundaryId 
   * @param {UUID} teamId 
   * @param {*} [options] Override http request option.
   * @throws {@link @zerobias-org/types-core-js#ParameterRequiredError} if any required parameter is not provided
   * @example
   * ```typescript
   * const result = await api.getBoundaryTeamMetric('00000000-0000-0000-0000-000000000000', '00000000-0000-0000-0000-000000000000');
   * ```
   * @openapi operation=getBoundaryTeamMetric path=/boundaries/{boundaryId}/teamMetrics/{teamId} method=GET
   * @memberof BoundaryApi
   */
  getBoundaryTeamMetric(boundaryId: UUID, teamId: UUID): Promise<BoundaryTeamMetrics>;

  /**
   * Retrieves scf control data for a boundary team
   * @summary Retrieves scf control data for a boundary team
   * @param {UUID} boundaryId 
   * @param {UUID} teamId 
   * @param {UUID} scfControlId 
   * @param {*} [options] Override http request option.
   * @throws {@link @zerobias-org/types-core-js#ParameterRequiredError} if any required parameter is not provided
   * @example
   * ```typescript
   * const result = await api.getBoundaryTeamScfControl('00000000-0000-0000-0000-000000000000', '00000000-0000-0000-0000-000000000000', '00000000-0000-0000-0000-000000000000');
   * ```
   * @openapi operation=getBoundaryTeamScfControl path=/boundaries/{boundaryId}/teams/{teamId}/scfControls/{scfControlId} method=GET
   * @memberof BoundaryApi
   */
  getBoundaryTeamScfControl(boundaryId: UUID, teamId: UUID, scfControlId: UUID): Promise<BoundaryTeamScfControl>;

  /**
   * Retrieves a scf control defailts within a boundary team
   * @summary Retrieves a scf control defailts within a boundary team
   * @param {UUID} boundaryId 
   * @param {UUID} teamId 
   * @param {UUID} scfControlId 
   * @param {*} [options] Override http request option.
   * @throws {@link @zerobias-org/types-core-js#ParameterRequiredError} if any required parameter is not provided
   * @example
   * ```typescript
   * const result = await api.getBoundaryTeamScfControlDetails('00000000-0000-0000-0000-000000000000', '00000000-0000-0000-0000-000000000000', '00000000-0000-0000-0000-000000000000');
   * ```
   * @openapi operation=getBoundaryTeamScfControlDetails path=/boundaries/{boundaryId}/teams/{teamId}/scfControlTree/{scfControlId} method=GET
   * @memberof BoundaryApi
   */
  getBoundaryTeamScfControlDetails(boundaryId: UUID, teamId: UUID, scfControlId: UUID): Promise<BoundaryTeamScfControlOverview>;

  /**
   * Retrieves a list of scf controls for a boundary in a tree form
   * @summary Retrieves a list of scf controls for a boundary in a tree form
   * @param {UUID} boundaryId 
   * @param {UUID} teamId 
   * @param {UUID} [frameworkVersionId] 
   * @param {*} [options] Override http request option.
   * @throws {@link @zerobias-org/types-core-js#ParameterRequiredError} if any required parameter is not provided
   * @example
   * ```typescript
   * const result = await api.getBoundaryTeamScfControlOverview('00000000-0000-0000-0000-000000000000', '00000000-0000-0000-0000-000000000000', '00000000-0000-0000-0000-000000000000');
   * ```
   * @openapi operation=getBoundaryTeamScfControlOverview path=/boundaries/{boundaryId}/teams/{teamId}/scfControlOverview method=GET
   * @memberof BoundaryApi
   */
  getBoundaryTeamScfControlOverview(boundaryId: UUID, teamId: UUID, frameworkVersionId?: UUID): Promise<BoundaryFrameworkControlsOverview>;

  /**
   * Retrieves a list of scf controls for a boundary in a tree form
   * @summary Retrieves a list of scf controls for a boundary in a tree form
   * @param {UUID} boundaryId 
   * @param {UUID} teamId 
   * @param {UUID} [frameworkVersionId] 
   * @param {*} [options] Override http request option.
   * @throws {@link @zerobias-org/types-core-js#ParameterRequiredError} if any required parameter is not provided
   * @example
   * ```typescript
   * const result = await api.getBoundaryTeamScfControlTree('00000000-0000-0000-0000-000000000000', '00000000-0000-0000-0000-000000000000', '00000000-0000-0000-0000-000000000000');
   * ```
   * @openapi operation=getBoundaryTeamScfControlTree path=/boundaries/{boundaryId}/teams/{teamId}/scfControlTree method=GET
   * @memberof BoundaryApi
   */
  getBoundaryTeamScfControlTree(boundaryId: UUID, teamId: UUID, frameworkVersionId?: UUID): Promise<{ [key: string]: BoundaryFrameworkControlTreeNode; }>;

  /**
   * List test within a boundary by id
   * @summary List test within a boundary by id
   * @param {UUID} boundaryId 
   * @param {UUID} testId 
   * @param {*} [options] Override http request option.
   * @throws {@link @zerobias-org/types-core-js#ParameterRequiredError} if any required parameter is not provided
   * @example
   * ```typescript
   * const result = await api.getTest('00000000-0000-0000-0000-000000000000', '00000000-0000-0000-0000-000000000000');
   * ```
   * @openapi operation=getBoundaryTest path=/app/boundaries/{boundaryId}/tests/{testId} method=GET
   * @memberof BoundaryApi
   */
  getTest(boundaryId: UUID, testId: UUID): Promise<TestExtended>;

  /**
   * Retrieves a list of all products for a boundary
   * @summary Retrieves a list of all products for a boundary
   * @param {UUID} boundaryId 
   * @param {number} [pageNumber] The requested page. This value is 1-indexed.
   * @param {number} [pageSize] The number of items in each page of data.
   * @param {string} [keywords] Search like filter
   * @param {BoundaryProductForListStatus} [status] Search like filter
   * @param {SortObject} [sort] Sort object
   * @param {*} [options] Override http request option.
   * @throws {@link @zerobias-org/types-core-js#ParameterRequiredError} if any required parameter is not provided
   * @example
   * ```typescript
   * const result = await api.listAllBoundaryProducts('00000000-0000-0000-0000-000000000000', 1, 1, 'keywords', null, null);
   * ```
   * @openapi operation=listAllBoundaryProducts path=/boundaries/{boundaryId}/allProducts method=GET
   * @memberof BoundaryApi
   */
  listAllBoundaryProducts(boundaryId: UUID, pageNumber?: number, pageSize?: number, keywords?: string, status?: BoundaryProductForListStatusDef, sort?: SortObject): Promise<PagedResults<BoundaryProductForList>>;

  /**
   * Retrieves a list of all boundaries
   * @summary Retrieves a list of all boundaries
   * @param {number} [pageNumber] The requested page. This value is 1-indexed.
   * @param {number} [pageSize] The number of items in each page of data.
   * @param {string} [name] Filter by name
   * @param {BoundaryStatusEnum} [status] Filter by status
   * @param {BoundaryTypeEnum} [type] Filter by type
   * @param {SortObject} [sort] Sort object
   * @param {*} [options] Override http request option.
   * @throws {@link @zerobias-org/types-core-js#ParameterRequiredError} if any required parameter is not provided
   * @example
   * ```typescript
   * const result = await api.listBoundaries(1, 1, 'name', null, null, null);
   * ```
   * @openapi operation=listBoundaries path=/boundaries method=GET
   * @memberof BoundaryApi
   */
  listBoundaries(pageNumber?: number, pageSize?: number, name?: string, status?: BoundaryStatusEnumDef, type?: BoundaryTypeEnumDef, sort?: SortObject): Promise<PagedResults<BoundaryExtended>>;

  /**
   * List alerts raised by this bot
   * @summary List alerts raised by this bot
   * @param {UUID} boundaryId 
   * @param {UUID} boundaryAlertBotId 
   * @param {number} [pageNumber] The requested page. This value is 1-indexed.
   * @param {number} [pageSize] The number of items in each page of data.
   * @param {SortObject} [sort] Sort object
   * @param {*} [options] Override http request option.
   * @throws {@link @zerobias-org/types-core-js#ParameterRequiredError} if any required parameter is not provided
   * @example
   * ```typescript
   * const result = await api.listAlertBotAlerts('00000000-0000-0000-0000-000000000000', '00000000-0000-0000-0000-000000000000', 1, 1, null);
   * ```
   * @openapi operation=listBoundaryAlertBotAlerts path=/app/boundaries/{boundaryId}/alertBots/{boundaryAlertBotId}/alerts method=GET
   * @memberof BoundaryApi
   */
  listAlertBotAlerts(boundaryId: UUID, boundaryAlertBotId: UUID, pageNumber?: number, pageSize?: number, sort?: SortObject): Promise<PagedResults<BoundaryAlertView>>;

  /**
   * 
   * @summary Retrieves subjects that may be associated with a Boundary Alert
   * @param {UUID} boundaryId The ID of the boundary
   * @param {UUID} id The ID of the alert
   * @param {number} [pageNumber] The requested page. This value is 1-indexed.
   * @param {number} [pageSize] The number of items in each page of data.
   * @param {SortObject} [sort] Sort object
   * @param {*} [options] Override http request option.
   * @throws {@link @zerobias-org/types-core-js#ParameterRequiredError} if any required parameter is not provided
   * @example
   * ```typescript
   * const result = await api.listBoundaryAlertSubjects('00000000-0000-0000-0000-000000000000', '00000000-0000-0000-0000-000000000000', 1, 1, null);
   * ```
   * @openapi operation=listBoundaryAlertSubjects path=/app/boundaries/{boundaryId}/alerts/{id}/subjects method=GET
   * @memberof BoundaryApi
   */
  listBoundaryAlertSubjects(boundaryId: UUID, id: UUID, pageNumber?: number, pageSize?: number, sort?: SortObject): Promise<PagedResults<BoundaryAlertSubjectExtended>>;

  /**
   * List boundary alert bots subscriptions
   * @summary List boundary alert bots subscriptions
   * @param {UUID} boundaryAlertBotId 
   * @param {UUID} boundaryId 
   * @param {number} [pageNumber] The requested page. This value is 1-indexed.
   * @param {number} [pageSize] The number of items in each page of data.
   * @param {SortObject} [sort] Sort object
   * @param {*} [options] Override http request option.
   * @throws {@link @zerobias-org/types-core-js#ParameterRequiredError} if any required parameter is not provided
   * @example
   * ```typescript
   * const result = await api.listAlertBotSubscriptions('00000000-0000-0000-0000-000000000000', '00000000-0000-0000-0000-000000000000', 1, 1, null);
   * ```
   * @openapi operation=listBoundaryAlertbotSubscriptions path=/app/boundaries/{boundaryId}/alertBots/{boundaryAlertBotId}/subscriptions method=GET
   * @memberof BoundaryApi
   */
  listAlertBotSubscriptions(boundaryAlertBotId: UUID, boundaryId: UUID, pageNumber?: number, pageSize?: number, sort?: SortObject): Promise<PagedResults<AlertSubscriptionExtended>>;

  /**
   * List boundary alert bots
   * @summary List boundary alert bots
   * @param {UUID} boundaryId 
   * @param {number} [pageNumber] The requested page. This value is 1-indexed.
   * @param {number} [pageSize] The number of items in each page of data.
   * @param {UUID} [queryId] 
   * @param {UUID} [queryVersionId] 
   * @param {SortObject} [sort] Sort object
   * @param {*} [options] Override http request option.
   * @throws {@link @zerobias-org/types-core-js#ParameterRequiredError} if any required parameter is not provided
   * @example
   * ```typescript
   * const result = await api.listAlertBots('00000000-0000-0000-0000-000000000000', 1, 1, '00000000-0000-0000-0000-000000000000', '00000000-0000-0000-0000-000000000000', null);
   * ```
   * @openapi operation=listBoundaryAlertbots path=/app/boundaries/{boundaryId}/alertBots method=GET
   * @memberof BoundaryApi
   */
  listAlertBots(boundaryId: UUID, pageNumber?: number, pageSize?: number, queryId?: UUID, queryVersionId?: UUID, sort?: SortObject): Promise<PagedResults<BoundaryAlertBotExtended>>;

  /**
   * List all alerts in a boundary
   * @summary List all alerts in a boundary
   * @param {UUID} boundaryId 
   * @param {number} [pageNumber] The requested page. This value is 1-indexed.
   * @param {number} [pageSize] The number of items in each page of data.
   * @param {SortObject} [sort] Sort object
   * @param {*} [options] Override http request option.
   * @throws {@link @zerobias-org/types-core-js#ParameterRequiredError} if any required parameter is not provided
   * @example
   * ```typescript
   * const result = await api.listBoundaryAlerts('00000000-0000-0000-0000-000000000000', 1, 1, null);
   * ```
   * @openapi operation=listBoundaryAlerts path=/app/boundaries/{boundaryId}/alerts method=GET
   * @memberof BoundaryApi
   */
  listBoundaryAlerts(boundaryId: UUID, pageNumber?: number, pageSize?: number, sort?: SortObject): Promise<PagedResults<BoundaryAlertView>>;

  /**
   * Retrieves audit metrics for a specific boundary
   * @summary Retrieves audit metrics for a specific boundary
   * @param {UUID} boundaryId 
   * @param {number} [pageNumber] The requested page. This value is 1-indexed.
   * @param {number} [pageSize] The number of items in each page of data.
   * @param {AuditStatusEnum} [status] Filter by status
   * @param {AuditTypeEnum} [type] Filter by type
   * @param {*} [options] Override http request option.
   * @throws {@link @zerobias-org/types-core-js#ParameterRequiredError} if any required parameter is not provided
   * @example
   * ```typescript
   * const result = await api.listBoundaryAuditMetrics('00000000-0000-0000-0000-000000000000', 1, 1, null, null);
   * ```
   * @openapi operation=listBoundaryAuditMetrics path=/boundaries/{boundaryId}/auditMetrics method=GET
   * @memberof BoundaryApi
   */
  listBoundaryAuditMetrics(boundaryId: UUID, pageNumber?: number, pageSize?: number, status?: AuditStatusEnumDef, type?: AuditTypeEnumDef): Promise<PagedResults<BoundaryAuditMetrics>>;

  /**
   * Retrieves a list of audits for a boundary
   * @summary Retrieves a list of audits for a boundary
   * @param {UUID} boundaryId 
   * @param {number} [pageNumber] The requested page. This value is 1-indexed.
   * @param {number} [pageSize] The number of items in each page of data.
   * @param {AuditStatusEnum} [status] Filter by status
   * @param {AuditTypeEnum} [type] Filter by type
   * @param {boolean} [audited] Filter by audited flag
   * @param {*} [options] Override http request option.
   * @throws {@link @zerobias-org/types-core-js#ParameterRequiredError} if any required parameter is not provided
   * @example
   * ```typescript
   * const result = await api.listBoundaryAudits('00000000-0000-0000-0000-000000000000', 1, 1, null, null, true);
   * ```
   * @openapi operation=listBoundaryAudits path=/boundaries/{boundaryId}/audits method=GET
   * @memberof BoundaryApi
   */
  listBoundaryAudits(boundaryId: UUID, pageNumber?: number, pageSize?: number, status?: AuditStatusEnumDef, type?: AuditTypeEnumDef, audited?: boolean): Promise<PagedResults<Audit & AuditExtended>>;

  /**
   * Page boundary components
   * @summary Page boundary components
   * @param {number} [pageNumber] The requested page. This value is 1-indexed.
   * @param {number} [pageSize] The number of items in each page of data.
   * @param {UUID} [boundaryId] Boundary Id filter
   * @param {UUID} [componentId] Component ID filter
   * @param {*} [options] Override http request option.
   * @throws {@link @zerobias-org/types-core-js#ParameterRequiredError} if any required parameter is not provided
   * @example
   * ```typescript
   * const result = await api.listBoundaryComponents(1, 1, '00000000-0000-0000-0000-000000000000', '00000000-0000-0000-0000-000000000000');
   * ```
   * @openapi operation=listBoundaryComponents path=/app/boundaryComponents method=GET
   * @memberof BoundaryApi
   */
  listBoundaryComponents(pageNumber?: number, pageSize?: number, boundaryId?: UUID, componentId?: UUID): Promise<PagedResults<BoundaryComponentExtended>>;

  /**
   * Page boundary components by boundary id
   * @summary Page boundary components by boundary id
   * @param {UUID} boundaryId 
   * @param {number} [pageNumber] The requested page. This value is 1-indexed.
   * @param {number} [pageSize] The number of items in each page of data.
   * @param {*} [options] Override http request option.
   * @throws {@link @zerobias-org/types-core-js#ParameterRequiredError} if any required parameter is not provided
   * @example
   * ```typescript
   * const result = await api.listBoundaryComponentsByBoundaryId('00000000-0000-0000-0000-000000000000', 1, 1);
   * ```
   * @openapi operation=listBoundaryComponentsByBoundaryId path=/app/boundaries/{boundaryId}/components method=GET
   * @memberof BoundaryApi
   */
  listBoundaryComponentsByBoundaryId(boundaryId: UUID, pageNumber?: number, pageSize?: number): Promise<PagedResults<BoundaryComponentExtended>>;

  /**
   * Retrieves a list of all connections for a boundary
   * @summary Retrieves a list of all connections for a boundary
   * @param {UUID} boundaryId 
   * @param {number} [pageNumber] The requested page. This value is 1-indexed.
   * @param {number} [pageSize] The number of items in each page of data.
   * @param {*} [options] Override http request option.
   * @throws {@link @zerobias-org/types-core-js#ParameterRequiredError} if any required parameter is not provided
   * @example
   * ```typescript
   * const result = await api.listBoundaryConnections('00000000-0000-0000-0000-000000000000', 1, 1);
   * ```
   * @openapi operation=listBoundaryConnections path=/boundaries/{boundaryId}/connections method=GET
   * @memberof BoundaryApi
   */
  listBoundaryConnections(boundaryId: UUID, pageNumber?: number, pageSize?: number): Promise<PagedResults<BoundaryConnectionForList>>;

  /**
   * Retrieves a list of events for a boundary
   * @summary Retrieves a list of events for a boundary
   * @param {UUID} boundaryId 
   * @param {number} [pageNumber] The requested page. This value is 1-indexed.
   * @param {number} [pageSize] The number of items in each page of data.
   * @param {*} [options] Override http request option.
   * @throws {@link @zerobias-org/types-core-js#ParameterRequiredError} if any required parameter is not provided
   * @example
   * ```typescript
   * const result = await api.listBoundaryEvents('00000000-0000-0000-0000-000000000000', 1, 1);
   * ```
   * @openapi operation=listBoundaryEvents path=/boundaries/{boundaryId}/events method=GET
   * @memberof BoundaryApi
   */
  listBoundaryEvents(boundaryId: UUID, pageNumber?: number, pageSize?: number): Promise<PagedResults<BoundaryEvent & ExtendedBoundaryEvent>>;

  /**
   * Retrieves a list of all boundary evidence by boundary id
   * @summary Retrieves a list of all boundary evidence by boundary id
   * @param {UUID} boundaryId 
   * @param {number} [pageNumber] The requested page. This value is 1-indexed.
   * @param {number} [pageSize] The number of items in each page of data.
   * @param {BoundaryEvidenceStatusEnum} [status] 
   * @param {UUID} [productId] 
   * @param {Array<UUID>} [evidenceDefinitionIds] 
   * @param {BoundaryEvidenceSortColumns} [sortColumn] 
   * @param {SortOrderOptions} [sortOrder] 
   * @param {*} [options] Override http request option.
   * @throws {@link @zerobias-org/types-core-js#ParameterRequiredError} if any required parameter is not provided
   * @example
   * ```typescript
   * const result = await api.listBoundaryEvidence('00000000-0000-0000-0000-000000000000', 1, 1, null, '00000000-0000-0000-0000-000000000000', null, null, null);
   * ```
   * @openapi operation=listBoundaryEvidence path=/boundaries/{boundaryId}/evidence method=GET
   * @memberof BoundaryApi
   */
  listBoundaryEvidence(boundaryId: UUID, pageNumber?: number, pageSize?: number, status?: BoundaryEvidenceStatusEnumDef, productId?: UUID, evidenceDefinitionIds?: Array<UUID>, sortColumn?: BoundaryEvidenceSortColumnsDef, sortOrder?: SortOrderOptionsDef): Promise<PagedResults<BoundaryEvidence & ExtendedBoundaryEvidence>>;

  /**
   * Retrieves a list of parties for a boundary
   * @summary Retrieves a list of parties for a boundary
   * @param {UUID} boundaryId 
   * @param {number} [pageNumber] The requested page. This value is 1-indexed.
   * @param {number} [pageSize] The number of items in each page of data.
   * @param {PartyTypeEnum} [partyType] 
   * @param {boolean} [assignable] 
   * @param {string} [search] comma separated string of keywords to search against
   * @param {SortObject} [sort] Sort object
   * @param {*} [options] Override http request option.
   * @throws {@link @zerobias-org/types-core-js#ParameterRequiredError} if any required parameter is not provided
   * @example
   * ```typescript
   * const result = await api.listBoundaryParties('00000000-0000-0000-0000-000000000000', 1, 1, null, true, 'search', null);
   * ```
   * @openapi operation=listBoundaryParties path=/boundaries/{boundaryId}/parties method=GET
   * @memberof BoundaryApi
   */
  listBoundaryParties(boundaryId: UUID, pageNumber?: number, pageSize?: number, partyType?: PartyTypeEnumDef, assignable?: boolean, search?: string, sort?: SortObject): Promise<PagedResults<PartyExtended>>;

  /**
   * Retrieves a boundary party Raci RollUP matrix
   * @summary Retrieves a boundary party Raci RollUP matrix
   * @param {UUID} boundaryId 
   * @param {UUID} partyId 
   * @param {*} [options] Override http request option.
   * @throws {@link @zerobias-org/types-core-js#ParameterRequiredError} if any required parameter is not provided
   * @example
   * ```typescript
   * const result = await api.listBoundaryPartyRaci('00000000-0000-0000-0000-000000000000', '00000000-0000-0000-0000-000000000000');
   * ```
   * @openapi operation=listBoundaryPartyRaci path=/boundaries/{boundaryId}/parties/{partyId}/responsibilityMatrix method=GET
   * @memberof BoundaryApi
   */
  listBoundaryPartyRaci(boundaryId: UUID, partyId: UUID): Promise<Array<RaciRollup>>;

  /**
   * Retrieves paged list of roles assigned to a party on a boundary
   * @summary Retrieves paged list of roles assigned to a party on a boundary
   * @param {UUID} boundaryId 
   * @param {UUID} partyId 
   * @param {number} [pageNumber] The requested page. This value is 1-indexed.
   * @param {number} [pageSize] The number of items in each page of data.
   * @param {*} [options] Override http request option.
   * @throws {@link @zerobias-org/types-core-js#ParameterRequiredError} if any required parameter is not provided
   * @example
   * ```typescript
   * const result = await api.listBoundaryPartyRoles('00000000-0000-0000-0000-000000000000', '00000000-0000-0000-0000-000000000000', 1, 1);
   * ```
   * @openapi operation=listBoundaryPartyRoles path=/app/boundaries/{boundaryId}/parties/{partyId}/roles method=GET
   * @memberof BoundaryApi
   */
  listBoundaryPartyRoles(boundaryId: UUID, partyId: UUID, pageNumber?: number, pageSize?: number): Promise<PagedResults<BoundaryPartyRoleExtended>>;

  /**
   * Page boundary party roles by boundary id
   * @summary Page boundary party roles by boundary id
   * @param {UUID} boundaryId 
   * @param {number} [pageNumber] The requested page. This value is 1-indexed.
   * @param {number} [pageSize] The number of items in each page of data.
   * @param {UUID} [partyId] Party Id filter
   * @param {*} [options] Override http request option.
   * @throws {@link @zerobias-org/types-core-js#ParameterRequiredError} if any required parameter is not provided
   * @example
   * ```typescript
   * const result = await api.listBoundaryPartyRolesByBoundaryId('00000000-0000-0000-0000-000000000000', 1, 1, '00000000-0000-0000-0000-000000000000');
   * ```
   * @openapi operation=listBoundaryPartyRolesByBoundaryId path=/app/boundaries/{boundaryId}/partyRoles method=GET
   * @memberof BoundaryApi
   */
  listBoundaryPartyRolesByBoundaryId(boundaryId: UUID, pageNumber?: number, pageSize?: number, partyId?: UUID): Promise<PagedResults<BoundaryPartyRoleExtended>>;

  /**
   * List pipelines for a certain boundary
   * @summary List pipelines for a certain boundary
   * @param {UUID} boundaryId 
   * @param {number} [pageNumber] The requested page. This value is 1-indexed.
   * @param {number} [pageSize] The number of items in each page of data.
   * @param {string} [keywords] 
   * @param {UUID} [productId] 
   * @param {PipelineAdminStatusEnum} [adminStatus] 
   * @param {PipelineExecutionStatusEnum} [executionStatus] 
   * @param {PipelineFormatEnum} [type] 
   * @param {SortObject} [sort] Sort object
   * @param {*} [options] Override http request option.
   * @throws {@link @zerobias-org/types-core-js#ParameterRequiredError} if any required parameter is not provided
   * @example
   * ```typescript
   * const result = await api.listBoundaryPipelines('00000000-0000-0000-0000-000000000000', 1, 1, 'keywords', '00000000-0000-0000-0000-000000000000', null, null, null, null);
   * ```
   * @openapi operation=listBoundaryPipelines path=/boundaries/{boundaryId}/pipelines method=GET
   * @memberof BoundaryApi
   */
  listBoundaryPipelines(boundaryId: UUID, pageNumber?: number, pageSize?: number, keywords?: string, productId?: UUID, adminStatus?: PipelineAdminStatusEnumDef, executionStatus?: PipelineExecutionStatusEnumDef, type?: PipelineFormatEnumDef, sort?: SortObject): Promise<PagedResults<Pipeline>>;

  /**
   * Retrieves a list of all connections for a boundary
   * @summary Retrieves a list of all connections for a boundary
   * @param {UUID} boundaryId 
   * @param {UUID} boundaryProductId 
   * @param {number} [pageNumber] The requested page. This value is 1-indexed.
   * @param {number} [pageSize] The number of items in each page of data.
   * @param {SortObject} [sort] Sort object
   * @param {*} [options] Override http request option.
   * @throws {@link @zerobias-org/types-core-js#ParameterRequiredError} if any required parameter is not provided
   * @example
   * ```typescript
   * const result = await api.listBoundaryProductConnections('00000000-0000-0000-0000-000000000000', '00000000-0000-0000-0000-000000000000', 1, 1, null);
   * ```
   * @openapi operation=listBoundaryProductConnections path=/boundaries/{boundaryId}/products/{boundaryProductId}/connections method=GET
   * @memberof BoundaryApi
   */
  listBoundaryProductConnections(boundaryId: UUID, boundaryProductId: UUID, pageNumber?: number, pageSize?: number, sort?: SortObject): Promise<PagedResults<BoundaryConnectionForList>>;

  /**
   * Retrieves a boundary product
   * @summary Retrieves a boundary product
   * @param {UUID} boundaryId 
   * @param {UUID} boundaryProductId 
   * @param {number} [pageNumber] The requested page. This value is 1-indexed.
   * @param {number} [pageSize] The number of items in each page of data.
   * @param {string} [search] 
   * @param {PipelineFormatEnum} [format] 
   * @param {UUID} [targetId] 
   * @param {SortObject} [sort] Sort object
   * @param {boolean} [showPreviews] 
   * @param {*} [options] Override http request option.
   * @throws {@link @zerobias-org/types-core-js#ParameterRequiredError} if any required parameter is not provided
   * @example
   * ```typescript
   * const result = await api.listBoundaryProductPipelines('00000000-0000-0000-0000-000000000000', '00000000-0000-0000-0000-000000000000', 1, 1, 'search', null, '00000000-0000-0000-0000-000000000000', null, true);
   * ```
   * @openapi operation=listBoundaryProductPipelines path=/boundaries/{boundaryId}/products/{boundaryProductId}/pipelines method=GET
   * @memberof BoundaryApi
   */
  listBoundaryProductPipelines(boundaryId: UUID, boundaryProductId: UUID, pageNumber?: number, pageSize?: number, search?: string, format?: PipelineFormatEnumDef, targetId?: UUID, sort?: SortObject, showPreviews?: boolean): Promise<PagedResults<BoundaryProductPipeline>>;

  /**
   * Retrieves a list of products for a boundary
   * @summary Retrieves a list of products for a boundary
   * @param {UUID} boundaryId 
   * @param {number} [pageNumber] The requested page. This value is 1-indexed.
   * @param {number} [pageSize] The number of items in each page of data.
   * @param {CatalogPublishStatusEnum} [status] Filter by status
   * @param {string} [keywords] Search like filter
   * @param {SortObject} [sort] 
   * @param {*} [options] Override http request option.
   * @throws {@link @zerobias-org/types-core-js#ParameterRequiredError} if any required parameter is not provided
   * @example
   * ```typescript
   * const result = await api.listBoundaryProductsByBoundary('00000000-0000-0000-0000-000000000000', 1, 1, null, 'keywords', null);
   * ```
   * @openapi operation=listBoundaryProductsByBoundary path=/boundaries/{boundaryId}/products method=GET
   * @memberof BoundaryApi
   */
  listBoundaryProductsByBoundary(boundaryId: UUID, pageNumber?: number, pageSize?: number, status?: CatalogPublishStatusEnumDef, keywords?: string, sort?: SortObject): Promise<PagedResults<BoundaryProductExtended>>;

  /**
   * List all alerts bound to a query
   * @summary List all alerts bound to a query
   * @param {UUID} boundaryId 
   * @param {UUID} queryId A queryId or queryVersionId.
   * @param {number} [pageNumber] The requested page. This value is 1-indexed.
   * @param {number} [pageSize] The number of items in each page of data.
   * @param {SortObject} [sort] Sort object
   * @param {*} [options] Override http request option.
   * @throws {@link @zerobias-org/types-core-js#ParameterRequiredError} if any required parameter is not provided
   * @example
   * ```typescript
   * const result = await api.listBoundaryQueryAlerts('00000000-0000-0000-0000-000000000000', '00000000-0000-0000-0000-000000000000', 1, 1, null);
   * ```
   * @openapi operation=listBoundaryQueryAlerts path=/app/boundaries/{boundaryId}/queries/{queryId}/alerts method=GET
   * @memberof BoundaryApi
   */
  listBoundaryQueryAlerts(boundaryId: UUID, queryId: UUID, pageNumber?: number, pageSize?: number, sort?: SortObject): Promise<PagedResults<BoundaryAlertView>>;

  /**
   * Retrieve paged list of boundary roles and parties if assigned
   * @summary Retrieve paged list of boundary roles and parties if assigned
   * @param {UUID} boundaryId 
   * @param {number} [pageNumber] The requested page. This value is 1-indexed.
   * @param {number} [pageSize] The number of items in each page of data.
   * @param {UUID} [roleCategoryId] 
   * @param {*} [options] Override http request option.
   * @throws {@link @zerobias-org/types-core-js#ParameterRequiredError} if any required parameter is not provided
   * @example
   * ```typescript
   * const result = await api.listBoundaryRoles('00000000-0000-0000-0000-000000000000', 1, 1, '00000000-0000-0000-0000-000000000000');
   * ```
   * @openapi operation=listBoundaryRoles path=/app/boundaries/{boundaryId}/roles method=GET
   * @memberof BoundaryApi
   */
  listBoundaryRoles(boundaryId: UUID, pageNumber?: number, pageSize?: number, roleCategoryId?: UUID): Promise<PagedResults<BoundaryRoleExtended>>;

  /**
   * Retrieves a list of scf controls for a boundary
   * @summary Retrieves a list of scf controls for a boundary
   * @param {UUID} boundaryId 
   * @param {number} [pageNumber] The requested page. This value is 1-indexed.
   * @param {number} [pageSize] The number of items in each page of data.
   * @param {UUID} [frameworkElementId] 
   * @param {string} [scfDomainCode] 
   * @param {boolean} [performed] 
   * @param {boolean} [answered] 
   * @param {*} [options] Override http request option.
   * @throws {@link @zerobias-org/types-core-js#ParameterRequiredError} if any required parameter is not provided
   * @example
   * ```typescript
   * const result = await api.listBoundaryScfControls('00000000-0000-0000-0000-000000000000', 1, 1, '00000000-0000-0000-0000-000000000000', 'scfDomainCode', true, true);
   * ```
   * @openapi operation=listBoundaryScfControls path=/boundaries/{boundaryId}/scfControls method=GET
   * @memberof BoundaryApi
   */
  listBoundaryScfControls(boundaryId: UUID, pageNumber?: number, pageSize?: number, frameworkElementId?: UUID, scfDomainCode?: string, performed?: boolean, answered?: boolean): Promise<PagedResults<ExtendedBoundaryScfControl>>;

  /**
   * List standard baselines that have been added to a boundary
   * @summary List standard baselines that have been added to a boundary
   * @param {UUID} boundaryId 
   * @param {UUID} boundaryStandardBaselineId 
   * @param {number} [pageNumber] The requested page. This value is 1-indexed.
   * @param {number} [pageSize] The number of items in each page of data.
   * @param {SortObject} [sort] Sort object
   * @param {*} [options] Override http request option.
   * @throws {@link @zerobias-org/types-core-js#ParameterRequiredError} if any required parameter is not provided
   * @example
   * ```typescript
   * const result = await api.listStandardBaselineElements('00000000-0000-0000-0000-000000000000', '00000000-0000-0000-0000-000000000000', 1, 1, null);
   * ```
   * @openapi operation=listBoundaryStandardBaselineElements path=/app/boundaries/{boundaryId}/standardBaselines/{boundaryStandardBaselineId}/elements method=GET
   * @memberof BoundaryApi
   */
  listStandardBaselineElements(boundaryId: UUID, boundaryStandardBaselineId: UUID, pageNumber?: number, pageSize?: number, sort?: SortObject): Promise<PagedResults<ElementExtended>>;

  /**
   * List standard baselines that have been added to a boundary
   * @summary List standard baselines that have been added to a boundary
   * @param {UUID} boundaryId 
   * @param {number} [pageNumber] The requested page. This value is 1-indexed.
   * @param {number} [pageSize] The number of items in each page of data.
   * @param {*} [options] Override http request option.
   * @throws {@link @zerobias-org/types-core-js#ParameterRequiredError} if any required parameter is not provided
   * @example
   * ```typescript
   * const result = await api.listStandardBaselines('00000000-0000-0000-0000-000000000000', 1, 1);
   * ```
   * @openapi operation=listBoundaryStandardBaselines path=/app/boundaries/{boundaryId}/standardBaselines method=GET
   * @memberof BoundaryApi
   */
  listStandardBaselines(boundaryId: UUID, pageNumber?: number, pageSize?: number): Promise<PagedResults<BoundaryStandardBaselineExtended>>;

  /**
   * Retrieves a list of suggested products for a boundary
   * @summary Retrieves a list of suggested products for a boundary
   * @param {UUID} boundaryId 
   * @param {number} [pageNumber] The requested page. This value is 1-indexed.
   * @param {number} [pageSize] The number of items in each page of data.
   * @param {string} [keywords] Search like filter
   * @param {*} [options] Override http request option.
   * @throws {@link @zerobias-org/types-core-js#ParameterRequiredError} if any required parameter is not provided
   * @example
   * ```typescript
   * const result = await api.listBoundarySuggestedProducts('00000000-0000-0000-0000-000000000000', 1, 1, 'keywords');
   * ```
   * @openapi operation=listBoundarySuggestedProducts path=/boundaries/{boundaryId}/suggestedProducts method=GET
   * @memberof BoundaryApi
   */
  listBoundarySuggestedProducts(boundaryId: UUID, pageNumber?: number, pageSize?: number, keywords?: string): Promise<PagedResults<BoundarySuggestedProduct>>;

  /**
   * Retrieves a list of targets for a boundary
   * @summary Retrieves a list of targets for a boundary
   * @param {UUID} boundaryId 
   * @param {UUID} boundaryProductId 
   * @param {number} [pageNumber] The requested page. This value is 1-indexed.
   * @param {number} [pageSize] The number of items in each page of data.
   * @param {string} [keywords] Search like filter
   * @param {*} [options] Override http request option.
   * @throws {@link @zerobias-org/types-core-js#ParameterRequiredError} if any required parameter is not provided
   * @example
   * ```typescript
   * const result = await api.listBoundaryTargetsByProduct('00000000-0000-0000-0000-000000000000', '00000000-0000-0000-0000-000000000000', 1, 1, 'keywords');
   * ```
   * @openapi operation=listBoundaryTargetsByProduct path=/boundaries/{boundaryId}/products/{boundaryProductId}/targets method=GET
   * @memberof BoundaryApi
   */
  listBoundaryTargetsByProduct(boundaryId: UUID, boundaryProductId: UUID, pageNumber?: number, pageSize?: number, keywords?: string): Promise<PagedResults<BoundaryProductTarget & ExtendedBoundaryProductTarget>>;

  /**
   * Retrieves a list of teams metrics for a boundary
   * @summary Retrieves a list of teams metrics for a boundary
   * @param {UUID} boundaryId 
   * @param {number} [pageNumber] The requested page. This value is 1-indexed.
   * @param {number} [pageSize] The number of items in each page of data.
   * @param {*} [options] Override http request option.
   * @throws {@link @zerobias-org/types-core-js#ParameterRequiredError} if any required parameter is not provided
   * @example
   * ```typescript
   * const result = await api.listBoundaryTeamMetrics('00000000-0000-0000-0000-000000000000', 1, 1);
   * ```
   * @openapi operation=listBoundaryTeamMetrics path=/boundaries/{boundaryId}/teamMetrics method=GET
   * @memberof BoundaryApi
   */
  listBoundaryTeamMetrics(boundaryId: UUID, pageNumber?: number, pageSize?: number): Promise<PagedResults<BoundaryTeamMetrics>>;

  /**
   * Retrieves a list of evidence definitions in scope for a boundary team scf control
   * @summary Retrieves a list of evidence definitions in scope for a boundary team scf control
   * @param {UUID} boundaryId 
   * @param {UUID} teamId 
   * @param {UUID} scfControlId 
   * @param {number} [pageNumber] The requested page. This value is 1-indexed.
   * @param {number} [pageSize] The number of items in each page of data.
   * @param {*} [options] Override http request option.
   * @throws {@link @zerobias-org/types-core-js#ParameterRequiredError} if any required parameter is not provided
   * @example
   * ```typescript
   * const result = await api.listBoundaryTeamScfControlEvidenceDefintions('00000000-0000-0000-0000-000000000000', '00000000-0000-0000-0000-000000000000', '00000000-0000-0000-0000-000000000000', 1, 1);
   * ```
   * @openapi operation=listBoundaryTeamScfControlEvidenceDefintions path=/boundaries/{boundaryId}/teams/{teamId}/scfControlTree/{scfControlId}/evidenceDefinitions method=GET
   * @memberof BoundaryApi
   */
  listBoundaryTeamScfControlEvidenceDefintions(boundaryId: UUID, teamId: UUID, scfControlId: UUID, pageNumber?: number, pageSize?: number): Promise<PagedResults<BoundaryTeamScfControlEvidenceDefinitionImplementation>>;

  /**
   * Retrieves a list of scf control data for a boundary team
   * @summary Retrieves a list of scf control data for a boundary team
   * @param {UUID} boundaryId 
   * @param {UUID} teamId 
   * @param {number} [pageNumber] The requested page. This value is 1-indexed.
   * @param {number} [pageSize] The number of items in each page of data.
   * @param {string} [domain] Filter by domain
   * @param {string} [code] Filter by code
   * @param {*} [options] Override http request option.
   * @throws {@link @zerobias-org/types-core-js#ParameterRequiredError} if any required parameter is not provided
   * @example
   * ```typescript
   * const result = await api.listBoundaryTeamScfControls('00000000-0000-0000-0000-000000000000', '00000000-0000-0000-0000-000000000000', 1, 1, 'domain', 'code');
   * ```
   * @openapi operation=listBoundaryTeamScfControls path=/boundaries/{boundaryId}/teams/{teamId}/scfControls method=GET
   * @memberof BoundaryApi
   */
  listBoundaryTeamScfControls(boundaryId: UUID, teamId: UUID, pageNumber?: number, pageSize?: number, domain?: string, code?: string): Promise<PagedResults<BoundaryTeamScfControl>>;

  /**
   * Retrieves a list of teams for a boundary
   * @summary Retrieves a list of teams for a boundary
   * @param {UUID} boundaryId 
   * @param {number} [pageNumber] The requested page. This value is 1-indexed.
   * @param {number} [pageSize] The number of items in each page of data.
   * @param {SortObject} [sort] Sort object
   * @param {*} [options] Override http request option.
   * @throws {@link @zerobias-org/types-core-js#ParameterRequiredError} if any required parameter is not provided
   * @example
   * ```typescript
   * const result = await api.listBoundaryTeams('00000000-0000-0000-0000-000000000000', 1, 1, null);
   * ```
   * @openapi operation=listBoundaryTeams path=/boundaries/{boundaryId}/teams method=GET
   * @memberof BoundaryApi
   */
  listBoundaryTeams(boundaryId: UUID, pageNumber?: number, pageSize?: number, sort?: SortObject): Promise<PagedResults<BoundaryTeam>>;

  /**
   * List tests within a boundary with filters
   * @summary List tests within a boundary with filters
   * @param {UUID} boundaryId 
   * @param {number} [pageNumber] The requested page. This value is 1-indexed.
   * @param {number} [pageSize] The number of items in each page of data.
   * @param {UUID} [standardId] 
   * @param {UUID} [benchmarkId] 
   * @param {UUID} [testCaseId] 
   * @param {UUID} [componentId] 
   * @param {TestResultEnum} [status] 
   * @param {SortObject} [sort] Sort object
   * @param {*} [options] Override http request option.
   * @throws {@link @zerobias-org/types-core-js#ParameterRequiredError} if any required parameter is not provided
   * @example
   * ```typescript
   * const result = await api.listTests('00000000-0000-0000-0000-000000000000', 1, 1, '00000000-0000-0000-0000-000000000000', '00000000-0000-0000-0000-000000000000', '00000000-0000-0000-0000-000000000000', '00000000-0000-0000-0000-000000000000', null, null);
   * ```
   * @openapi operation=listBoundaryTests path=/app/boundaries/{boundaryId}/tests method=GET
   * @memberof BoundaryApi
   */
  listTests(boundaryId: UUID, pageNumber?: number, pageSize?: number, standardId?: UUID, benchmarkId?: UUID, testCaseId?: UUID, componentId?: UUID, status?: TestResultEnumDef, sort?: SortObject): Promise<PagedResults<TestExtended>>;

  /**
   * Retrieves a list of scf domains unmanaged for a boundary
   * @summary Retrieves a list of scf domains unmanaged for a boundary
   * @param {UUID} boundaryId 
   * @param {number} [pageNumber] The requested page. This value is 1-indexed.
   * @param {number} [pageSize] The number of items in each page of data.
   * @param {*} [options] Override http request option.
   * @throws {@link @zerobias-org/types-core-js#ParameterRequiredError} if any required parameter is not provided
   * @example
   * ```typescript
   * const result = await api.listBoundaryUnmanagedDomains('00000000-0000-0000-0000-000000000000', 1, 1);
   * ```
   * @openapi operation=listBoundaryUnmanagedDomains path=/boundaries/{boundaryId}/unmanagedDomains method=GET
   * @memberof BoundaryApi
   */
  listBoundaryUnmanagedDomains(boundaryId: UUID, pageNumber?: number, pageSize?: number): Promise<PagedResults<ScfDomain>>;

  /**
   * Page boundary party roles with filters
   * @summary Page boundary party roles with filters
   * @param {number} [pageNumber] The requested page. This value is 1-indexed.
   * @param {number} [pageSize] The number of items in each page of data.
   * @param {UUID} [partyId] Party Id filter
   * @param {UUID} [boundaryId] Boundary Id filter
   * @param {UUID} [roleId] Role ID filter
   * @param {*} [options] Override http request option.
   * @throws {@link @zerobias-org/types-core-js#ParameterRequiredError} if any required parameter is not provided
   * @example
   * ```typescript
   * const result = await api.listFilterBoundaryPartyRoles(1, 1, '00000000-0000-0000-0000-000000000000', '00000000-0000-0000-0000-000000000000', '00000000-0000-0000-0000-000000000000');
   * ```
   * @openapi operation=listFilterBoundaryPartyRoles path=/app/boundaryPartyRoles method=GET
   * @memberof BoundaryApi
   */
  listFilterBoundaryPartyRoles(pageNumber?: number, pageSize?: number, partyId?: UUID, boundaryId?: UUID, roleId?: UUID): Promise<PagedResults<BoundaryPartyRoleExtended>>;

  /**
   * Remove crosswalk version from boundary
   * @summary Remove crosswalk version from boundary
   * @param {UUID} boundaryId 
   * @param {UUID} boundaryCrosswalkVersionId 
   * @param {*} [options] Override http request option.
   * @throws {@link @zerobias-org/types-core-js#ParameterRequiredError} if any required parameter is not provided
   * @example
   * ```typescript
   * const result = await api.removeCrosswalkVersion('00000000-0000-0000-0000-000000000000', '00000000-0000-0000-0000-000000000000');
   * ```
   * @openapi operation=removeBoundaryCrosswalkVersion path=/app/boundaries/{boundaryId}/crosswalkVersions/{boundaryCrosswalkVersionId} method=DELETE
   * @memberof BoundaryApi
   */
  removeCrosswalkVersion(boundaryId: UUID, boundaryCrosswalkVersionId: UUID): Promise<void>;

  /**
   * Remove standard baseline from boundary
   * @summary Remove standard baseline from boundary
   * @param {UUID} boundaryId 
   * @param {UUID} boundaryStandardBaselineId 
   * @param {*} [options] Override http request option.
   * @throws {@link @zerobias-org/types-core-js#ParameterRequiredError} if any required parameter is not provided
   * @example
   * ```typescript
   * const result = await api.removeStandardBaseline('00000000-0000-0000-0000-000000000000', '00000000-0000-0000-0000-000000000000');
   * ```
   * @openapi operation=removeBoundaryStandardBaseline path=/app/boundaries/{boundaryId}/standardBaselines/{boundaryStandardBaselineId} method=DELETE
   * @memberof BoundaryApi
   */
  removeStandardBaseline(boundaryId: UUID, boundaryStandardBaselineId: UUID): Promise<void>;

  /**
   * Manually run an alert bot
   * @summary Manually run an alert bot
   * @param {UUID} boundaryId 
   * @param {UUID} boundaryAlertBotId 
   * @param {*} [options] Override http request option.
   * @throws {@link @zerobias-org/types-core-js#ParameterRequiredError} if any required parameter is not provided
   * @example
   * ```typescript
   * const result = await api.runAlertBot('00000000-0000-0000-0000-000000000000', '00000000-0000-0000-0000-000000000000');
   * ```
   * @openapi operation=runBoundaryAlertBot path=/app/boundaries/{boundaryId}/alertBots/{boundaryAlertBotId} method=POST
   * @memberof BoundaryApi
   */
  runAlertBot(boundaryId: UUID, boundaryAlertBotId: UUID): Promise<void>;

  /**
   * Subscribe to an Alert Bot's alerts
   * @summary Subscribe to an Alert Bot's alerts
   * @param {UUID} boundaryId 
   * @param {UUID} boundaryAlertBotId 
   * @param {*} [options] Override http request option.
   * @throws {@link @zerobias-org/types-core-js#ParameterRequiredError} if any required parameter is not provided
   * @example
   * ```typescript
   * const result = await api.subscribe('00000000-0000-0000-0000-000000000000', '00000000-0000-0000-0000-000000000000');
   * ```
   * @openapi operation=subscribeToBoundaryAlertBotAlerts path=/app/boundaries/{boundaryId}/alertBots/{boundaryAlertBotId}/subscribe method=PUT
   * @memberof BoundaryApi
   */
  subscribe(boundaryId: UUID, boundaryAlertBotId: UUID): Promise<AlertSubscriptionExtended>;

  /**
   * Unsubscribe from and alert bot's alerts
   * @summary Unsubscribe from and alert bot's alerts
   * @param {UUID} boundaryId 
   * @param {UUID} boundaryAlertBotId 
   * @param {*} [options] Override http request option.
   * @throws {@link @zerobias-org/types-core-js#ParameterRequiredError} if any required parameter is not provided
   * @example
   * ```typescript
   * const result = await api.unsubscribe('00000000-0000-0000-0000-000000000000', '00000000-0000-0000-0000-000000000000');
   * ```
   * @openapi operation=unsubscribeFromBoundaryAlertBotAlerts path=/app/boundaries/{boundaryId}/alertBots/{boundaryAlertBotId}/unsubscribe method=PUT
   * @memberof BoundaryApi
   */
  unsubscribe(boundaryId: UUID, boundaryAlertBotId: UUID): Promise<AlertSubscriptionExtended>;

  /**
   * Updates a boundary
   * @summary Updates a boundary
   * @param {UUID} boundaryId 
   * @param {UpdateBoundary} updateBoundary 
   * @param {*} [options] Override http request option.
   * @throws {@link @zerobias-org/types-core-js#ParameterRequiredError} if any required parameter is not provided
   * @example
   * ```typescript
   * const result = await api.updateBoundary('00000000-0000-0000-0000-000000000000', null);
   * ```
   * @openapi operation=updateBoundary path=/boundaries/{boundaryId} method=PUT
   * @memberof BoundaryApi
   */
  updateBoundary(boundaryId: UUID, updateBoundary: UpdateBoundary): Promise<Boundary>;

  /**
   * Update an alert bot
   * @summary Update an alert bot
   * @param {UUID} boundaryId 
   * @param {UUID} boundaryAlertBotId 
   * @param {UpdateBoundaryAlertBot} updateBoundaryAlertBot 
   * @param {*} [options] Override http request option.
   * @throws {@link @zerobias-org/types-core-js#ParameterRequiredError} if any required parameter is not provided
   * @example
   * ```typescript
   * const result = await api.updateAlertBot('00000000-0000-0000-0000-000000000000', '00000000-0000-0000-0000-000000000000', null);
   * ```
   * @openapi operation=updateBoundaryAlertBot path=/app/boundaries/{boundaryId}/alertBots/{boundaryAlertBotId} method=PATCH
   * @memberof BoundaryApi
   */
  updateAlertBot(boundaryId: UUID, boundaryAlertBotId: UUID, updateBoundaryAlertBot: UpdateBoundaryAlertBot): Promise<BoundaryAlertBotExtended>;

  /**
   * Updates a boundary evidence
   * @summary Updates a boundary evidence
   * @param {UUID} boundaryId 
   * @param {UUID} evidenceId 
   * @param {UpdateBoundaryEvidence} updateBoundaryEvidence 
   * @param {*} [options] Override http request option.
   * @throws {@link @zerobias-org/types-core-js#ParameterRequiredError} if any required parameter is not provided
   * @example
   * ```typescript
   * const result = await api.updateBoundaryEvidence('00000000-0000-0000-0000-000000000000', '00000000-0000-0000-0000-000000000000', null);
   * ```
   * @openapi operation=updateBoundaryEvidence path=/boundaries/{boundaryId}/evidence/{evidenceId} method=PUT
   * @memberof BoundaryApi
   */
  updateBoundaryEvidence(boundaryId: UUID, evidenceId: UUID, updateBoundaryEvidence: UpdateBoundaryEvidence): Promise<BoundaryEvidence>;

  /**
   * Updates a boundary product
   * @summary Updates a boundary product
   * @param {UUID} boundaryId 
   * @param {UUID} boundaryProductId 
   * @param {UpdateBoundaryProduct} updateBoundaryProduct 
   * @param {*} [options] Override http request option.
   * @throws {@link @zerobias-org/types-core-js#ParameterRequiredError} if any required parameter is not provided
   * @example
   * ```typescript
   * const result = await api.updateBoundaryProduct('00000000-0000-0000-0000-000000000000', '00000000-0000-0000-0000-000000000000', null);
   * ```
   * @openapi operation=updateBoundaryProduct path=/boundaries/{boundaryId}/products/{boundaryProductId} method=PUT
   * @memberof BoundaryApi
   */
  updateBoundaryProduct(boundaryId: UUID, boundaryProductId: UUID, updateBoundaryProduct: UpdateBoundaryProduct): Promise<BoundaryProduct>;

  /**
   * Updates a scf control for a boundary
   * @summary Updates a scf control for a boundary
   * @param {UUID} boundaryId 
   * @param {UUID} boundaryScfControlId 
   * @param {UpdateBoundaryScfControl} updateBoundaryScfControl 
   * @param {*} [options] Override http request option.
   * @throws {@link @zerobias-org/types-core-js#ParameterRequiredError} if any required parameter is not provided
   * @example
   * ```typescript
   * const result = await api.updateBoundaryScfControl('00000000-0000-0000-0000-000000000000', '00000000-0000-0000-0000-000000000000', null);
   * ```
   * @openapi operation=updateBoundaryScfControl path=/boundaries/{boundaryId}/scfControls/{boundaryScfControlId} method=PUT
   * @memberof BoundaryApi
   */
  updateBoundaryScfControl(boundaryId: UUID, boundaryScfControlId: UUID, updateBoundaryScfControl: UpdateBoundaryScfControl): Promise<ExtendedBoundaryScfControl>;

  /**
   * Updates a boundary team
   * @summary Updates a boundary team
   * @param {UUID} boundaryId 
   * @param {UUID} teamId 
   * @param {UpdateBoundaryTeam} updateBoundaryTeam 
   * @param {*} [options] Override http request option.
   * @throws {@link @zerobias-org/types-core-js#ParameterRequiredError} if any required parameter is not provided
   * @example
   * ```typescript
   * const result = await api.updateBoundaryTeam('00000000-0000-0000-0000-000000000000', '00000000-0000-0000-0000-000000000000', null);
   * ```
   * @openapi operation=updateBoundaryTeam path=/boundaries/{boundaryId}/teams/{teamId} method=PUT
   * @memberof BoundaryApi
   */
  updateBoundaryTeam(boundaryId: UUID, teamId: UUID, updateBoundaryTeam: UpdateBoundaryTeam): Promise<BoundaryTeam>;

  /**
   * Updates a boundary team scf control question
   * @summary Updates a boundary team scf control question
   * @param {UUID} boundaryId 
   * @param {UUID} teamId 
   * @param {UUID} scfControlId 
   * @param {UpdateBoundaryTeamScfControl} updateBoundaryTeamScfControl 
   * @param {*} [options] Override http request option.
   * @throws {@link @zerobias-org/types-core-js#ParameterRequiredError} if any required parameter is not provided
   * @example
   * ```typescript
   * const result = await api.updateBoundaryTeamScfControl('00000000-0000-0000-0000-000000000000', '00000000-0000-0000-0000-000000000000', '00000000-0000-0000-0000-000000000000', null);
   * ```
   * @openapi operation=updateBoundaryTeamScfControl path=/boundaries/{boundaryId}/teams/{teamId}/scfControlTree/{scfControlId} method=PUT
   * @memberof BoundaryApi
   */
  updateBoundaryTeamScfControl(boundaryId: UUID, teamId: UUID, scfControlId: UUID, updateBoundaryTeamScfControl: UpdateBoundaryTeamScfControl): Promise<BoundaryTeamScfControl>;

  /**
   * Updates a boundary team scf control evidence definition implementation
   * @summary Updates a boundary team scf control evidence definition implementation
   * @param {UUID} boundaryId 
   * @param {UUID} teamId 
   * @param {UUID} scfControlId 
   * @param {UUID} evidenceDefinitionId 
   * @param {UpdateBoundaryTeamScfControlEvidenceDefinition} updateBoundaryTeamScfControlEvidenceDefinition 
   * @param {*} [options] Override http request option.
   * @throws {@link @zerobias-org/types-core-js#ParameterRequiredError} if any required parameter is not provided
   * @example
   * ```typescript
   * const result = await api.updateBoundaryTeamScfControlEvidenceDefinition('00000000-0000-0000-0000-000000000000', '00000000-0000-0000-0000-000000000000', '00000000-0000-0000-0000-000000000000', '00000000-0000-0000-0000-000000000000', null);
   * ```
   * @openapi operation=updateBoundaryTeamScfControlEvidenceDefinition path=/boundaries/{boundaryId}/teams/{teamId}/scfControlTree/{scfControlId}/evidenceDefinitions/{evidenceDefinitionId} method=PUT
   * @memberof BoundaryApi
   */
  updateBoundaryTeamScfControlEvidenceDefinition(boundaryId: UUID, teamId: UUID, scfControlId: UUID, evidenceDefinitionId: UUID, updateBoundaryTeamScfControlEvidenceDefinition: UpdateBoundaryTeamScfControlEvidenceDefinition): Promise<BoundaryTeamScfControlEvidenceDefinitionImplementation>;

  /**
   * Creates or Updates an alert bot for a query, query version, and boundary
   * @summary Creates or Updates an alert bot for a query, query version, and boundary
   * @param {UUID} boundaryId 
   * @param {NewBoundaryAlertBot} newBoundaryAlertBot 
   * @param {boolean} [executeAndVerifyQuery] 
   * @param {*} [options] Override http request option.
   * @throws {@link @zerobias-org/types-core-js#ParameterRequiredError} if any required parameter is not provided
   * @example
   * ```typescript
   * const result = await api.upsertAlertBot('00000000-0000-0000-0000-000000000000', null, true);
   * ```
   * @openapi operation=upsertBoundaryAlertBot path=/app/boundaries/{boundaryId}/alertBots method=PUT
   * @memberof BoundaryApi
   */
  upsertAlertBot(boundaryId: UUID, newBoundaryAlertBot: NewBoundaryAlertBot, executeAndVerifyQuery?: boolean): Promise<BoundaryAlertBotExtended>;

  /**
   * Updates a boundary product targets
   * @summary Updates a boundary product targets
   * @param {UUID} boundaryId 
   * @param {UUID} boundaryProductId 
   * @param {NewBoundaryProductTarget} newBoundaryProductTarget 
   * @param {*} [options] Override http request option.
   * @throws {@link @zerobias-org/types-core-js#ParameterRequiredError} if any required parameter is not provided
   * @example
   * ```typescript
   * const result = await api.upsertBoundaryProductTargets('00000000-0000-0000-0000-000000000000', '00000000-0000-0000-0000-000000000000', null);
   * ```
   * @openapi operation=upsertBoundaryProductTargets path=/boundaries/{boundaryId}/products/{boundaryProductId}/targets method=PUT
   * @memberof BoundaryApi
   */
  upsertBoundaryProductTargets(boundaryId: UUID, boundaryProductId: UUID, newBoundaryProductTarget: NewBoundaryProductTarget): Promise<Array<BoundaryProductTarget>>;

  /**
   * Updates a boundarys products
   * @summary Updates a boundarys products
   * @param {UUID} boundaryId 
   * @param {UpsertBoundaryProducts} upsertBoundaryProducts 
   * @param {*} [options] Override http request option.
   * @throws {@link @zerobias-org/types-core-js#ParameterRequiredError} if any required parameter is not provided
   * @example
   * ```typescript
   * const result = await api.upsertBoundaryProducts('00000000-0000-0000-0000-000000000000', null);
   * ```
   * @openapi operation=upsertBoundaryProducts path=/boundaries/{boundaryId}/products method=PUT
   * @memberof BoundaryApi
   */
  upsertBoundaryProducts(boundaryId: UUID, upsertBoundaryProducts: UpsertBoundaryProducts): Promise<Array<BoundaryProduct>>;

}

/**
 * BoundaryProducerApi - interface
 * Producer interface for Boundary
 * @export
 * @interface BoundaryProducerApi
 */
export interface BoundaryProducerApi {
  /**
  * Add crosswalk versions to boundary
  * @summary Add crosswalk versions to boundary
  * @param {UUID} boundaryId 
  * @param {NewBoundaryCrosswalkVersion} newBoundaryCrosswalkVersion 
  * @param {*} [options] Override http request option.
  * @throws {@link @zerobias-org/types-core-js#ParameterRequiredError} if any required parameter is not provided
  * @openapi operation=addBoundaryCrosswalkVersion path=/app/boundaries/{boundaryId}/crosswalkVersions method=POST
  * @memberof Boundary
  */
  addCrosswalkVersion(boundaryId: UUID, newBoundaryCrosswalkVersion: NewBoundaryCrosswalkVersion): Promise<BoundaryCrosswalkVersionExtended>;
  /**
  * Add standard baseline to boundary
  * @summary Add standard baseline to boundary
  * @param {UUID} boundaryId 
  * @param {NewBoundaryStandardBaseline} newBoundaryStandardBaseline 
  * @param {*} [options] Override http request option.
  * @throws {@link @zerobias-org/types-core-js#ParameterRequiredError} if any required parameter is not provided
  * @openapi operation=addBoundaryStandardBaseline path=/app/boundaries/{boundaryId}/standardBaselines method=POST
  * @memberof Boundary
  */
  addStandardBaseline(boundaryId: UUID, newBoundaryStandardBaseline: NewBoundaryStandardBaseline): Promise<BoundaryStandardBaselineExtended>;
  /**
  * Choose elements that are in scope for boundary standard baseline
  * @summary Choose elements that are in scope for boundary standard baseline
  * @param {UUID} boundaryId 
  * @param {UUID} boundaryStandardBaselineId 
  * @param {NewBoundaryStandardBaselineElements} newBoundaryStandardBaselineElements 
  * @param {*} [options] Override http request option.
  * @throws {@link @zerobias-org/types-core-js#ParameterRequiredError} if any required parameter is not provided
  * @openapi operation=addBoundaryStandardBaselineElements path=/app/boundaries/{boundaryId}/standardBaselines/{boundaryStandardBaselineId}/elements method=POST
  * @memberof Boundary
  */
  addStandardBaselineElements(boundaryId: UUID, boundaryStandardBaselineId: UUID, newBoundaryStandardBaselineElements: NewBoundaryStandardBaselineElements): Promise<Array<ElementExtended>>;
  /**
  * Removes a subscription from a boundary alert bot
  * @summary Removes a subscription from a boundary alert bot
  * @param {UUID} boundaryId 
  * @param {UUID} boundaryAlertBotId 
  * @param {UUID} subscriptionId 
  * @param {*} [options] Override http request option.
  * @throws {@link @zerobias-org/types-core-js#ParameterRequiredError} if any required parameter is not provided
  * @openapi operation=boundaryAlertBotDeleteSubscription path=/app/boundaries/{boundaryId}/alertBots/{boundaryAlertBotId}/subscriptions/{subscriptionId} method=DELETE
  * @memberof Boundary
  */
  deleteSubscription(boundaryId: UUID, boundaryAlertBotId: UUID, subscriptionId: UUID): Promise<void>;
  /**
  * Adds a subscription to a boundary alert bot
  * @summary Adds a subscription to a boundary alert bot
  * @param {UUID} boundaryId 
  * @param {UUID} boundaryAlertBotId 
  * @param {NewAlertSubscription} newAlertSubscription 
  * @param {*} [options] Override http request option.
  * @throws {@link @zerobias-org/types-core-js#ParameterRequiredError} if any required parameter is not provided
  * @openapi operation=boundaryAlertBotSubscribeToAlerts path=/app/boundaries/{boundaryId}/alertBots/{boundaryAlertBotId}/subscriptions method=POST
  * @memberof Boundary
  */
  addSubscription(boundaryId: UUID, boundaryAlertBotId: UUID, newAlertSubscription: NewAlertSubscription): Promise<AlertSubscriptionExtended>;
  /**
  * Executes a query within the given boundary. (not implemented)
  * @summary Executes a query within the given boundary. (not implemented)
  * @param {UUID} boundaryId 
  * @param {UUID} queryId the queryId or queryVersionId to execute. If given a queryId the latest version of that query will be executed
  * @param {ExecuteGraphqlQuery} executeGraphqlQuery 
  * @param {*} [options] Override http request option.
  * @throws {@link @zerobias-org/types-core-js#ParameterRequiredError} if any required parameter is not provided
  * @openapi operation=boundaryExecuteQuery path=/app/boundaries/{boundaryId}/queries/{queryId} method=PUT
  * @memberof Boundary
  */
  boundaryExecuteQuery(boundaryId: UUID, queryId: UUID, executeGraphqlQuery: ExecuteGraphqlQuery): Promise<ExecuteGraphqlQueryResult>;
  /**
  * Searches for filters, queries, and keywords within boundary for given keyword
  * @summary Searches for filters, queries, and keywords within boundary for given keyword
  * @param {UUID} boundaryId 
  * @param {BoundaryKeywordSearchBody} boundaryKeywordSearchBody Filters to apply to the search.
  * @param {*} [options] Override http request option.
  * @throws {@link @zerobias-org/types-core-js#ParameterRequiredError} if any required parameter is not provided
  * @openapi operation=boundaryKeywordSearch path=/boundaries/{boundaryId}/keywordSearch method=POST
  * @memberof Boundary
  */
  boundaryKeywordSearch(boundaryId: UUID, boundaryKeywordSearchBody: BoundaryKeywordSearchBody): Promise<BoundaryKeywordSearchResult>;
  /**
  * Searches for keywords within boundary for given class and keyword
  * @summary Searches for keywords within boundary for given class and keyword
  * @param {UUID} boundaryId 
  * @param {UUID} classId 
  * @param {BoundaryKeywordSearchBody} boundaryKeywordSearchBody Filters to apply to the search.
  * @param {*} [options] Override http request option.
  * @throws {@link @zerobias-org/types-core-js#ParameterRequiredError} if any required parameter is not provided
  * @openapi operation=boundaryKeywordSearchForClass path=/boundaries/{boundaryId}/keywordSearch/{classId} method=POST
  * @memberof Boundary
  */
  boundaryKeywordSearchForClass(boundaryId: UUID, classId: UUID, boundaryKeywordSearchBody: BoundaryKeywordSearchBody): Promise<BoundaryKeywordSearchForClassResult>;
  /**
  * Retrieves object counts for class given in filter
  * @summary Retrieves object counts for class given in filter
  * @param {UUID} boundaryId 
  * @param {BoundaryObjectCountFilter} boundaryObjectCountFilter 
  * @param {*} [options] Override http request option.
  * @throws {@link @zerobias-org/types-core-js#ParameterRequiredError} if any required parameter is not provided
  * @openapi operation=boundaryObjectCount path=/boundaries/{boundaryId}/objectCount method=POST
  * @memberof Boundary
  */
  boundaryObjectCount(boundaryId: UUID, boundaryObjectCountFilter: BoundaryObjectCountFilter): Promise<BoundaryObjectCountResult>;
  /**
  * Search through objects within a boundary
  * @summary Search through objects within a boundary
  * @param {UUID} boundaryId 
  * @param {BoundaryObjectSearchFilter} boundaryObjectSearchFilter Filters to apply to the search.
  * @param {*} [options] Override http request option.
  * @throws {@link @zerobias-org/types-core-js#ParameterRequiredError} if any required parameter is not provided
  * @openapi operation=boundaryObjectSearch path=/boundaries/{boundaryId}/objectSearch method=POST
  * @memberof Boundary
  */
  boundaryObjectSearch(results: PagedResults<BoundarySearchResult>, boundaryId: UUID, boundaryObjectSearchFilter: BoundaryObjectSearchFilter): Promise<void>;
  /**
  * Search through objects within a boundary and returns metadata about results that would be returned by objectSearch
  * @summary Search through objects within a boundary and returns metadata about results that would be returned by objectSearch
  * @param {UUID} boundaryId 
  * @param {BoundaryObjectSearchFilter} boundaryObjectSearchFilter Filters to apply to the search.
  * @param {*} [options] Override http request option.
  * @throws {@link @zerobias-org/types-core-js#ParameterRequiredError} if any required parameter is not provided
  * @openapi operation=boundaryObjectSearchMetadata path=/boundaries/{boundaryId}/objectSearchMetadata method=POST
  * @memberof Boundary
  */
  boundaryObjectSearchMetadata(boundaryId: UUID, boundaryObjectSearchFilter: BoundaryObjectSearchFilter): Promise<BoundaryObjectSearchResultsMetadata>;
  /**
  * Search accross objects, resources and tags within a boundary
  * @summary Search accross objects, resources and tags within a boundary
  * @param {UUID} boundaryId 
  * @param {BoundarySearchFilter} boundarySearchFilter Filters to apply to the search.
  * @param {*} [options] Override http request option.
  * @throws {@link @zerobias-org/types-core-js#ParameterRequiredError} if any required parameter is not provided
  * @openapi operation=boundarySearch path=/boundaries/{boundaryId}/search method=POST
  * @memberof Boundary
  */
  boundarySearch(results: PagedResults<BoundarySearchResult>, boundaryId: UUID, boundarySearchFilter: BoundarySearchFilter): Promise<void>;
  /**
  * Create a new boundary
  * @summary Create a new boundary
  * @param {NewBoundary} newBoundary 
  * @param {*} [options] Override http request option.
  * @throws {@link @zerobias-org/types-core-js#ParameterRequiredError} if any required parameter is not provided
  * @openapi operation=createBoundary path=/boundaries method=POST
  * @memberof Boundary
  */
  createBoundary(newBoundary: NewBoundary): Promise<Boundary>;
  /**
  * Create a new boundary Event
  * @summary Create a new boundary Event
  * @param {UUID} boundaryId 
  * @param {NewBoundaryEvent} newBoundaryEvent 
  * @param {*} [options] Override http request option.
  * @throws {@link @zerobias-org/types-core-js#ParameterRequiredError} if any required parameter is not provided
  * @openapi operation=createBoundaryEvent path=/boundaries/{boundaryId}/events method=POST
  * @memberof Boundary
  */
  createBoundaryEvent(boundaryId: UUID, newBoundaryEvent: NewBoundaryEvent): Promise<BoundaryEvent>;
  /**
  * Create a new boundary Event
  * @summary Create a new boundary Event
  * @param {UUID} boundaryId 
  * @param {*} [options] Override http request option.
  * @throws {@link @zerobias-org/types-core-js#ParameterRequiredError} if any required parameter is not provided
  * @openapi operation=createBoundaryEvidence path=/boundaries/{boundaryId}/evidence method=POST
  * @memberof Boundary
  */
  createBoundaryEvidence(boundaryId: UUID): Promise<CreateBoundaryEvidenceCounts>;
  /**
  * Create a new boundary party
  * @summary Create a new boundary party
  * @param {UUID} boundaryId 
  * @param {NewBoundaryParty} newBoundaryParty 
  * @param {*} [options] Override http request option.
  * @throws {@link @zerobias-org/types-core-js#ParameterRequiredError} if any required parameter is not provided
  * @openapi operation=createBoundaryParty path=/boundaries/{boundaryId}/parties method=POST
  * @memberof Boundary
  */
  createBoundaryParty(boundaryId: UUID, newBoundaryParty: NewBoundaryParty): Promise<PartyExtended>;
  /**
  * Create new boundary party role
  * @summary Create new boundary party role
  * @param {UUID} boundaryId 
  * @param {NewBoundaryPartyRole} newBoundaryPartyRole 
  * @param {*} [options] Override http request option.
  * @throws {@link @zerobias-org/types-core-js#ParameterRequiredError} if any required parameter is not provided
  * @openapi operation=createBoundaryPartyRole path=/app/boundaries/{boundaryId}/partyRoles method=POST
  * @memberof Boundary
  */
  createBoundaryPartyRole(boundaryId: UUID, newBoundaryPartyRole: NewBoundaryPartyRole): Promise<BoundaryPartyRoleExtended>;
  /**
  * Create a new boundary product
  * @summary Create a new boundary product
  * @param {UUID} boundaryId 
  * @param {NewBoundaryProduct} newBoundaryProduct 
  * @param {*} [options] Override http request option.
  * @throws {@link @zerobias-org/types-core-js#ParameterRequiredError} if any required parameter is not provided
  * @openapi operation=createBoundaryProduct path=/boundaries/{boundaryId}/products method=POST
  * @memberof Boundary
  */
  createBoundaryProduct(boundaryId: UUID, newBoundaryProduct: NewBoundaryProduct): Promise<BoundaryProductProcessedResponse>;
  /**
  * Create a new boundary product target
  * @summary Create a new boundary product target
  * @param {UUID} boundaryId 
  * @param {UUID} boundaryProductId 
  * @param {NewBoundaryProductTarget} newBoundaryProductTarget 
  * @param {*} [options] Override http request option.
  * @throws {@link @zerobias-org/types-core-js#ParameterRequiredError} if any required parameter is not provided
  * @openapi operation=createBoundaryProductTarget path=/boundaries/{boundaryId}/products/{boundaryProductId}/targets method=POST
  * @memberof Boundary
  */
  createBoundaryProductTarget(boundaryId: UUID, boundaryProductId: UUID, newBoundaryProductTarget: NewBoundaryProductTarget): Promise<BoundaryProductTargetProcessedResponse>;
  /**
  * Create a new boundary team
  * @summary Create a new boundary team
  * @param {UUID} boundaryId 
  * @param {NewBoundaryTeam} newBoundaryTeam 
  * @param {*} [options] Override http request option.
  * @throws {@link @zerobias-org/types-core-js#ParameterRequiredError} if any required parameter is not provided
  * @openapi operation=createBoundaryTeam path=/boundaries/{boundaryId}/teams method=POST
  * @memberof Boundary
  */
  createBoundaryTeam(boundaryId: UUID, newBoundaryTeam: NewBoundaryTeam): Promise<BoundaryTeam>;
  /**
  * Create a new suggested product
  * @summary Create a new suggested product
  * @param {UUID} boundaryId 
  * @param {NewSuggestedProduct} newSuggestedProduct 
  * @param {*} [options] Override http request option.
  * @throws {@link @zerobias-org/types-core-js#ParameterRequiredError} if any required parameter is not provided
  * @openapi operation=createSuggestedProduct path=/boundaries/{boundaryId}/suggestedProducts method=POST
  * @memberof Boundary
  */
  createSuggestedProduct(boundaryId: UUID, newSuggestedProduct: NewSuggestedProduct): Promise<SuggestedProduct>;
  /**
  * Deletes a boundary
  * @summary Deletes a boundary
  * @param {UUID} boundaryId 
  * @param {*} [options] Override http request option.
  * @throws {@link @zerobias-org/types-core-js#ParameterRequiredError} if any required parameter is not provided
  * @openapi operation=deleteBoundary path=/boundaries/{boundaryId} method=DELETE
  * @memberof Boundary
  */
  deleteBoundary(boundaryId: UUID): Promise<void>;
  /**
  * Deletes a boundary query alert bot
  * @summary Deletes a boundary query alert bot
  * @param {UUID} boundaryId 
  * @param {UUID} boundaryAlertBotId 
  * @param {*} [options] Override http request option.
  * @throws {@link @zerobias-org/types-core-js#ParameterRequiredError} if any required parameter is not provided
  * @openapi operation=deleteBoundaryAlertBot path=/app/boundaries/{boundaryId}/alertBots/{boundaryAlertBotId} method=DELETE
  * @memberof Boundary
  */
  deleteAlertBot(boundaryId: UUID, boundaryAlertBotId: UUID): Promise<void>;
  /**
  * Delete boundary party role
  * @summary Delete boundary party role
  * @param {UUID} boundaryId 
  * @param {UUID} roleId 
  * @param {UUID} partyId 
  * @param {*} [options] Override http request option.
  * @throws {@link @zerobias-org/types-core-js#ParameterRequiredError} if any required parameter is not provided
  * @openapi operation=deleteBoundaryPartyRole path=/app/boundaries/{boundaryId}/parties/{partyId}/roles/{roleId} method=DELETE
  * @memberof Boundary
  */
  deleteBoundaryPartyRole(boundaryId: UUID, roleId: UUID, partyId: UUID): Promise<void>;
  /**
  * Delete boundary party roles by boundary id
  * @summary Delete boundary party roles by boundary id
  * @param {UUID} boundaryId 
  * @param {*} [options] Override http request option.
  * @throws {@link @zerobias-org/types-core-js#ParameterRequiredError} if any required parameter is not provided
  * @openapi operation=deleteBoundaryPartyRoles path=/app/boundaries/{boundaryId}/partyRoles method=DELETE
  * @memberof Boundary
  */
  deleteBoundaryPartyRoles(boundaryId: UUID): Promise<void>;
  /**
  * Deletes target for a boundary product
  * @summary Deletes target for a boundary product
  * @param {UUID} boundaryId 
  * @param {UUID} boundaryProductId 
  * @param {DeleteBoundaryProductTarget} deleteBoundaryProductTarget 
  * @param {*} [options] Override http request option.
  * @throws {@link @zerobias-org/types-core-js#ParameterRequiredError} if any required parameter is not provided
  * @openapi operation=deleteBoundaryProductTargets path=/boundaries/{boundaryId}/products/{boundaryProductId}/targets method=DELETE
  * @memberof Boundary
  */
  deleteBoundaryProductTargets(boundaryId: UUID, boundaryProductId: UUID, deleteBoundaryProductTarget: DeleteBoundaryProductTarget): Promise<BoundaryProductTargetProcessedResponse>;
  /**
  * Deletes products for a boundary
  * @summary Deletes products for a boundary
  * @param {UUID} boundaryId 
  * @param {DeleteBoundaryProduct} deleteBoundaryProduct 
  * @param {*} [options] Override http request option.
  * @throws {@link @zerobias-org/types-core-js#ParameterRequiredError} if any required parameter is not provided
  * @openapi operation=deleteBoundaryProducts path=/boundaries/{boundaryId}/products method=DELETE
  * @memberof Boundary
  */
  deleteBoundaryProducts(boundaryId: UUID, deleteBoundaryProduct: DeleteBoundaryProduct): Promise<BoundaryProductProcessedResponse>;
  /**
  * Deletes a boundary team
  * @summary Deletes a boundary team
  * @param {UUID} boundaryId 
  * @param {UUID} teamId 
  * @param {*} [options] Override http request option.
  * @throws {@link @zerobias-org/types-core-js#ParameterRequiredError} if any required parameter is not provided
  * @openapi operation=deleteBoundaryTeam path=/boundaries/{boundaryId}/teams/{teamId} method=DELETE
  * @memberof Boundary
  */
  deleteBoundaryTeam(boundaryId: UUID, teamId: UUID): Promise<void>;
  /**
  * Deletes events for a boundary
  * @summary Deletes events for a boundary
  * @param {UUID} boundaryId 
  * @param {*} [options] Override http request option.
  * @throws {@link @zerobias-org/types-core-js#ParameterRequiredError} if any required parameter is not provided
  * @openapi operation=deleteEventsForBoundary path=/boundaries/{boundaryId}/events method=DELETE
  * @memberof Boundary
  */
  deleteEventsForBoundary(boundaryId: UUID): Promise<void>;
  /**
  * Disables a boundary team scf control evidence definition implementation
  * @summary Disables a boundary team scf control evidence definition implementation
  * @param {UUID} boundaryId 
  * @param {UUID} teamId 
  * @param {UUID} scfControlId 
  * @param {UUID} evidenceDefinitionId 
  * @param {*} [options] Override http request option.
  * @throws {@link @zerobias-org/types-core-js#ParameterRequiredError} if any required parameter is not provided
  * @openapi operation=disableBoundaryTeamScfControlEvidenceDefinition path=/boundaries/{boundaryId}/teams/{teamId}/scfControlTree/{scfControlId}/evidenceDefinitions/{evidenceDefinitionId} method=DELETE
  * @memberof Boundary
  */
  disableBoundaryTeamScfControlEvidenceDefinition(boundaryId: UUID, teamId: UUID, scfControlId: UUID, evidenceDefinitionId: UUID): Promise<void>;
  /**
  * Enables a boundary team scf control evidence definition implementation
  * @summary Enables a boundary team scf control evidence definition implementation
  * @param {UUID} boundaryId 
  * @param {UUID} teamId 
  * @param {UUID} scfControlId 
  * @param {EnableBoundaryTeamScfControlEvidenceDefinition} enableBoundaryTeamScfControlEvidenceDefinition 
  * @param {*} [options] Override http request option.
  * @throws {@link @zerobias-org/types-core-js#ParameterRequiredError} if any required parameter is not provided
  * @openapi operation=enableBoundaryTeamScfControlEvidenceDefinition path=/boundaries/{boundaryId}/teams/{teamId}/scfControlTree/{scfControlId}/evidenceDefinitions method=POST
  * @memberof Boundary
  */
  enableBoundaryTeamScfControlEvidenceDefinition(boundaryId: UUID, teamId: UUID, scfControlId: UUID, enableBoundaryTeamScfControlEvidenceDefinition: EnableBoundaryTeamScfControlEvidenceDefinition): Promise<BoundaryTeamScfControlEvidenceDefinitionImplementation>;
  /**
  * Retrieves a boundary product
  * @summary Retrieves a boundary product
  * @param {UUID} boundaryId 
  * @param {UUID} boundaryProductId 
  * @param {*} [options] Override http request option.
  * @throws {@link @zerobias-org/types-core-js#ParameterRequiredError} if any required parameter is not provided
  * @openapi operation=getAnyBoundaryProduct path=/boundaries/{boundaryId}/allProducts/{boundaryProductId} method=GET
  * @memberof Boundary
  */
  getAnyBoundaryProduct(boundaryId: UUID, boundaryProductId: UUID): Promise<BoundaryProductAny>;
  /**
  * Retrieves a boundary
  * @summary Retrieves a boundary
  * @param {UUID} boundaryId 
  * @param {*} [options] Override http request option.
  * @throws {@link @zerobias-org/types-core-js#ParameterRequiredError} if any required parameter is not provided
  * @openapi operation=getBoundary path=/boundaries/{boundaryId} method=GET
  * @memberof Boundary
  */
  getBoundary(boundaryId: UUID): Promise<BoundaryExtended>;
  /**
  * 
  * @summary Retrieves extended information about a boundary alert
  * @param {UUID} boundaryId The ID of the boundary
  * @param {UUID} id The ID of the alert to fetch
  * @param {*} [options] Override http request option.
  * @throws {@link @zerobias-org/types-core-js#ParameterRequiredError} if any required parameter is not provided
  * @openapi operation=getBoundaryAlert path=/app/boundaries/{boundaryId}/alerts/{id} method=GET
  * @memberof Boundary
  */
  getBoundaryAlert(boundaryId: UUID, id: UUID): Promise<BoundaryAlertExtended>;
  /**
  * Get boundary component
  * @summary Get boundary component
  * @param {UUID} boundaryId 
  * @param {UUID} componentId 
  * @param {*} [options] Override http request option.
  * @throws {@link @zerobias-org/types-core-js#ParameterRequiredError} if any required parameter is not provided
  * @openapi operation=getBoundaryComponent path=/app/boundaries/{boundaryId}/components/{componentId} method=GET
  * @memberof Boundary
  */
  getBoundaryComponent(boundaryId: UUID, componentId: UUID): Promise<BoundaryComponentExtended>;
  /**
  * Retrieves a boundary product
  * @summary Retrieves a boundary product
  * @param {UUID} boundaryId 
  * @param {UUID} connectionId 
  * @param {*} [options] Override http request option.
  * @throws {@link @zerobias-org/types-core-js#ParameterRequiredError} if any required parameter is not provided
  * @openapi operation=getBoundaryConnectionOverview path=/boundaries/{boundaryId}/connections/{connectionId} method=GET
  * @memberof Boundary
  */
  getBoundaryConnectionOverview(boundaryId: UUID, connectionId: UUID): Promise<BoundaryConnectionOverview>;
  /**
  * Retrieves domains summary info for a boundary
  * @summary Retrieves domains summary info for a boundary
  * @param {UUID} boundaryId 
  * @param {UUID} [sourceId] 
  * @param {*} [options] Override http request option.
  * @throws {@link @zerobias-org/types-core-js#ParameterRequiredError} if any required parameter is not provided
  * @openapi operation=getBoundaryDomainSummary path=/boundaries/{boundaryId}/domains method=GET
  * @memberof Boundary
  */
  getBoundaryDomainSummary(boundaryId: UUID, sourceId?: UUID): Promise<BoundaryDomainSummary>;
  /**
  * Retrieves a boundary evidence record
  * @summary Retrieves a boundary evidence record
  * @param {UUID} boundaryId 
  * @param {UUID} evidenceId 
  * @param {*} [options] Override http request option.
  * @throws {@link @zerobias-org/types-core-js#ParameterRequiredError} if any required parameter is not provided
  * @openapi operation=getBoundaryEvidence path=/boundaries/{boundaryId}/evidence/{evidenceId} method=GET
  * @memberof Boundary
  */
  getBoundaryEvidence(boundaryId: UUID, evidenceId: UUID): Promise<BoundaryEvidence & ExtendedBoundaryEvidence>;
  /**
  * Retrieves metrics of the data for a specific boundary
  * @summary Retrieves metrics of the data for a specific boundary
  * @param {UUID} boundaryId 
  * @param {*} [options] Override http request option.
  * @throws {@link @zerobias-org/types-core-js#ParameterRequiredError} if any required parameter is not provided
  * @openapi operation=getBoundaryMetrics path=/boundaries/{boundaryId}/metrics method=GET
  * @memberof Boundary
  */
  getBoundaryMetrics(boundaryId: UUID): Promise<BoundaryMetric>;
  /**
  * Retrieves a party for a boundary
  * @summary Retrieves a party for a boundary
  * @param {UUID} boundaryId 
  * @param {UUID} partyId 
  * @param {*} [options] Override http request option.
  * @throws {@link @zerobias-org/types-core-js#ParameterRequiredError} if any required parameter is not provided
  * @openapi operation=getBoundaryParty path=/boundaries/{boundaryId}/parties/{partyId} method=GET
  * @memberof Boundary
  */
  getBoundaryParty(boundaryId: UUID, partyId: UUID): Promise<PartyExtended>;
  /**
  * Get boundary party role
  * @summary Get boundary party role
  * @param {UUID} boundaryId 
  * @param {UUID} roleId 
  * @param {UUID} partyId 
  * @param {*} [options] Override http request option.
  * @throws {@link @zerobias-org/types-core-js#ParameterRequiredError} if any required parameter is not provided
  * @openapi operation=getBoundaryPartyRole path=/app/boundaries/{boundaryId}/parties/{partyId}/roles/{roleId} method=GET
  * @memberof Boundary
  */
  getBoundaryPartyRole(boundaryId: UUID, roleId: UUID, partyId: UUID): Promise<BoundaryPartyRoleExtended>;
  /**
  * Retrieves a boundary product
  * @summary Retrieves a boundary product
  * @param {UUID} boundaryId 
  * @param {UUID} boundaryProductId 
  * @param {*} [options] Override http request option.
  * @throws {@link @zerobias-org/types-core-js#ParameterRequiredError} if any required parameter is not provided
  * @openapi operation=getBoundaryProduct path=/boundaries/{boundaryId}/products/{boundaryProductId} method=GET
  * @memberof Boundary
  */
  getBoundaryProduct(boundaryId: UUID, boundaryProductId: UUID): Promise<BoundaryProduct & ExtendedBoundaryProduct>;
  /**
  * Retrieves a boundary product
  * @summary Retrieves a boundary product
  * @param {UUID} boundaryId 
  * @param {UUID} boundaryProductId 
  * @param {UUID} connectionId 
  * @param {*} [options] Override http request option.
  * @throws {@link @zerobias-org/types-core-js#ParameterRequiredError} if any required parameter is not provided
  * @openapi operation=getBoundaryProductConnectionOverview path=/boundaries/{boundaryId}/products/{boundaryProductId}/connections/{connectionId} method=GET
  * @memberof Boundary
  */
  getBoundaryProductConnectionOverview(boundaryId: UUID, boundaryProductId: UUID, connectionId: UUID): Promise<BoundaryConnectionOverview>;
  /**
  * Retrieves a boundary product overview
  * @summary Retrieves a boundary product overview
  * @param {UUID} boundaryId 
  * @param {UUID} boundaryProductId 
  * @param {*} [options] Override http request option.
  * @throws {@link @zerobias-org/types-core-js#ParameterRequiredError} if any required parameter is not provided
  * @openapi operation=getBoundaryProductOverview path=/boundaries/{boundaryId}/products/{boundaryProductId}/overviews method=GET
  * @memberof Boundary
  */
  getBoundaryProductOverview(boundaryId: UUID, boundaryProductId: UUID): Promise<BoundaryProductOverview>;
  /**
  * Retrieves a scf control for a boundary
  * @summary Retrieves a scf control for a boundary
  * @param {UUID} boundaryId 
  * @param {UUID} boundaryScfControlId 
  * @param {*} [options] Override http request option.
  * @throws {@link @zerobias-org/types-core-js#ParameterRequiredError} if any required parameter is not provided
  * @openapi operation=getBoundaryScfControl path=/boundaries/{boundaryId}/scfControls/{boundaryScfControlId} method=GET
  * @memberof Boundary
  */
  getBoundaryScfControl(boundaryId: UUID, boundaryScfControlId: UUID): Promise<ExtendedBoundaryScfControl>;
  /**
  * Get standard baseline that has been added to a boundary
  * @summary Get standard baseline that has been added to a boundary
  * @param {UUID} boundaryId 
  * @param {UUID} boundaryStandardBaselineId 
  * @param {*} [options] Override http request option.
  * @throws {@link @zerobias-org/types-core-js#ParameterRequiredError} if any required parameter is not provided
  * @openapi operation=getBoundaryStandardBaseline path=/app/boundaries/{boundaryId}/standardBaselines/{boundaryStandardBaselineId} method=GET
  * @memberof Boundary
  */
  getStandardBaseline(boundaryId: UUID, boundaryStandardBaselineId: UUID): Promise<BoundaryStandardBaselineExtended>;
  /**
  * Get element by standard and baseline and element id
  * @summary Get element by standard and baseline and element id
  * @param {UUID} boundaryId 
  * @param {UUID} boundaryStandardBaselineId 
  * @param {*} [options] Override http request option.
  * @throws {@link @zerobias-org/types-core-js#ParameterRequiredError} if any required parameter is not provided
  * @openapi operation=getBoundaryStandardBaselineFilterTree path=/app/boundaries/{boundaryId}/standardBaselines/{boundaryStandardBaselineId}/filterTree method=GET
  * @memberof Boundary
  */
  getStandardBaselineFilterTree(boundaryId: UUID, boundaryStandardBaselineId: UUID): Promise<{ [key: string]: StandardFilterTreeNode; }>;
  /**
  * Retrieves a boundary suggested product overview
  * @summary Retrieves a boundary suggested product overview
  * @param {UUID} boundaryId 
  * @param {UUID} boundarySuggestedProductId 
  * @param {*} [options] Override http request option.
  * @throws {@link @zerobias-org/types-core-js#ParameterRequiredError} if any required parameter is not provided
  * @openapi operation=getBoundarySuggestedProductOverview path=/boundaries/{boundaryId}/suggestedProducts/{boundarySuggestedProductId}/overviews method=GET
  * @memberof Boundary
  */
  getBoundarySuggestedProductOverview(boundaryId: UUID, boundarySuggestedProductId: UUID): Promise<BoundarySuggestedProductOverview>;
  /**
  * Retrieves task metrics for a specific boundary
  * @summary Retrieves task metrics for a specific boundary
  * @param {UUID} boundaryId 
  * @param {number} [pageNumber] The requested page. This value is 1-indexed.
  * @param {number} [pageSize] The number of items in each page of data.
  * @param {*} [options] Override http request option.
  * @throws {@link @zerobias-org/types-core-js#ParameterRequiredError} if any required parameter is not provided
  * @openapi operation=getBoundaryTaskMetrics path=/boundaries/{boundaryId}/taskMetrics method=GET
  * @memberof Boundary
  */
  getBoundaryTaskMetrics(boundaryId: UUID, pageNumber?: number, pageSize?: number): Promise<BoundaryTaskMetrics>;
  /**
  * Retrieves a team for a boundary
  * @summary Retrieves a team for a boundary
  * @param {UUID} boundaryId 
  * @param {UUID} teamId 
  * @param {*} [options] Override http request option.
  * @throws {@link @zerobias-org/types-core-js#ParameterRequiredError} if any required parameter is not provided
  * @openapi operation=getBoundaryTeam path=/boundaries/{boundaryId}/teams/{teamId} method=GET
  * @memberof Boundary
  */
  getBoundaryTeam(boundaryId: UUID, teamId: UUID): Promise<BoundaryTeam>;
  /**
  * Retrieves domains summary info for a boundary team
  * @summary Retrieves domains summary info for a boundary team
  * @param {UUID} boundaryId 
  * @param {UUID} teamId 
  * @param {UUID} [sourceId] 
  * @param {*} [options] Override http request option.
  * @throws {@link @zerobias-org/types-core-js#ParameterRequiredError} if any required parameter is not provided
  * @openapi operation=getBoundaryTeamDomainSummary path=/boundaries/{boundaryId}/teams/{teamId}/domains method=GET
  * @memberof Boundary
  */
  getBoundaryTeamDomainSummary(boundaryId: UUID, teamId: UUID, sourceId?: UUID): Promise<BoundaryTeamDomainSummary>;
  /**
  * Retrieves a teams metrics for a boundary
  * @summary Retrieves a teams metrics for a boundary
  * @param {UUID} boundaryId 
  * @param {UUID} teamId 
  * @param {*} [options] Override http request option.
  * @throws {@link @zerobias-org/types-core-js#ParameterRequiredError} if any required parameter is not provided
  * @openapi operation=getBoundaryTeamMetric path=/boundaries/{boundaryId}/teamMetrics/{teamId} method=GET
  * @memberof Boundary
  */
  getBoundaryTeamMetric(boundaryId: UUID, teamId: UUID): Promise<BoundaryTeamMetrics>;
  /**
  * Retrieves scf control data for a boundary team
  * @summary Retrieves scf control data for a boundary team
  * @param {UUID} boundaryId 
  * @param {UUID} teamId 
  * @param {UUID} scfControlId 
  * @param {*} [options] Override http request option.
  * @throws {@link @zerobias-org/types-core-js#ParameterRequiredError} if any required parameter is not provided
  * @openapi operation=getBoundaryTeamScfControl path=/boundaries/{boundaryId}/teams/{teamId}/scfControls/{scfControlId} method=GET
  * @memberof Boundary
  */
  getBoundaryTeamScfControl(boundaryId: UUID, teamId: UUID, scfControlId: UUID): Promise<BoundaryTeamScfControl>;
  /**
  * Retrieves a scf control defailts within a boundary team
  * @summary Retrieves a scf control defailts within a boundary team
  * @param {UUID} boundaryId 
  * @param {UUID} teamId 
  * @param {UUID} scfControlId 
  * @param {*} [options] Override http request option.
  * @throws {@link @zerobias-org/types-core-js#ParameterRequiredError} if any required parameter is not provided
  * @openapi operation=getBoundaryTeamScfControlDetails path=/boundaries/{boundaryId}/teams/{teamId}/scfControlTree/{scfControlId} method=GET
  * @memberof Boundary
  */
  getBoundaryTeamScfControlDetails(boundaryId: UUID, teamId: UUID, scfControlId: UUID): Promise<BoundaryTeamScfControlOverview>;
  /**
  * Retrieves a list of scf controls for a boundary in a tree form
  * @summary Retrieves a list of scf controls for a boundary in a tree form
  * @param {UUID} boundaryId 
  * @param {UUID} teamId 
  * @param {UUID} [frameworkVersionId] 
  * @param {*} [options] Override http request option.
  * @throws {@link @zerobias-org/types-core-js#ParameterRequiredError} if any required parameter is not provided
  * @openapi operation=getBoundaryTeamScfControlOverview path=/boundaries/{boundaryId}/teams/{teamId}/scfControlOverview method=GET
  * @memberof Boundary
  */
  getBoundaryTeamScfControlOverview(boundaryId: UUID, teamId: UUID, frameworkVersionId?: UUID): Promise<BoundaryFrameworkControlsOverview>;
  /**
  * Retrieves a list of scf controls for a boundary in a tree form
  * @summary Retrieves a list of scf controls for a boundary in a tree form
  * @param {UUID} boundaryId 
  * @param {UUID} teamId 
  * @param {UUID} [frameworkVersionId] 
  * @param {*} [options] Override http request option.
  * @throws {@link @zerobias-org/types-core-js#ParameterRequiredError} if any required parameter is not provided
  * @openapi operation=getBoundaryTeamScfControlTree path=/boundaries/{boundaryId}/teams/{teamId}/scfControlTree method=GET
  * @memberof Boundary
  */
  getBoundaryTeamScfControlTree(boundaryId: UUID, teamId: UUID, frameworkVersionId?: UUID): Promise<{ [key: string]: BoundaryFrameworkControlTreeNode; }>;
  /**
  * List test within a boundary by id
  * @summary List test within a boundary by id
  * @param {UUID} boundaryId 
  * @param {UUID} testId 
  * @param {*} [options] Override http request option.
  * @throws {@link @zerobias-org/types-core-js#ParameterRequiredError} if any required parameter is not provided
  * @openapi operation=getBoundaryTest path=/app/boundaries/{boundaryId}/tests/{testId} method=GET
  * @memberof Boundary
  */
  getTest(boundaryId: UUID, testId: UUID): Promise<TestExtended>;
  /**
  * Retrieves a list of all products for a boundary
  * @summary Retrieves a list of all products for a boundary
  * @param {UUID} boundaryId 
  * @param {string} [keywords] Search like filter
  * @param {BoundaryProductForListStatus} [status] Search like filter
  * @param {SortObject} [sort] Sort object
  * @param {*} [options] Override http request option.
  * @throws {@link @zerobias-org/types-core-js#ParameterRequiredError} if any required parameter is not provided
  * @openapi operation=listAllBoundaryProducts path=/boundaries/{boundaryId}/allProducts method=GET
  * @memberof Boundary
  */
  listAllBoundaryProducts(results: PagedResults<BoundaryProductForList>, boundaryId: UUID, keywords?: string, status?: BoundaryProductForListStatusDef, sort?: SortObject): Promise<void>;
  /**
  * Retrieves a list of all boundaries
  * @summary Retrieves a list of all boundaries
  * @param {string} [name] Filter by name
  * @param {BoundaryStatusEnum} [status] Filter by status
  * @param {BoundaryTypeEnum} [type] Filter by type
  * @param {SortObject} [sort] Sort object
  * @param {*} [options] Override http request option.
  * @throws {@link @zerobias-org/types-core-js#ParameterRequiredError} if any required parameter is not provided
  * @openapi operation=listBoundaries path=/boundaries method=GET
  * @memberof Boundary
  */
  listBoundaries(results: PagedResults<BoundaryExtended>, name?: string, status?: BoundaryStatusEnumDef, type?: BoundaryTypeEnumDef, sort?: SortObject): Promise<void>;
  /**
  * List alerts raised by this bot
  * @summary List alerts raised by this bot
  * @param {UUID} boundaryId 
  * @param {UUID} boundaryAlertBotId 
  * @param {SortObject} [sort] Sort object
  * @param {*} [options] Override http request option.
  * @throws {@link @zerobias-org/types-core-js#ParameterRequiredError} if any required parameter is not provided
  * @openapi operation=listBoundaryAlertBotAlerts path=/app/boundaries/{boundaryId}/alertBots/{boundaryAlertBotId}/alerts method=GET
  * @memberof Boundary
  */
  listAlertBotAlerts(results: PagedResults<BoundaryAlertView>, boundaryId: UUID, boundaryAlertBotId: UUID, sort?: SortObject): Promise<void>;
  /**
  * 
  * @summary Retrieves subjects that may be associated with a Boundary Alert
  * @param {UUID} boundaryId The ID of the boundary
  * @param {UUID} id The ID of the alert
  * @param {SortObject} [sort] Sort object
  * @param {*} [options] Override http request option.
  * @throws {@link @zerobias-org/types-core-js#ParameterRequiredError} if any required parameter is not provided
  * @openapi operation=listBoundaryAlertSubjects path=/app/boundaries/{boundaryId}/alerts/{id}/subjects method=GET
  * @memberof Boundary
  */
  listBoundaryAlertSubjects(results: PagedResults<BoundaryAlertSubjectExtended>, boundaryId: UUID, id: UUID, sort?: SortObject): Promise<void>;
  /**
  * List boundary alert bots subscriptions
  * @summary List boundary alert bots subscriptions
  * @param {UUID} boundaryAlertBotId 
  * @param {UUID} boundaryId 
  * @param {SortObject} [sort] Sort object
  * @param {*} [options] Override http request option.
  * @throws {@link @zerobias-org/types-core-js#ParameterRequiredError} if any required parameter is not provided
  * @openapi operation=listBoundaryAlertbotSubscriptions path=/app/boundaries/{boundaryId}/alertBots/{boundaryAlertBotId}/subscriptions method=GET
  * @memberof Boundary
  */
  listAlertBotSubscriptions(results: PagedResults<AlertSubscriptionExtended>, boundaryAlertBotId: UUID, boundaryId: UUID, sort?: SortObject): Promise<void>;
  /**
  * List boundary alert bots
  * @summary List boundary alert bots
  * @param {UUID} boundaryId 
  * @param {UUID} [queryId] 
  * @param {UUID} [queryVersionId] 
  * @param {SortObject} [sort] Sort object
  * @param {*} [options] Override http request option.
  * @throws {@link @zerobias-org/types-core-js#ParameterRequiredError} if any required parameter is not provided
  * @openapi operation=listBoundaryAlertbots path=/app/boundaries/{boundaryId}/alertBots method=GET
  * @memberof Boundary
  */
  listAlertBots(results: PagedResults<BoundaryAlertBotExtended>, boundaryId: UUID, queryId?: UUID, queryVersionId?: UUID, sort?: SortObject): Promise<void>;
  /**
  * List all alerts in a boundary
  * @summary List all alerts in a boundary
  * @param {UUID} boundaryId 
  * @param {SortObject} [sort] Sort object
  * @param {*} [options] Override http request option.
  * @throws {@link @zerobias-org/types-core-js#ParameterRequiredError} if any required parameter is not provided
  * @openapi operation=listBoundaryAlerts path=/app/boundaries/{boundaryId}/alerts method=GET
  * @memberof Boundary
  */
  listBoundaryAlerts(results: PagedResults<BoundaryAlertView>, boundaryId: UUID, sort?: SortObject): Promise<void>;
  /**
  * Retrieves audit metrics for a specific boundary
  * @summary Retrieves audit metrics for a specific boundary
  * @param {UUID} boundaryId 
  * @param {AuditStatusEnum} [status] Filter by status
  * @param {AuditTypeEnum} [type] Filter by type
  * @param {*} [options] Override http request option.
  * @throws {@link @zerobias-org/types-core-js#ParameterRequiredError} if any required parameter is not provided
  * @openapi operation=listBoundaryAuditMetrics path=/boundaries/{boundaryId}/auditMetrics method=GET
  * @memberof Boundary
  */
  listBoundaryAuditMetrics(results: PagedResults<BoundaryAuditMetrics>, boundaryId: UUID, status?: AuditStatusEnumDef, type?: AuditTypeEnumDef): Promise<void>;
  /**
  * Retrieves a list of audits for a boundary
  * @summary Retrieves a list of audits for a boundary
  * @param {UUID} boundaryId 
  * @param {AuditStatusEnum} [status] Filter by status
  * @param {AuditTypeEnum} [type] Filter by type
  * @param {boolean} [audited] Filter by audited flag
  * @param {*} [options] Override http request option.
  * @throws {@link @zerobias-org/types-core-js#ParameterRequiredError} if any required parameter is not provided
  * @openapi operation=listBoundaryAudits path=/boundaries/{boundaryId}/audits method=GET
  * @memberof Boundary
  */
  listBoundaryAudits(results: PagedResults<Audit & AuditExtended>, boundaryId: UUID, status?: AuditStatusEnumDef, type?: AuditTypeEnumDef, audited?: boolean): Promise<void>;
  /**
  * Page boundary components
  * @summary Page boundary components
  * @param {UUID} [boundaryId] Boundary Id filter
  * @param {UUID} [componentId] Component ID filter
  * @param {*} [options] Override http request option.
  * @throws {@link @zerobias-org/types-core-js#ParameterRequiredError} if any required parameter is not provided
  * @openapi operation=listBoundaryComponents path=/app/boundaryComponents method=GET
  * @memberof Boundary
  */
  listBoundaryComponents(results: PagedResults<BoundaryComponentExtended>, boundaryId?: UUID, componentId?: UUID): Promise<void>;
  /**
  * Page boundary components by boundary id
  * @summary Page boundary components by boundary id
  * @param {UUID} boundaryId 
  * @param {*} [options] Override http request option.
  * @throws {@link @zerobias-org/types-core-js#ParameterRequiredError} if any required parameter is not provided
  * @openapi operation=listBoundaryComponentsByBoundaryId path=/app/boundaries/{boundaryId}/components method=GET
  * @memberof Boundary
  */
  listBoundaryComponentsByBoundaryId(results: PagedResults<BoundaryComponentExtended>, boundaryId: UUID): Promise<void>;
  /**
  * Retrieves a list of all connections for a boundary
  * @summary Retrieves a list of all connections for a boundary
  * @param {UUID} boundaryId 
  * @param {*} [options] Override http request option.
  * @throws {@link @zerobias-org/types-core-js#ParameterRequiredError} if any required parameter is not provided
  * @openapi operation=listBoundaryConnections path=/boundaries/{boundaryId}/connections method=GET
  * @memberof Boundary
  */
  listBoundaryConnections(results: PagedResults<BoundaryConnectionForList>, boundaryId: UUID): Promise<void>;
  /**
  * Retrieves a list of events for a boundary
  * @summary Retrieves a list of events for a boundary
  * @param {UUID} boundaryId 
  * @param {*} [options] Override http request option.
  * @throws {@link @zerobias-org/types-core-js#ParameterRequiredError} if any required parameter is not provided
  * @openapi operation=listBoundaryEvents path=/boundaries/{boundaryId}/events method=GET
  * @memberof Boundary
  */
  listBoundaryEvents(results: PagedResults<BoundaryEvent & ExtendedBoundaryEvent>, boundaryId: UUID): Promise<void>;
  /**
  * Retrieves a list of all boundary evidence by boundary id
  * @summary Retrieves a list of all boundary evidence by boundary id
  * @param {UUID} boundaryId 
  * @param {BoundaryEvidenceStatusEnum} [status] 
  * @param {UUID} [productId] 
  * @param {Array<UUID>} [evidenceDefinitionIds] 
  * @param {BoundaryEvidenceSortColumns} [sortColumn] 
  * @param {SortOrderOptions} [sortOrder] 
  * @param {*} [options] Override http request option.
  * @throws {@link @zerobias-org/types-core-js#ParameterRequiredError} if any required parameter is not provided
  * @openapi operation=listBoundaryEvidence path=/boundaries/{boundaryId}/evidence method=GET
  * @memberof Boundary
  */
  listBoundaryEvidence(results: PagedResults<BoundaryEvidence & ExtendedBoundaryEvidence>, boundaryId: UUID, status?: BoundaryEvidenceStatusEnumDef, productId?: UUID, evidenceDefinitionIds?: Array<UUID>, sortColumn?: BoundaryEvidenceSortColumnsDef, sortOrder?: SortOrderOptionsDef): Promise<void>;
  /**
  * Retrieves a list of parties for a boundary
  * @summary Retrieves a list of parties for a boundary
  * @param {UUID} boundaryId 
  * @param {PartyTypeEnum} [partyType] 
  * @param {boolean} [assignable] 
  * @param {string} [search] comma separated string of keywords to search against
  * @param {SortObject} [sort] Sort object
  * @param {*} [options] Override http request option.
  * @throws {@link @zerobias-org/types-core-js#ParameterRequiredError} if any required parameter is not provided
  * @openapi operation=listBoundaryParties path=/boundaries/{boundaryId}/parties method=GET
  * @memberof Boundary
  */
  listBoundaryParties(results: PagedResults<PartyExtended>, boundaryId: UUID, partyType?: PartyTypeEnumDef, assignable?: boolean, search?: string, sort?: SortObject): Promise<void>;
  /**
  * Retrieves a boundary party Raci RollUP matrix
  * @summary Retrieves a boundary party Raci RollUP matrix
  * @param {UUID} boundaryId 
  * @param {UUID} partyId 
  * @param {*} [options] Override http request option.
  * @throws {@link @zerobias-org/types-core-js#ParameterRequiredError} if any required parameter is not provided
  * @openapi operation=listBoundaryPartyRaci path=/boundaries/{boundaryId}/parties/{partyId}/responsibilityMatrix method=GET
  * @memberof Boundary
  */
  listBoundaryPartyRaci(boundaryId: UUID, partyId: UUID): Promise<Array<RaciRollup>>;
  /**
  * Retrieves paged list of roles assigned to a party on a boundary
  * @summary Retrieves paged list of roles assigned to a party on a boundary
  * @param {UUID} boundaryId 
  * @param {UUID} partyId 
  * @param {*} [options] Override http request option.
  * @throws {@link @zerobias-org/types-core-js#ParameterRequiredError} if any required parameter is not provided
  * @openapi operation=listBoundaryPartyRoles path=/app/boundaries/{boundaryId}/parties/{partyId}/roles method=GET
  * @memberof Boundary
  */
  listBoundaryPartyRoles(results: PagedResults<BoundaryPartyRoleExtended>, boundaryId: UUID, partyId: UUID): Promise<void>;
  /**
  * Page boundary party roles by boundary id
  * @summary Page boundary party roles by boundary id
  * @param {UUID} boundaryId 
  * @param {UUID} [partyId] Party Id filter
  * @param {*} [options] Override http request option.
  * @throws {@link @zerobias-org/types-core-js#ParameterRequiredError} if any required parameter is not provided
  * @openapi operation=listBoundaryPartyRolesByBoundaryId path=/app/boundaries/{boundaryId}/partyRoles method=GET
  * @memberof Boundary
  */
  listBoundaryPartyRolesByBoundaryId(results: PagedResults<BoundaryPartyRoleExtended>, boundaryId: UUID, partyId?: UUID): Promise<void>;
  /**
  * List pipelines for a certain boundary
  * @summary List pipelines for a certain boundary
  * @param {UUID} boundaryId 
  * @param {string} [keywords] 
  * @param {UUID} [productId] 
  * @param {PipelineAdminStatusEnum} [adminStatus] 
  * @param {PipelineExecutionStatusEnum} [executionStatus] 
  * @param {PipelineFormatEnum} [type] 
  * @param {SortObject} [sort] Sort object
  * @param {*} [options] Override http request option.
  * @throws {@link @zerobias-org/types-core-js#ParameterRequiredError} if any required parameter is not provided
  * @openapi operation=listBoundaryPipelines path=/boundaries/{boundaryId}/pipelines method=GET
  * @memberof Boundary
  */
  listBoundaryPipelines(results: PagedResults<Pipeline>, boundaryId: UUID, keywords?: string, productId?: UUID, adminStatus?: PipelineAdminStatusEnumDef, executionStatus?: PipelineExecutionStatusEnumDef, type?: PipelineFormatEnumDef, sort?: SortObject): Promise<void>;
  /**
  * Retrieves a list of all connections for a boundary
  * @summary Retrieves a list of all connections for a boundary
  * @param {UUID} boundaryId 
  * @param {UUID} boundaryProductId 
  * @param {SortObject} [sort] Sort object
  * @param {*} [options] Override http request option.
  * @throws {@link @zerobias-org/types-core-js#ParameterRequiredError} if any required parameter is not provided
  * @openapi operation=listBoundaryProductConnections path=/boundaries/{boundaryId}/products/{boundaryProductId}/connections method=GET
  * @memberof Boundary
  */
  listBoundaryProductConnections(results: PagedResults<BoundaryConnectionForList>, boundaryId: UUID, boundaryProductId: UUID, sort?: SortObject): Promise<void>;
  /**
  * Retrieves a boundary product
  * @summary Retrieves a boundary product
  * @param {UUID} boundaryId 
  * @param {UUID} boundaryProductId 
  * @param {string} [search] 
  * @param {PipelineFormatEnum} [format] 
  * @param {UUID} [targetId] 
  * @param {SortObject} [sort] Sort object
  * @param {boolean} [showPreviews] 
  * @param {*} [options] Override http request option.
  * @throws {@link @zerobias-org/types-core-js#ParameterRequiredError} if any required parameter is not provided
  * @openapi operation=listBoundaryProductPipelines path=/boundaries/{boundaryId}/products/{boundaryProductId}/pipelines method=GET
  * @memberof Boundary
  */
  listBoundaryProductPipelines(results: PagedResults<BoundaryProductPipeline>, boundaryId: UUID, boundaryProductId: UUID, search?: string, format?: PipelineFormatEnumDef, targetId?: UUID, sort?: SortObject, showPreviews?: boolean): Promise<void>;
  /**
  * Retrieves a list of products for a boundary
  * @summary Retrieves a list of products for a boundary
  * @param {UUID} boundaryId 
  * @param {CatalogPublishStatusEnum} [status] Filter by status
  * @param {string} [keywords] Search like filter
  * @param {SortObject} [sort] 
  * @param {*} [options] Override http request option.
  * @throws {@link @zerobias-org/types-core-js#ParameterRequiredError} if any required parameter is not provided
  * @openapi operation=listBoundaryProductsByBoundary path=/boundaries/{boundaryId}/products method=GET
  * @memberof Boundary
  */
  listBoundaryProductsByBoundary(results: PagedResults<BoundaryProductExtended>, boundaryId: UUID, status?: CatalogPublishStatusEnumDef, keywords?: string, sort?: SortObject): Promise<void>;
  /**
  * List all alerts bound to a query
  * @summary List all alerts bound to a query
  * @param {UUID} boundaryId 
  * @param {UUID} queryId A queryId or queryVersionId.
  * @param {SortObject} [sort] Sort object
  * @param {*} [options] Override http request option.
  * @throws {@link @zerobias-org/types-core-js#ParameterRequiredError} if any required parameter is not provided
  * @openapi operation=listBoundaryQueryAlerts path=/app/boundaries/{boundaryId}/queries/{queryId}/alerts method=GET
  * @memberof Boundary
  */
  listBoundaryQueryAlerts(results: PagedResults<BoundaryAlertView>, boundaryId: UUID, queryId: UUID, sort?: SortObject): Promise<void>;
  /**
  * Retrieve paged list of boundary roles and parties if assigned
  * @summary Retrieve paged list of boundary roles and parties if assigned
  * @param {UUID} boundaryId 
  * @param {UUID} [roleCategoryId] 
  * @param {*} [options] Override http request option.
  * @throws {@link @zerobias-org/types-core-js#ParameterRequiredError} if any required parameter is not provided
  * @openapi operation=listBoundaryRoles path=/app/boundaries/{boundaryId}/roles method=GET
  * @memberof Boundary
  */
  listBoundaryRoles(results: PagedResults<BoundaryRoleExtended>, boundaryId: UUID, roleCategoryId?: UUID): Promise<void>;
  /**
  * Retrieves a list of scf controls for a boundary
  * @summary Retrieves a list of scf controls for a boundary
  * @param {UUID} boundaryId 
  * @param {UUID} [frameworkElementId] 
  * @param {string} [scfDomainCode] 
  * @param {boolean} [performed] 
  * @param {boolean} [answered] 
  * @param {*} [options] Override http request option.
  * @throws {@link @zerobias-org/types-core-js#ParameterRequiredError} if any required parameter is not provided
  * @openapi operation=listBoundaryScfControls path=/boundaries/{boundaryId}/scfControls method=GET
  * @memberof Boundary
  */
  listBoundaryScfControls(results: PagedResults<ExtendedBoundaryScfControl>, boundaryId: UUID, frameworkElementId?: UUID, scfDomainCode?: string, performed?: boolean, answered?: boolean): Promise<void>;
  /**
  * List standard baselines that have been added to a boundary
  * @summary List standard baselines that have been added to a boundary
  * @param {UUID} boundaryId 
  * @param {UUID} boundaryStandardBaselineId 
  * @param {SortObject} [sort] Sort object
  * @param {*} [options] Override http request option.
  * @throws {@link @zerobias-org/types-core-js#ParameterRequiredError} if any required parameter is not provided
  * @openapi operation=listBoundaryStandardBaselineElements path=/app/boundaries/{boundaryId}/standardBaselines/{boundaryStandardBaselineId}/elements method=GET
  * @memberof Boundary
  */
  listStandardBaselineElements(results: PagedResults<ElementExtended>, boundaryId: UUID, boundaryStandardBaselineId: UUID, sort?: SortObject): Promise<void>;
  /**
  * List standard baselines that have been added to a boundary
  * @summary List standard baselines that have been added to a boundary
  * @param {UUID} boundaryId 
  * @param {*} [options] Override http request option.
  * @throws {@link @zerobias-org/types-core-js#ParameterRequiredError} if any required parameter is not provided
  * @openapi operation=listBoundaryStandardBaselines path=/app/boundaries/{boundaryId}/standardBaselines method=GET
  * @memberof Boundary
  */
  listStandardBaselines(results: PagedResults<BoundaryStandardBaselineExtended>, boundaryId: UUID): Promise<void>;
  /**
  * Retrieves a list of suggested products for a boundary
  * @summary Retrieves a list of suggested products for a boundary
  * @param {UUID} boundaryId 
  * @param {string} [keywords] Search like filter
  * @param {*} [options] Override http request option.
  * @throws {@link @zerobias-org/types-core-js#ParameterRequiredError} if any required parameter is not provided
  * @openapi operation=listBoundarySuggestedProducts path=/boundaries/{boundaryId}/suggestedProducts method=GET
  * @memberof Boundary
  */
  listBoundarySuggestedProducts(results: PagedResults<BoundarySuggestedProduct>, boundaryId: UUID, keywords?: string): Promise<void>;
  /**
  * Retrieves a list of targets for a boundary
  * @summary Retrieves a list of targets for a boundary
  * @param {UUID} boundaryId 
  * @param {UUID} boundaryProductId 
  * @param {string} [keywords] Search like filter
  * @param {*} [options] Override http request option.
  * @throws {@link @zerobias-org/types-core-js#ParameterRequiredError} if any required parameter is not provided
  * @openapi operation=listBoundaryTargetsByProduct path=/boundaries/{boundaryId}/products/{boundaryProductId}/targets method=GET
  * @memberof Boundary
  */
  listBoundaryTargetsByProduct(results: PagedResults<BoundaryProductTarget & ExtendedBoundaryProductTarget>, boundaryId: UUID, boundaryProductId: UUID, keywords?: string): Promise<void>;
  /**
  * Retrieves a list of teams metrics for a boundary
  * @summary Retrieves a list of teams metrics for a boundary
  * @param {UUID} boundaryId 
  * @param {*} [options] Override http request option.
  * @throws {@link @zerobias-org/types-core-js#ParameterRequiredError} if any required parameter is not provided
  * @openapi operation=listBoundaryTeamMetrics path=/boundaries/{boundaryId}/teamMetrics method=GET
  * @memberof Boundary
  */
  listBoundaryTeamMetrics(results: PagedResults<BoundaryTeamMetrics>, boundaryId: UUID): Promise<void>;
  /**
  * Retrieves a list of evidence definitions in scope for a boundary team scf control
  * @summary Retrieves a list of evidence definitions in scope for a boundary team scf control
  * @param {UUID} boundaryId 
  * @param {UUID} teamId 
  * @param {UUID} scfControlId 
  * @param {*} [options] Override http request option.
  * @throws {@link @zerobias-org/types-core-js#ParameterRequiredError} if any required parameter is not provided
  * @openapi operation=listBoundaryTeamScfControlEvidenceDefintions path=/boundaries/{boundaryId}/teams/{teamId}/scfControlTree/{scfControlId}/evidenceDefinitions method=GET
  * @memberof Boundary
  */
  listBoundaryTeamScfControlEvidenceDefintions(results: PagedResults<BoundaryTeamScfControlEvidenceDefinitionImplementation>, boundaryId: UUID, teamId: UUID, scfControlId: UUID): Promise<void>;
  /**
  * Retrieves a list of scf control data for a boundary team
  * @summary Retrieves a list of scf control data for a boundary team
  * @param {UUID} boundaryId 
  * @param {UUID} teamId 
  * @param {string} [domain] Filter by domain
  * @param {string} [code] Filter by code
  * @param {*} [options] Override http request option.
  * @throws {@link @zerobias-org/types-core-js#ParameterRequiredError} if any required parameter is not provided
  * @openapi operation=listBoundaryTeamScfControls path=/boundaries/{boundaryId}/teams/{teamId}/scfControls method=GET
  * @memberof Boundary
  */
  listBoundaryTeamScfControls(results: PagedResults<BoundaryTeamScfControl>, boundaryId: UUID, teamId: UUID, domain?: string, code?: string): Promise<void>;
  /**
  * Retrieves a list of teams for a boundary
  * @summary Retrieves a list of teams for a boundary
  * @param {UUID} boundaryId 
  * @param {SortObject} [sort] Sort object
  * @param {*} [options] Override http request option.
  * @throws {@link @zerobias-org/types-core-js#ParameterRequiredError} if any required parameter is not provided
  * @openapi operation=listBoundaryTeams path=/boundaries/{boundaryId}/teams method=GET
  * @memberof Boundary
  */
  listBoundaryTeams(results: PagedResults<BoundaryTeam>, boundaryId: UUID, sort?: SortObject): Promise<void>;
  /**
  * List tests within a boundary with filters
  * @summary List tests within a boundary with filters
  * @param {UUID} boundaryId 
  * @param {UUID} [standardId] 
  * @param {UUID} [benchmarkId] 
  * @param {UUID} [testCaseId] 
  * @param {UUID} [componentId] 
  * @param {TestResultEnum} [status] 
  * @param {SortObject} [sort] Sort object
  * @param {*} [options] Override http request option.
  * @throws {@link @zerobias-org/types-core-js#ParameterRequiredError} if any required parameter is not provided
  * @openapi operation=listBoundaryTests path=/app/boundaries/{boundaryId}/tests method=GET
  * @memberof Boundary
  */
  listTests(results: PagedResults<TestExtended>, boundaryId: UUID, standardId?: UUID, benchmarkId?: UUID, testCaseId?: UUID, componentId?: UUID, status?: TestResultEnumDef, sort?: SortObject): Promise<void>;
  /**
  * Retrieves a list of scf domains unmanaged for a boundary
  * @summary Retrieves a list of scf domains unmanaged for a boundary
  * @param {UUID} boundaryId 
  * @param {*} [options] Override http request option.
  * @throws {@link @zerobias-org/types-core-js#ParameterRequiredError} if any required parameter is not provided
  * @openapi operation=listBoundaryUnmanagedDomains path=/boundaries/{boundaryId}/unmanagedDomains method=GET
  * @memberof Boundary
  */
  listBoundaryUnmanagedDomains(results: PagedResults<ScfDomain>, boundaryId: UUID): Promise<void>;
  /**
  * Page boundary party roles with filters
  * @summary Page boundary party roles with filters
  * @param {UUID} [partyId] Party Id filter
  * @param {UUID} [boundaryId] Boundary Id filter
  * @param {UUID} [roleId] Role ID filter
  * @param {*} [options] Override http request option.
  * @throws {@link @zerobias-org/types-core-js#ParameterRequiredError} if any required parameter is not provided
  * @openapi operation=listFilterBoundaryPartyRoles path=/app/boundaryPartyRoles method=GET
  * @memberof Boundary
  */
  listFilterBoundaryPartyRoles(results: PagedResults<BoundaryPartyRoleExtended>, partyId?: UUID, boundaryId?: UUID, roleId?: UUID): Promise<void>;
  /**
  * Remove crosswalk version from boundary
  * @summary Remove crosswalk version from boundary
  * @param {UUID} boundaryId 
  * @param {UUID} boundaryCrosswalkVersionId 
  * @param {*} [options] Override http request option.
  * @throws {@link @zerobias-org/types-core-js#ParameterRequiredError} if any required parameter is not provided
  * @openapi operation=removeBoundaryCrosswalkVersion path=/app/boundaries/{boundaryId}/crosswalkVersions/{boundaryCrosswalkVersionId} method=DELETE
  * @memberof Boundary
  */
  removeCrosswalkVersion(boundaryId: UUID, boundaryCrosswalkVersionId: UUID): Promise<void>;
  /**
  * Remove standard baseline from boundary
  * @summary Remove standard baseline from boundary
  * @param {UUID} boundaryId 
  * @param {UUID} boundaryStandardBaselineId 
  * @param {*} [options] Override http request option.
  * @throws {@link @zerobias-org/types-core-js#ParameterRequiredError} if any required parameter is not provided
  * @openapi operation=removeBoundaryStandardBaseline path=/app/boundaries/{boundaryId}/standardBaselines/{boundaryStandardBaselineId} method=DELETE
  * @memberof Boundary
  */
  removeStandardBaseline(boundaryId: UUID, boundaryStandardBaselineId: UUID): Promise<void>;
  /**
  * Manually run an alert bot
  * @summary Manually run an alert bot
  * @param {UUID} boundaryId 
  * @param {UUID} boundaryAlertBotId 
  * @param {*} [options] Override http request option.
  * @throws {@link @zerobias-org/types-core-js#ParameterRequiredError} if any required parameter is not provided
  * @openapi operation=runBoundaryAlertBot path=/app/boundaries/{boundaryId}/alertBots/{boundaryAlertBotId} method=POST
  * @memberof Boundary
  */
  runAlertBot(boundaryId: UUID, boundaryAlertBotId: UUID): Promise<void>;
  /**
  * Subscribe to an Alert Bot's alerts
  * @summary Subscribe to an Alert Bot's alerts
  * @param {UUID} boundaryId 
  * @param {UUID} boundaryAlertBotId 
  * @param {*} [options] Override http request option.
  * @throws {@link @zerobias-org/types-core-js#ParameterRequiredError} if any required parameter is not provided
  * @openapi operation=subscribeToBoundaryAlertBotAlerts path=/app/boundaries/{boundaryId}/alertBots/{boundaryAlertBotId}/subscribe method=PUT
  * @memberof Boundary
  */
  subscribe(boundaryId: UUID, boundaryAlertBotId: UUID): Promise<AlertSubscriptionExtended>;
  /**
  * Unsubscribe from and alert bot's alerts
  * @summary Unsubscribe from and alert bot's alerts
  * @param {UUID} boundaryId 
  * @param {UUID} boundaryAlertBotId 
  * @param {*} [options] Override http request option.
  * @throws {@link @zerobias-org/types-core-js#ParameterRequiredError} if any required parameter is not provided
  * @openapi operation=unsubscribeFromBoundaryAlertBotAlerts path=/app/boundaries/{boundaryId}/alertBots/{boundaryAlertBotId}/unsubscribe method=PUT
  * @memberof Boundary
  */
  unsubscribe(boundaryId: UUID, boundaryAlertBotId: UUID): Promise<AlertSubscriptionExtended>;
  /**
  * Updates a boundary
  * @summary Updates a boundary
  * @param {UUID} boundaryId 
  * @param {UpdateBoundary} updateBoundary 
  * @param {*} [options] Override http request option.
  * @throws {@link @zerobias-org/types-core-js#ParameterRequiredError} if any required parameter is not provided
  * @openapi operation=updateBoundary path=/boundaries/{boundaryId} method=PUT
  * @memberof Boundary
  */
  updateBoundary(boundaryId: UUID, updateBoundary: UpdateBoundary): Promise<Boundary>;
  /**
  * Update an alert bot
  * @summary Update an alert bot
  * @param {UUID} boundaryId 
  * @param {UUID} boundaryAlertBotId 
  * @param {UpdateBoundaryAlertBot} updateBoundaryAlertBot 
  * @param {*} [options] Override http request option.
  * @throws {@link @zerobias-org/types-core-js#ParameterRequiredError} if any required parameter is not provided
  * @openapi operation=updateBoundaryAlertBot path=/app/boundaries/{boundaryId}/alertBots/{boundaryAlertBotId} method=PATCH
  * @memberof Boundary
  */
  updateAlertBot(boundaryId: UUID, boundaryAlertBotId: UUID, updateBoundaryAlertBot: UpdateBoundaryAlertBot): Promise<BoundaryAlertBotExtended>;
  /**
  * Updates a boundary evidence
  * @summary Updates a boundary evidence
  * @param {UUID} boundaryId 
  * @param {UUID} evidenceId 
  * @param {UpdateBoundaryEvidence} updateBoundaryEvidence 
  * @param {*} [options] Override http request option.
  * @throws {@link @zerobias-org/types-core-js#ParameterRequiredError} if any required parameter is not provided
  * @openapi operation=updateBoundaryEvidence path=/boundaries/{boundaryId}/evidence/{evidenceId} method=PUT
  * @memberof Boundary
  */
  updateBoundaryEvidence(boundaryId: UUID, evidenceId: UUID, updateBoundaryEvidence: UpdateBoundaryEvidence): Promise<BoundaryEvidence>;
  /**
  * Updates a boundary product
  * @summary Updates a boundary product
  * @param {UUID} boundaryId 
  * @param {UUID} boundaryProductId 
  * @param {UpdateBoundaryProduct} updateBoundaryProduct 
  * @param {*} [options] Override http request option.
  * @throws {@link @zerobias-org/types-core-js#ParameterRequiredError} if any required parameter is not provided
  * @openapi operation=updateBoundaryProduct path=/boundaries/{boundaryId}/products/{boundaryProductId} method=PUT
  * @memberof Boundary
  */
  updateBoundaryProduct(boundaryId: UUID, boundaryProductId: UUID, updateBoundaryProduct: UpdateBoundaryProduct): Promise<BoundaryProduct>;
  /**
  * Updates a scf control for a boundary
  * @summary Updates a scf control for a boundary
  * @param {UUID} boundaryId 
  * @param {UUID} boundaryScfControlId 
  * @param {UpdateBoundaryScfControl} updateBoundaryScfControl 
  * @param {*} [options] Override http request option.
  * @throws {@link @zerobias-org/types-core-js#ParameterRequiredError} if any required parameter is not provided
  * @openapi operation=updateBoundaryScfControl path=/boundaries/{boundaryId}/scfControls/{boundaryScfControlId} method=PUT
  * @memberof Boundary
  */
  updateBoundaryScfControl(boundaryId: UUID, boundaryScfControlId: UUID, updateBoundaryScfControl: UpdateBoundaryScfControl): Promise<ExtendedBoundaryScfControl>;
  /**
  * Updates a boundary team
  * @summary Updates a boundary team
  * @param {UUID} boundaryId 
  * @param {UUID} teamId 
  * @param {UpdateBoundaryTeam} updateBoundaryTeam 
  * @param {*} [options] Override http request option.
  * @throws {@link @zerobias-org/types-core-js#ParameterRequiredError} if any required parameter is not provided
  * @openapi operation=updateBoundaryTeam path=/boundaries/{boundaryId}/teams/{teamId} method=PUT
  * @memberof Boundary
  */
  updateBoundaryTeam(boundaryId: UUID, teamId: UUID, updateBoundaryTeam: UpdateBoundaryTeam): Promise<BoundaryTeam>;
  /**
  * Updates a boundary team scf control question
  * @summary Updates a boundary team scf control question
  * @param {UUID} boundaryId 
  * @param {UUID} teamId 
  * @param {UUID} scfControlId 
  * @param {UpdateBoundaryTeamScfControl} updateBoundaryTeamScfControl 
  * @param {*} [options] Override http request option.
  * @throws {@link @zerobias-org/types-core-js#ParameterRequiredError} if any required parameter is not provided
  * @openapi operation=updateBoundaryTeamScfControl path=/boundaries/{boundaryId}/teams/{teamId}/scfControlTree/{scfControlId} method=PUT
  * @memberof Boundary
  */
  updateBoundaryTeamScfControl(boundaryId: UUID, teamId: UUID, scfControlId: UUID, updateBoundaryTeamScfControl: UpdateBoundaryTeamScfControl): Promise<BoundaryTeamScfControl>;
  /**
  * Updates a boundary team scf control evidence definition implementation
  * @summary Updates a boundary team scf control evidence definition implementation
  * @param {UUID} boundaryId 
  * @param {UUID} teamId 
  * @param {UUID} scfControlId 
  * @param {UUID} evidenceDefinitionId 
  * @param {UpdateBoundaryTeamScfControlEvidenceDefinition} updateBoundaryTeamScfControlEvidenceDefinition 
  * @param {*} [options] Override http request option.
  * @throws {@link @zerobias-org/types-core-js#ParameterRequiredError} if any required parameter is not provided
  * @openapi operation=updateBoundaryTeamScfControlEvidenceDefinition path=/boundaries/{boundaryId}/teams/{teamId}/scfControlTree/{scfControlId}/evidenceDefinitions/{evidenceDefinitionId} method=PUT
  * @memberof Boundary
  */
  updateBoundaryTeamScfControlEvidenceDefinition(boundaryId: UUID, teamId: UUID, scfControlId: UUID, evidenceDefinitionId: UUID, updateBoundaryTeamScfControlEvidenceDefinition: UpdateBoundaryTeamScfControlEvidenceDefinition): Promise<BoundaryTeamScfControlEvidenceDefinitionImplementation>;
  /**
  * Creates or Updates an alert bot for a query, query version, and boundary
  * @summary Creates or Updates an alert bot for a query, query version, and boundary
  * @param {UUID} boundaryId 
  * @param {NewBoundaryAlertBot} newBoundaryAlertBot 
  * @param {boolean} [executeAndVerifyQuery] 
  * @param {*} [options] Override http request option.
  * @throws {@link @zerobias-org/types-core-js#ParameterRequiredError} if any required parameter is not provided
  * @openapi operation=upsertBoundaryAlertBot path=/app/boundaries/{boundaryId}/alertBots method=PUT
  * @memberof Boundary
  */
  upsertAlertBot(boundaryId: UUID, newBoundaryAlertBot: NewBoundaryAlertBot, executeAndVerifyQuery?: boolean): Promise<BoundaryAlertBotExtended>;
  /**
  * Updates a boundary product targets
  * @summary Updates a boundary product targets
  * @param {UUID} boundaryId 
  * @param {UUID} boundaryProductId 
  * @param {NewBoundaryProductTarget} newBoundaryProductTarget 
  * @param {*} [options] Override http request option.
  * @throws {@link @zerobias-org/types-core-js#ParameterRequiredError} if any required parameter is not provided
  * @openapi operation=upsertBoundaryProductTargets path=/boundaries/{boundaryId}/products/{boundaryProductId}/targets method=PUT
  * @memberof Boundary
  */
  upsertBoundaryProductTargets(boundaryId: UUID, boundaryProductId: UUID, newBoundaryProductTarget: NewBoundaryProductTarget): Promise<Array<BoundaryProductTarget>>;
  /**
  * Updates a boundarys products
  * @summary Updates a boundarys products
  * @param {UUID} boundaryId 
  * @param {UpsertBoundaryProducts} upsertBoundaryProducts 
  * @param {*} [options] Override http request option.
  * @throws {@link @zerobias-org/types-core-js#ParameterRequiredError} if any required parameter is not provided
  * @openapi operation=upsertBoundaryProducts path=/boundaries/{boundaryId}/products method=PUT
  * @memberof Boundary
  */
  upsertBoundaryProducts(boundaryId: UUID, upsertBoundaryProducts: UpsertBoundaryProducts): Promise<Array<BoundaryProduct>>;
}

export class BoundaryApiMappingImpl implements BoundaryApi {
  private producer: BoundaryProducerApi;
  constructor(producer: BoundaryProducerApi) {
    this.producer = producer;
  }

  /**
   * Add crosswalk versions to boundary
   * @summary Add crosswalk versions to boundary
   * @param boundaryId 
   * @param newBoundaryCrosswalkVersion 
   * @openapi operation=addBoundaryCrosswalkVersion path=/app/boundaries/{boundaryId}/crosswalkVersions method=POST
   */
  public async addCrosswalkVersion(boundaryId: UUID, newBoundaryCrosswalkVersion: NewBoundaryCrosswalkVersion): Promise<BoundaryCrosswalkVersionExtended> {
    // verify required parameter 'boundaryId' is not null or undefined
    if (boundaryId === null || boundaryId === undefined) {
      throw new ParameterRequiredError('boundaryId');
    }
    // verify required parameter 'newBoundaryCrosswalkVersion' is not null or undefined
    if (newBoundaryCrosswalkVersion === null || newBoundaryCrosswalkVersion === undefined) {
      throw new ParameterRequiredError('newBoundaryCrosswalkVersion');
    }
    return this.producer.addCrosswalkVersion(boundaryId, newBoundaryCrosswalkVersion);
  }
  /**
   * Add standard baseline to boundary
   * @summary Add standard baseline to boundary
   * @param boundaryId 
   * @param newBoundaryStandardBaseline 
   * @openapi operation=addBoundaryStandardBaseline path=/app/boundaries/{boundaryId}/standardBaselines method=POST
   */
  public async addStandardBaseline(boundaryId: UUID, newBoundaryStandardBaseline: NewBoundaryStandardBaseline): Promise<BoundaryStandardBaselineExtended> {
    // verify required parameter 'boundaryId' is not null or undefined
    if (boundaryId === null || boundaryId === undefined) {
      throw new ParameterRequiredError('boundaryId');
    }
    // verify required parameter 'newBoundaryStandardBaseline' is not null or undefined
    if (newBoundaryStandardBaseline === null || newBoundaryStandardBaseline === undefined) {
      throw new ParameterRequiredError('newBoundaryStandardBaseline');
    }
    return this.producer.addStandardBaseline(boundaryId, newBoundaryStandardBaseline);
  }
  /**
   * Choose elements that are in scope for boundary standard baseline
   * @summary Choose elements that are in scope for boundary standard baseline
   * @param boundaryId 
   * @param boundaryStandardBaselineId 
   * @param newBoundaryStandardBaselineElements 
   * @openapi operation=addBoundaryStandardBaselineElements path=/app/boundaries/{boundaryId}/standardBaselines/{boundaryStandardBaselineId}/elements method=POST
   */
  public async addStandardBaselineElements(boundaryId: UUID, boundaryStandardBaselineId: UUID, newBoundaryStandardBaselineElements: NewBoundaryStandardBaselineElements): Promise<Array<ElementExtended>> {
    // verify required parameter 'boundaryId' is not null or undefined
    if (boundaryId === null || boundaryId === undefined) {
      throw new ParameterRequiredError('boundaryId');
    }
    // verify required parameter 'boundaryStandardBaselineId' is not null or undefined
    if (boundaryStandardBaselineId === null || boundaryStandardBaselineId === undefined) {
      throw new ParameterRequiredError('boundaryStandardBaselineId');
    }
    // verify required parameter 'newBoundaryStandardBaselineElements' is not null or undefined
    if (newBoundaryStandardBaselineElements === null || newBoundaryStandardBaselineElements === undefined) {
      throw new ParameterRequiredError('newBoundaryStandardBaselineElements');
    }
    return this.producer.addStandardBaselineElements(boundaryId, boundaryStandardBaselineId, newBoundaryStandardBaselineElements);
  }
  /**
   * Removes a subscription from a boundary alert bot
   * @summary Removes a subscription from a boundary alert bot
   * @param boundaryId 
   * @param boundaryAlertBotId 
   * @param subscriptionId 
   * @openapi operation=boundaryAlertBotDeleteSubscription path=/app/boundaries/{boundaryId}/alertBots/{boundaryAlertBotId}/subscriptions/{subscriptionId} method=DELETE
   */
  public async deleteSubscription(boundaryId: UUID, boundaryAlertBotId: UUID, subscriptionId: UUID): Promise<void> {
    // verify required parameter 'boundaryId' is not null or undefined
    if (boundaryId === null || boundaryId === undefined) {
      throw new ParameterRequiredError('boundaryId');
    }
    // verify required parameter 'boundaryAlertBotId' is not null or undefined
    if (boundaryAlertBotId === null || boundaryAlertBotId === undefined) {
      throw new ParameterRequiredError('boundaryAlertBotId');
    }
    // verify required parameter 'subscriptionId' is not null or undefined
    if (subscriptionId === null || subscriptionId === undefined) {
      throw new ParameterRequiredError('subscriptionId');
    }
    return this.producer.deleteSubscription(boundaryId, boundaryAlertBotId, subscriptionId);
  }
  /**
   * Adds a subscription to a boundary alert bot
   * @summary Adds a subscription to a boundary alert bot
   * @param boundaryId 
   * @param boundaryAlertBotId 
   * @param newAlertSubscription 
   * @openapi operation=boundaryAlertBotSubscribeToAlerts path=/app/boundaries/{boundaryId}/alertBots/{boundaryAlertBotId}/subscriptions method=POST
   */
  public async addSubscription(boundaryId: UUID, boundaryAlertBotId: UUID, newAlertSubscription: NewAlertSubscription): Promise<AlertSubscriptionExtended> {
    // verify required parameter 'boundaryId' is not null or undefined
    if (boundaryId === null || boundaryId === undefined) {
      throw new ParameterRequiredError('boundaryId');
    }
    // verify required parameter 'boundaryAlertBotId' is not null or undefined
    if (boundaryAlertBotId === null || boundaryAlertBotId === undefined) {
      throw new ParameterRequiredError('boundaryAlertBotId');
    }
    // verify required parameter 'newAlertSubscription' is not null or undefined
    if (newAlertSubscription === null || newAlertSubscription === undefined) {
      throw new ParameterRequiredError('newAlertSubscription');
    }
    return this.producer.addSubscription(boundaryId, boundaryAlertBotId, newAlertSubscription);
  }
  /**
   * Executes a query within the given boundary. (not implemented)
   * @summary Executes a query within the given boundary. (not implemented)
   * @param boundaryId 
   * @param queryId the queryId or queryVersionId to execute. If given a queryId the latest version of that query will be executed
   * @param executeGraphqlQuery 
   * @openapi operation=boundaryExecuteQuery path=/app/boundaries/{boundaryId}/queries/{queryId} method=PUT
   */
  public async boundaryExecuteQuery(boundaryId: UUID, queryId: UUID, executeGraphqlQuery: ExecuteGraphqlQuery): Promise<ExecuteGraphqlQueryResult> {
    // verify required parameter 'boundaryId' is not null or undefined
    if (boundaryId === null || boundaryId === undefined) {
      throw new ParameterRequiredError('boundaryId');
    }
    // verify required parameter 'queryId' is not null or undefined
    if (queryId === null || queryId === undefined) {
      throw new ParameterRequiredError('queryId');
    }
    // verify required parameter 'executeGraphqlQuery' is not null or undefined
    if (executeGraphqlQuery === null || executeGraphqlQuery === undefined) {
      throw new ParameterRequiredError('executeGraphqlQuery');
    }
    return this.producer.boundaryExecuteQuery(boundaryId, queryId, executeGraphqlQuery);
  }
  /**
   * Searches for filters, queries, and keywords within boundary for given keyword
   * @summary Searches for filters, queries, and keywords within boundary for given keyword
   * @param boundaryId 
   * @param boundaryKeywordSearchBody Filters to apply to the search.
   * @openapi operation=boundaryKeywordSearch path=/boundaries/{boundaryId}/keywordSearch method=POST
   */
  public async boundaryKeywordSearch(boundaryId: UUID, boundaryKeywordSearchBody: BoundaryKeywordSearchBody): Promise<BoundaryKeywordSearchResult> {
    // verify required parameter 'boundaryId' is not null or undefined
    if (boundaryId === null || boundaryId === undefined) {
      throw new ParameterRequiredError('boundaryId');
    }
    // verify required parameter 'boundaryKeywordSearchBody' is not null or undefined
    if (boundaryKeywordSearchBody === null || boundaryKeywordSearchBody === undefined) {
      throw new ParameterRequiredError('boundaryKeywordSearchBody');
    }
    return this.producer.boundaryKeywordSearch(boundaryId, boundaryKeywordSearchBody);
  }
  /**
   * Searches for keywords within boundary for given class and keyword
   * @summary Searches for keywords within boundary for given class and keyword
   * @param boundaryId 
   * @param classId 
   * @param boundaryKeywordSearchBody Filters to apply to the search.
   * @openapi operation=boundaryKeywordSearchForClass path=/boundaries/{boundaryId}/keywordSearch/{classId} method=POST
   */
  public async boundaryKeywordSearchForClass(boundaryId: UUID, classId: UUID, boundaryKeywordSearchBody: BoundaryKeywordSearchBody): Promise<BoundaryKeywordSearchForClassResult> {
    // verify required parameter 'boundaryId' is not null or undefined
    if (boundaryId === null || boundaryId === undefined) {
      throw new ParameterRequiredError('boundaryId');
    }
    // verify required parameter 'classId' is not null or undefined
    if (classId === null || classId === undefined) {
      throw new ParameterRequiredError('classId');
    }
    // verify required parameter 'boundaryKeywordSearchBody' is not null or undefined
    if (boundaryKeywordSearchBody === null || boundaryKeywordSearchBody === undefined) {
      throw new ParameterRequiredError('boundaryKeywordSearchBody');
    }
    return this.producer.boundaryKeywordSearchForClass(boundaryId, classId, boundaryKeywordSearchBody);
  }
  /**
   * Retrieves object counts for class given in filter
   * @summary Retrieves object counts for class given in filter
   * @param boundaryId 
   * @param boundaryObjectCountFilter 
   * @openapi operation=boundaryObjectCount path=/boundaries/{boundaryId}/objectCount method=POST
   */
  public async boundaryObjectCount(boundaryId: UUID, boundaryObjectCountFilter: BoundaryObjectCountFilter): Promise<BoundaryObjectCountResult> {
    // verify required parameter 'boundaryId' is not null or undefined
    if (boundaryId === null || boundaryId === undefined) {
      throw new ParameterRequiredError('boundaryId');
    }
    // verify required parameter 'boundaryObjectCountFilter' is not null or undefined
    if (boundaryObjectCountFilter === null || boundaryObjectCountFilter === undefined) {
      throw new ParameterRequiredError('boundaryObjectCountFilter');
    }
    return this.producer.boundaryObjectCount(boundaryId, boundaryObjectCountFilter);
  }
  /**
   * Search through objects within a boundary
   * @summary Search through objects within a boundary
   * @param boundaryId 
   * @param boundaryObjectSearchFilter Filters to apply to the search.
   * @param pageNumber The requested page. This value is 1-indexed.
   * @param pageSize The number of items in each page of data.
   * @openapi operation=boundaryObjectSearch path=/boundaries/{boundaryId}/objectSearch method=POST
   */
  public async boundaryObjectSearch(boundaryId: UUID, boundaryObjectSearchFilter: BoundaryObjectSearchFilter, pageNumber: number = 1, pageSize: number = 50): Promise<PagedResults<BoundarySearchResult>> {
    // verify required parameter 'boundaryId' is not null or undefined
    if (boundaryId === null || boundaryId === undefined) {
      throw new ParameterRequiredError('boundaryId');
    }
    // verify required parameter 'boundaryObjectSearchFilter' is not null or undefined
    if (boundaryObjectSearchFilter === null || boundaryObjectSearchFilter === undefined) {
      throw new ParameterRequiredError('boundaryObjectSearchFilter');
    }
    if (pageNumber) {
      await Int32.parse(pageNumber);
    }
    if (pageSize) {
      await Int32.parse(pageSize);
    }
    const bag = new PagedResults<BoundarySearchResult>();
    bag.pageNumber = pageNumber;
    bag.pageSize = pageSize;
    await this.producer.boundaryObjectSearch(bag, boundaryId, boundaryObjectSearchFilter);
    if (bag.items === null || bag.items === undefined) {
      throw new UnexpectedError("Producers must return 'items' for PagedResults queries");
    }
    return bag;
  }
  /**
   * Search through objects within a boundary and returns metadata about results that would be returned by objectSearch
   * @summary Search through objects within a boundary and returns metadata about results that would be returned by objectSearch
   * @param boundaryId 
   * @param boundaryObjectSearchFilter Filters to apply to the search.
   * @openapi operation=boundaryObjectSearchMetadata path=/boundaries/{boundaryId}/objectSearchMetadata method=POST
   */
  public async boundaryObjectSearchMetadata(boundaryId: UUID, boundaryObjectSearchFilter: BoundaryObjectSearchFilter): Promise<BoundaryObjectSearchResultsMetadata> {
    // verify required parameter 'boundaryId' is not null or undefined
    if (boundaryId === null || boundaryId === undefined) {
      throw new ParameterRequiredError('boundaryId');
    }
    // verify required parameter 'boundaryObjectSearchFilter' is not null or undefined
    if (boundaryObjectSearchFilter === null || boundaryObjectSearchFilter === undefined) {
      throw new ParameterRequiredError('boundaryObjectSearchFilter');
    }
    return this.producer.boundaryObjectSearchMetadata(boundaryId, boundaryObjectSearchFilter);
  }
  /**
   * Search accross objects, resources and tags within a boundary
   * @summary Search accross objects, resources and tags within a boundary
   * @param boundaryId 
   * @param boundarySearchFilter Filters to apply to the search.
   * @param pageNumber The requested page. This value is 1-indexed.
   * @param pageSize The number of items in each page of data.
   * @openapi operation=boundarySearch path=/boundaries/{boundaryId}/search method=POST
   */
  public async boundarySearch(boundaryId: UUID, boundarySearchFilter: BoundarySearchFilter, pageNumber: number = 1, pageSize: number = 50): Promise<PagedResults<BoundarySearchResult>> {
    // verify required parameter 'boundaryId' is not null or undefined
    if (boundaryId === null || boundaryId === undefined) {
      throw new ParameterRequiredError('boundaryId');
    }
    // verify required parameter 'boundarySearchFilter' is not null or undefined
    if (boundarySearchFilter === null || boundarySearchFilter === undefined) {
      throw new ParameterRequiredError('boundarySearchFilter');
    }
    if (pageNumber) {
      await Int32.parse(pageNumber);
    }
    if (pageSize) {
      await Int32.parse(pageSize);
    }
    const bag = new PagedResults<BoundarySearchResult>();
    bag.pageNumber = pageNumber;
    bag.pageSize = pageSize;
    await this.producer.boundarySearch(bag, boundaryId, boundarySearchFilter);
    if (bag.items === null || bag.items === undefined) {
      throw new UnexpectedError("Producers must return 'items' for PagedResults queries");
    }
    return bag;
  }
  /**
   * Create a new boundary
   * @summary Create a new boundary
   * @param newBoundary 
   * @openapi operation=createBoundary path=/boundaries method=POST
   */
  public async createBoundary(newBoundary: NewBoundary): Promise<Boundary> {
    // verify required parameter 'newBoundary' is not null or undefined
    if (newBoundary === null || newBoundary === undefined) {
      throw new ParameterRequiredError('newBoundary');
    }
    return this.producer.createBoundary(newBoundary);
  }
  /**
   * Create a new boundary Event
   * @summary Create a new boundary Event
   * @param boundaryId 
   * @param newBoundaryEvent 
   * @openapi operation=createBoundaryEvent path=/boundaries/{boundaryId}/events method=POST
   */
  public async createBoundaryEvent(boundaryId: UUID, newBoundaryEvent: NewBoundaryEvent): Promise<BoundaryEvent> {
    // verify required parameter 'boundaryId' is not null or undefined
    if (boundaryId === null || boundaryId === undefined) {
      throw new ParameterRequiredError('boundaryId');
    }
    // verify required parameter 'newBoundaryEvent' is not null or undefined
    if (newBoundaryEvent === null || newBoundaryEvent === undefined) {
      throw new ParameterRequiredError('newBoundaryEvent');
    }
    return this.producer.createBoundaryEvent(boundaryId, newBoundaryEvent);
  }
  /**
   * Create a new boundary Event
   * @summary Create a new boundary Event
   * @param boundaryId 
   * @openapi operation=createBoundaryEvidence path=/boundaries/{boundaryId}/evidence method=POST
   */
  public async createBoundaryEvidence(boundaryId: UUID): Promise<CreateBoundaryEvidenceCounts> {
    // verify required parameter 'boundaryId' is not null or undefined
    if (boundaryId === null || boundaryId === undefined) {
      throw new ParameterRequiredError('boundaryId');
    }
    return this.producer.createBoundaryEvidence(boundaryId);
  }
  /**
   * Create a new boundary party
   * @summary Create a new boundary party
   * @param boundaryId 
   * @param newBoundaryParty 
   * @openapi operation=createBoundaryParty path=/boundaries/{boundaryId}/parties method=POST
   */
  public async createBoundaryParty(boundaryId: UUID, newBoundaryParty: NewBoundaryParty): Promise<PartyExtended> {
    // verify required parameter 'boundaryId' is not null or undefined
    if (boundaryId === null || boundaryId === undefined) {
      throw new ParameterRequiredError('boundaryId');
    }
    // verify required parameter 'newBoundaryParty' is not null or undefined
    if (newBoundaryParty === null || newBoundaryParty === undefined) {
      throw new ParameterRequiredError('newBoundaryParty');
    }
    return this.producer.createBoundaryParty(boundaryId, newBoundaryParty);
  }
  /**
   * Create new boundary party role
   * @summary Create new boundary party role
   * @param boundaryId 
   * @param newBoundaryPartyRole 
   * @openapi operation=createBoundaryPartyRole path=/app/boundaries/{boundaryId}/partyRoles method=POST
   */
  public async createBoundaryPartyRole(boundaryId: UUID, newBoundaryPartyRole: NewBoundaryPartyRole): Promise<BoundaryPartyRoleExtended> {
    // verify required parameter 'boundaryId' is not null or undefined
    if (boundaryId === null || boundaryId === undefined) {
      throw new ParameterRequiredError('boundaryId');
    }
    // verify required parameter 'newBoundaryPartyRole' is not null or undefined
    if (newBoundaryPartyRole === null || newBoundaryPartyRole === undefined) {
      throw new ParameterRequiredError('newBoundaryPartyRole');
    }
    return this.producer.createBoundaryPartyRole(boundaryId, newBoundaryPartyRole);
  }
  /**
   * Create a new boundary product
   * @summary Create a new boundary product
   * @param boundaryId 
   * @param newBoundaryProduct 
   * @openapi operation=createBoundaryProduct path=/boundaries/{boundaryId}/products method=POST
   */
  public async createBoundaryProduct(boundaryId: UUID, newBoundaryProduct: NewBoundaryProduct): Promise<BoundaryProductProcessedResponse> {
    // verify required parameter 'boundaryId' is not null or undefined
    if (boundaryId === null || boundaryId === undefined) {
      throw new ParameterRequiredError('boundaryId');
    }
    // verify required parameter 'newBoundaryProduct' is not null or undefined
    if (newBoundaryProduct === null || newBoundaryProduct === undefined) {
      throw new ParameterRequiredError('newBoundaryProduct');
    }
    return this.producer.createBoundaryProduct(boundaryId, newBoundaryProduct);
  }
  /**
   * Create a new boundary product target
   * @summary Create a new boundary product target
   * @param boundaryId 
   * @param boundaryProductId 
   * @param newBoundaryProductTarget 
   * @openapi operation=createBoundaryProductTarget path=/boundaries/{boundaryId}/products/{boundaryProductId}/targets method=POST
   */
  public async createBoundaryProductTarget(boundaryId: UUID, boundaryProductId: UUID, newBoundaryProductTarget: NewBoundaryProductTarget): Promise<BoundaryProductTargetProcessedResponse> {
    // verify required parameter 'boundaryId' is not null or undefined
    if (boundaryId === null || boundaryId === undefined) {
      throw new ParameterRequiredError('boundaryId');
    }
    // verify required parameter 'boundaryProductId' is not null or undefined
    if (boundaryProductId === null || boundaryProductId === undefined) {
      throw new ParameterRequiredError('boundaryProductId');
    }
    // verify required parameter 'newBoundaryProductTarget' is not null or undefined
    if (newBoundaryProductTarget === null || newBoundaryProductTarget === undefined) {
      throw new ParameterRequiredError('newBoundaryProductTarget');
    }
    return this.producer.createBoundaryProductTarget(boundaryId, boundaryProductId, newBoundaryProductTarget);
  }
  /**
   * Create a new boundary team
   * @summary Create a new boundary team
   * @param boundaryId 
   * @param newBoundaryTeam 
   * @openapi operation=createBoundaryTeam path=/boundaries/{boundaryId}/teams method=POST
   */
  public async createBoundaryTeam(boundaryId: UUID, newBoundaryTeam: NewBoundaryTeam): Promise<BoundaryTeam> {
    // verify required parameter 'boundaryId' is not null or undefined
    if (boundaryId === null || boundaryId === undefined) {
      throw new ParameterRequiredError('boundaryId');
    }
    // verify required parameter 'newBoundaryTeam' is not null or undefined
    if (newBoundaryTeam === null || newBoundaryTeam === undefined) {
      throw new ParameterRequiredError('newBoundaryTeam');
    }
    return this.producer.createBoundaryTeam(boundaryId, newBoundaryTeam);
  }
  /**
   * Create a new suggested product
   * @summary Create a new suggested product
   * @param boundaryId 
   * @param newSuggestedProduct 
   * @openapi operation=createSuggestedProduct path=/boundaries/{boundaryId}/suggestedProducts method=POST
   */
  public async createSuggestedProduct(boundaryId: UUID, newSuggestedProduct: NewSuggestedProduct): Promise<SuggestedProduct> {
    // verify required parameter 'boundaryId' is not null or undefined
    if (boundaryId === null || boundaryId === undefined) {
      throw new ParameterRequiredError('boundaryId');
    }
    // verify required parameter 'newSuggestedProduct' is not null or undefined
    if (newSuggestedProduct === null || newSuggestedProduct === undefined) {
      throw new ParameterRequiredError('newSuggestedProduct');
    }
    return this.producer.createSuggestedProduct(boundaryId, newSuggestedProduct);
  }
  /**
   * Deletes a boundary
   * @summary Deletes a boundary
   * @param boundaryId 
   * @openapi operation=deleteBoundary path=/boundaries/{boundaryId} method=DELETE
   */
  public async deleteBoundary(boundaryId: UUID): Promise<void> {
    // verify required parameter 'boundaryId' is not null or undefined
    if (boundaryId === null || boundaryId === undefined) {
      throw new ParameterRequiredError('boundaryId');
    }
    return this.producer.deleteBoundary(boundaryId);
  }
  /**
   * Deletes a boundary query alert bot
   * @summary Deletes a boundary query alert bot
   * @param boundaryId 
   * @param boundaryAlertBotId 
   * @openapi operation=deleteBoundaryAlertBot path=/app/boundaries/{boundaryId}/alertBots/{boundaryAlertBotId} method=DELETE
   */
  public async deleteAlertBot(boundaryId: UUID, boundaryAlertBotId: UUID): Promise<void> {
    // verify required parameter 'boundaryId' is not null or undefined
    if (boundaryId === null || boundaryId === undefined) {
      throw new ParameterRequiredError('boundaryId');
    }
    // verify required parameter 'boundaryAlertBotId' is not null or undefined
    if (boundaryAlertBotId === null || boundaryAlertBotId === undefined) {
      throw new ParameterRequiredError('boundaryAlertBotId');
    }
    return this.producer.deleteAlertBot(boundaryId, boundaryAlertBotId);
  }
  /**
   * Delete boundary party role
   * @summary Delete boundary party role
   * @param boundaryId 
   * @param roleId 
   * @param partyId 
   * @openapi operation=deleteBoundaryPartyRole path=/app/boundaries/{boundaryId}/parties/{partyId}/roles/{roleId} method=DELETE
   */
  public async deleteBoundaryPartyRole(boundaryId: UUID, roleId: UUID, partyId: UUID): Promise<void> {
    // verify required parameter 'boundaryId' is not null or undefined
    if (boundaryId === null || boundaryId === undefined) {
      throw new ParameterRequiredError('boundaryId');
    }
    // verify required parameter 'roleId' is not null or undefined
    if (roleId === null || roleId === undefined) {
      throw new ParameterRequiredError('roleId');
    }
    // verify required parameter 'partyId' is not null or undefined
    if (partyId === null || partyId === undefined) {
      throw new ParameterRequiredError('partyId');
    }
    return this.producer.deleteBoundaryPartyRole(boundaryId, roleId, partyId);
  }
  /**
   * Delete boundary party roles by boundary id
   * @summary Delete boundary party roles by boundary id
   * @param boundaryId 
   * @openapi operation=deleteBoundaryPartyRoles path=/app/boundaries/{boundaryId}/partyRoles method=DELETE
   */
  public async deleteBoundaryPartyRoles(boundaryId: UUID): Promise<void> {
    // verify required parameter 'boundaryId' is not null or undefined
    if (boundaryId === null || boundaryId === undefined) {
      throw new ParameterRequiredError('boundaryId');
    }
    return this.producer.deleteBoundaryPartyRoles(boundaryId);
  }
  /**
   * Deletes target for a boundary product
   * @summary Deletes target for a boundary product
   * @param boundaryId 
   * @param boundaryProductId 
   * @param deleteBoundaryProductTarget 
   * @openapi operation=deleteBoundaryProductTargets path=/boundaries/{boundaryId}/products/{boundaryProductId}/targets method=DELETE
   */
  public async deleteBoundaryProductTargets(boundaryId: UUID, boundaryProductId: UUID, deleteBoundaryProductTarget: DeleteBoundaryProductTarget): Promise<BoundaryProductTargetProcessedResponse> {
    // verify required parameter 'boundaryId' is not null or undefined
    if (boundaryId === null || boundaryId === undefined) {
      throw new ParameterRequiredError('boundaryId');
    }
    // verify required parameter 'boundaryProductId' is not null or undefined
    if (boundaryProductId === null || boundaryProductId === undefined) {
      throw new ParameterRequiredError('boundaryProductId');
    }
    // verify required parameter 'deleteBoundaryProductTarget' is not null or undefined
    if (deleteBoundaryProductTarget === null || deleteBoundaryProductTarget === undefined) {
      throw new ParameterRequiredError('deleteBoundaryProductTarget');
    }
    return this.producer.deleteBoundaryProductTargets(boundaryId, boundaryProductId, deleteBoundaryProductTarget);
  }
  /**
   * Deletes products for a boundary
   * @summary Deletes products for a boundary
   * @param boundaryId 
   * @param deleteBoundaryProduct 
   * @openapi operation=deleteBoundaryProducts path=/boundaries/{boundaryId}/products method=DELETE
   */
  public async deleteBoundaryProducts(boundaryId: UUID, deleteBoundaryProduct: DeleteBoundaryProduct): Promise<BoundaryProductProcessedResponse> {
    // verify required parameter 'boundaryId' is not null or undefined
    if (boundaryId === null || boundaryId === undefined) {
      throw new ParameterRequiredError('boundaryId');
    }
    // verify required parameter 'deleteBoundaryProduct' is not null or undefined
    if (deleteBoundaryProduct === null || deleteBoundaryProduct === undefined) {
      throw new ParameterRequiredError('deleteBoundaryProduct');
    }
    return this.producer.deleteBoundaryProducts(boundaryId, deleteBoundaryProduct);
  }
  /**
   * Deletes a boundary team
   * @summary Deletes a boundary team
   * @param boundaryId 
   * @param teamId 
   * @openapi operation=deleteBoundaryTeam path=/boundaries/{boundaryId}/teams/{teamId} method=DELETE
   */
  public async deleteBoundaryTeam(boundaryId: UUID, teamId: UUID): Promise<void> {
    // verify required parameter 'boundaryId' is not null or undefined
    if (boundaryId === null || boundaryId === undefined) {
      throw new ParameterRequiredError('boundaryId');
    }
    // verify required parameter 'teamId' is not null or undefined
    if (teamId === null || teamId === undefined) {
      throw new ParameterRequiredError('teamId');
    }
    return this.producer.deleteBoundaryTeam(boundaryId, teamId);
  }
  /**
   * Deletes events for a boundary
   * @summary Deletes events for a boundary
   * @param boundaryId 
   * @openapi operation=deleteEventsForBoundary path=/boundaries/{boundaryId}/events method=DELETE
   */
  public async deleteEventsForBoundary(boundaryId: UUID): Promise<void> {
    // verify required parameter 'boundaryId' is not null or undefined
    if (boundaryId === null || boundaryId === undefined) {
      throw new ParameterRequiredError('boundaryId');
    }
    return this.producer.deleteEventsForBoundary(boundaryId);
  }
  /**
   * Disables a boundary team scf control evidence definition implementation
   * @summary Disables a boundary team scf control evidence definition implementation
   * @param boundaryId 
   * @param teamId 
   * @param scfControlId 
   * @param evidenceDefinitionId 
   * @openapi operation=disableBoundaryTeamScfControlEvidenceDefinition path=/boundaries/{boundaryId}/teams/{teamId}/scfControlTree/{scfControlId}/evidenceDefinitions/{evidenceDefinitionId} method=DELETE
   */
  public async disableBoundaryTeamScfControlEvidenceDefinition(boundaryId: UUID, teamId: UUID, scfControlId: UUID, evidenceDefinitionId: UUID): Promise<void> {
    // verify required parameter 'boundaryId' is not null or undefined
    if (boundaryId === null || boundaryId === undefined) {
      throw new ParameterRequiredError('boundaryId');
    }
    // verify required parameter 'teamId' is not null or undefined
    if (teamId === null || teamId === undefined) {
      throw new ParameterRequiredError('teamId');
    }
    // verify required parameter 'scfControlId' is not null or undefined
    if (scfControlId === null || scfControlId === undefined) {
      throw new ParameterRequiredError('scfControlId');
    }
    // verify required parameter 'evidenceDefinitionId' is not null or undefined
    if (evidenceDefinitionId === null || evidenceDefinitionId === undefined) {
      throw new ParameterRequiredError('evidenceDefinitionId');
    }
    return this.producer.disableBoundaryTeamScfControlEvidenceDefinition(boundaryId, teamId, scfControlId, evidenceDefinitionId);
  }
  /**
   * Enables a boundary team scf control evidence definition implementation
   * @summary Enables a boundary team scf control evidence definition implementation
   * @param boundaryId 
   * @param teamId 
   * @param scfControlId 
   * @param enableBoundaryTeamScfControlEvidenceDefinition 
   * @openapi operation=enableBoundaryTeamScfControlEvidenceDefinition path=/boundaries/{boundaryId}/teams/{teamId}/scfControlTree/{scfControlId}/evidenceDefinitions method=POST
   */
  public async enableBoundaryTeamScfControlEvidenceDefinition(boundaryId: UUID, teamId: UUID, scfControlId: UUID, enableBoundaryTeamScfControlEvidenceDefinition: EnableBoundaryTeamScfControlEvidenceDefinition): Promise<BoundaryTeamScfControlEvidenceDefinitionImplementation> {
    // verify required parameter 'boundaryId' is not null or undefined
    if (boundaryId === null || boundaryId === undefined) {
      throw new ParameterRequiredError('boundaryId');
    }
    // verify required parameter 'teamId' is not null or undefined
    if (teamId === null || teamId === undefined) {
      throw new ParameterRequiredError('teamId');
    }
    // verify required parameter 'scfControlId' is not null or undefined
    if (scfControlId === null || scfControlId === undefined) {
      throw new ParameterRequiredError('scfControlId');
    }
    // verify required parameter 'enableBoundaryTeamScfControlEvidenceDefinition' is not null or undefined
    if (enableBoundaryTeamScfControlEvidenceDefinition === null || enableBoundaryTeamScfControlEvidenceDefinition === undefined) {
      throw new ParameterRequiredError('enableBoundaryTeamScfControlEvidenceDefinition');
    }
    return this.producer.enableBoundaryTeamScfControlEvidenceDefinition(boundaryId, teamId, scfControlId, enableBoundaryTeamScfControlEvidenceDefinition);
  }
  /**
   * Retrieves a boundary product
   * @summary Retrieves a boundary product
   * @param boundaryId 
   * @param boundaryProductId 
   * @openapi operation=getAnyBoundaryProduct path=/boundaries/{boundaryId}/allProducts/{boundaryProductId} method=GET
   */
  public async getAnyBoundaryProduct(boundaryId: UUID, boundaryProductId: UUID): Promise<BoundaryProductAny> {
    // verify required parameter 'boundaryId' is not null or undefined
    if (boundaryId === null || boundaryId === undefined) {
      throw new ParameterRequiredError('boundaryId');
    }
    // verify required parameter 'boundaryProductId' is not null or undefined
    if (boundaryProductId === null || boundaryProductId === undefined) {
      throw new ParameterRequiredError('boundaryProductId');
    }
    return this.producer.getAnyBoundaryProduct(boundaryId, boundaryProductId);
  }
  /**
   * Retrieves a boundary
   * @summary Retrieves a boundary
   * @param boundaryId 
   * @openapi operation=getBoundary path=/boundaries/{boundaryId} method=GET
   */
  public async getBoundary(boundaryId: UUID): Promise<BoundaryExtended> {
    // verify required parameter 'boundaryId' is not null or undefined
    if (boundaryId === null || boundaryId === undefined) {
      throw new ParameterRequiredError('boundaryId');
    }
    return this.producer.getBoundary(boundaryId);
  }
  /**
   * 
   * @summary Retrieves extended information about a boundary alert
   * @param boundaryId The ID of the boundary
   * @param id The ID of the alert to fetch
   * @openapi operation=getBoundaryAlert path=/app/boundaries/{boundaryId}/alerts/{id} method=GET
   */
  public async getBoundaryAlert(boundaryId: UUID, id: UUID): Promise<BoundaryAlertExtended> {
    // verify required parameter 'boundaryId' is not null or undefined
    if (boundaryId === null || boundaryId === undefined) {
      throw new ParameterRequiredError('boundaryId');
    }
    // verify required parameter 'id' is not null or undefined
    if (id === null || id === undefined) {
      throw new ParameterRequiredError('id');
    }
    return this.producer.getBoundaryAlert(boundaryId, id);
  }
  /**
   * Get boundary component
   * @summary Get boundary component
   * @param boundaryId 
   * @param componentId 
   * @openapi operation=getBoundaryComponent path=/app/boundaries/{boundaryId}/components/{componentId} method=GET
   */
  public async getBoundaryComponent(boundaryId: UUID, componentId: UUID): Promise<BoundaryComponentExtended> {
    // verify required parameter 'boundaryId' is not null or undefined
    if (boundaryId === null || boundaryId === undefined) {
      throw new ParameterRequiredError('boundaryId');
    }
    // verify required parameter 'componentId' is not null or undefined
    if (componentId === null || componentId === undefined) {
      throw new ParameterRequiredError('componentId');
    }
    return this.producer.getBoundaryComponent(boundaryId, componentId);
  }
  /**
   * Retrieves a boundary product
   * @summary Retrieves a boundary product
   * @param boundaryId 
   * @param connectionId 
   * @openapi operation=getBoundaryConnectionOverview path=/boundaries/{boundaryId}/connections/{connectionId} method=GET
   */
  public async getBoundaryConnectionOverview(boundaryId: UUID, connectionId: UUID): Promise<BoundaryConnectionOverview> {
    // verify required parameter 'boundaryId' is not null or undefined
    if (boundaryId === null || boundaryId === undefined) {
      throw new ParameterRequiredError('boundaryId');
    }
    // verify required parameter 'connectionId' is not null or undefined
    if (connectionId === null || connectionId === undefined) {
      throw new ParameterRequiredError('connectionId');
    }
    return this.producer.getBoundaryConnectionOverview(boundaryId, connectionId);
  }
  /**
   * Retrieves domains summary info for a boundary
   * @summary Retrieves domains summary info for a boundary
   * @param boundaryId 
   * @param sourceId 
   * @openapi operation=getBoundaryDomainSummary path=/boundaries/{boundaryId}/domains method=GET
   */
  public async getBoundaryDomainSummary(boundaryId: UUID, sourceId?: UUID): Promise<BoundaryDomainSummary> {
    // verify required parameter 'boundaryId' is not null or undefined
    if (boundaryId === null || boundaryId === undefined) {
      throw new ParameterRequiredError('boundaryId');
    }
    return this.producer.getBoundaryDomainSummary(boundaryId, sourceId);
  }
  /**
   * Retrieves a boundary evidence record
   * @summary Retrieves a boundary evidence record
   * @param boundaryId 
   * @param evidenceId 
   * @openapi operation=getBoundaryEvidence path=/boundaries/{boundaryId}/evidence/{evidenceId} method=GET
   */
  public async getBoundaryEvidence(boundaryId: UUID, evidenceId: UUID): Promise<BoundaryEvidence & ExtendedBoundaryEvidence> {
    // verify required parameter 'boundaryId' is not null or undefined
    if (boundaryId === null || boundaryId === undefined) {
      throw new ParameterRequiredError('boundaryId');
    }
    // verify required parameter 'evidenceId' is not null or undefined
    if (evidenceId === null || evidenceId === undefined) {
      throw new ParameterRequiredError('evidenceId');
    }
    return this.producer.getBoundaryEvidence(boundaryId, evidenceId);
  }
  /**
   * Retrieves metrics of the data for a specific boundary
   * @summary Retrieves metrics of the data for a specific boundary
   * @param boundaryId 
   * @openapi operation=getBoundaryMetrics path=/boundaries/{boundaryId}/metrics method=GET
   */
  public async getBoundaryMetrics(boundaryId: UUID): Promise<BoundaryMetric> {
    // verify required parameter 'boundaryId' is not null or undefined
    if (boundaryId === null || boundaryId === undefined) {
      throw new ParameterRequiredError('boundaryId');
    }
    return this.producer.getBoundaryMetrics(boundaryId);
  }
  /**
   * Retrieves a party for a boundary
   * @summary Retrieves a party for a boundary
   * @param boundaryId 
   * @param partyId 
   * @openapi operation=getBoundaryParty path=/boundaries/{boundaryId}/parties/{partyId} method=GET
   */
  public async getBoundaryParty(boundaryId: UUID, partyId: UUID): Promise<PartyExtended> {
    // verify required parameter 'boundaryId' is not null or undefined
    if (boundaryId === null || boundaryId === undefined) {
      throw new ParameterRequiredError('boundaryId');
    }
    // verify required parameter 'partyId' is not null or undefined
    if (partyId === null || partyId === undefined) {
      throw new ParameterRequiredError('partyId');
    }
    return this.producer.getBoundaryParty(boundaryId, partyId);
  }
  /**
   * Get boundary party role
   * @summary Get boundary party role
   * @param boundaryId 
   * @param roleId 
   * @param partyId 
   * @openapi operation=getBoundaryPartyRole path=/app/boundaries/{boundaryId}/parties/{partyId}/roles/{roleId} method=GET
   */
  public async getBoundaryPartyRole(boundaryId: UUID, roleId: UUID, partyId: UUID): Promise<BoundaryPartyRoleExtended> {
    // verify required parameter 'boundaryId' is not null or undefined
    if (boundaryId === null || boundaryId === undefined) {
      throw new ParameterRequiredError('boundaryId');
    }
    // verify required parameter 'roleId' is not null or undefined
    if (roleId === null || roleId === undefined) {
      throw new ParameterRequiredError('roleId');
    }
    // verify required parameter 'partyId' is not null or undefined
    if (partyId === null || partyId === undefined) {
      throw new ParameterRequiredError('partyId');
    }
    return this.producer.getBoundaryPartyRole(boundaryId, roleId, partyId);
  }
  /**
   * Retrieves a boundary product
   * @summary Retrieves a boundary product
   * @param boundaryId 
   * @param boundaryProductId 
   * @openapi operation=getBoundaryProduct path=/boundaries/{boundaryId}/products/{boundaryProductId} method=GET
   */
  public async getBoundaryProduct(boundaryId: UUID, boundaryProductId: UUID): Promise<BoundaryProduct & ExtendedBoundaryProduct> {
    // verify required parameter 'boundaryId' is not null or undefined
    if (boundaryId === null || boundaryId === undefined) {
      throw new ParameterRequiredError('boundaryId');
    }
    // verify required parameter 'boundaryProductId' is not null or undefined
    if (boundaryProductId === null || boundaryProductId === undefined) {
      throw new ParameterRequiredError('boundaryProductId');
    }
    return this.producer.getBoundaryProduct(boundaryId, boundaryProductId);
  }
  /**
   * Retrieves a boundary product
   * @summary Retrieves a boundary product
   * @param boundaryId 
   * @param boundaryProductId 
   * @param connectionId 
   * @openapi operation=getBoundaryProductConnectionOverview path=/boundaries/{boundaryId}/products/{boundaryProductId}/connections/{connectionId} method=GET
   */
  public async getBoundaryProductConnectionOverview(boundaryId: UUID, boundaryProductId: UUID, connectionId: UUID): Promise<BoundaryConnectionOverview> {
    // verify required parameter 'boundaryId' is not null or undefined
    if (boundaryId === null || boundaryId === undefined) {
      throw new ParameterRequiredError('boundaryId');
    }
    // verify required parameter 'boundaryProductId' is not null or undefined
    if (boundaryProductId === null || boundaryProductId === undefined) {
      throw new ParameterRequiredError('boundaryProductId');
    }
    // verify required parameter 'connectionId' is not null or undefined
    if (connectionId === null || connectionId === undefined) {
      throw new ParameterRequiredError('connectionId');
    }
    return this.producer.getBoundaryProductConnectionOverview(boundaryId, boundaryProductId, connectionId);
  }
  /**
   * Retrieves a boundary product overview
   * @summary Retrieves a boundary product overview
   * @param boundaryId 
   * @param boundaryProductId 
   * @openapi operation=getBoundaryProductOverview path=/boundaries/{boundaryId}/products/{boundaryProductId}/overviews method=GET
   */
  public async getBoundaryProductOverview(boundaryId: UUID, boundaryProductId: UUID): Promise<BoundaryProductOverview> {
    // verify required parameter 'boundaryId' is not null or undefined
    if (boundaryId === null || boundaryId === undefined) {
      throw new ParameterRequiredError('boundaryId');
    }
    // verify required parameter 'boundaryProductId' is not null or undefined
    if (boundaryProductId === null || boundaryProductId === undefined) {
      throw new ParameterRequiredError('boundaryProductId');
    }
    return this.producer.getBoundaryProductOverview(boundaryId, boundaryProductId);
  }
  /**
   * Retrieves a scf control for a boundary
   * @summary Retrieves a scf control for a boundary
   * @param boundaryId 
   * @param boundaryScfControlId 
   * @openapi operation=getBoundaryScfControl path=/boundaries/{boundaryId}/scfControls/{boundaryScfControlId} method=GET
   */
  public async getBoundaryScfControl(boundaryId: UUID, boundaryScfControlId: UUID): Promise<ExtendedBoundaryScfControl> {
    // verify required parameter 'boundaryId' is not null or undefined
    if (boundaryId === null || boundaryId === undefined) {
      throw new ParameterRequiredError('boundaryId');
    }
    // verify required parameter 'boundaryScfControlId' is not null or undefined
    if (boundaryScfControlId === null || boundaryScfControlId === undefined) {
      throw new ParameterRequiredError('boundaryScfControlId');
    }
    return this.producer.getBoundaryScfControl(boundaryId, boundaryScfControlId);
  }
  /**
   * Get standard baseline that has been added to a boundary
   * @summary Get standard baseline that has been added to a boundary
   * @param boundaryId 
   * @param boundaryStandardBaselineId 
   * @openapi operation=getBoundaryStandardBaseline path=/app/boundaries/{boundaryId}/standardBaselines/{boundaryStandardBaselineId} method=GET
   */
  public async getStandardBaseline(boundaryId: UUID, boundaryStandardBaselineId: UUID): Promise<BoundaryStandardBaselineExtended> {
    // verify required parameter 'boundaryId' is not null or undefined
    if (boundaryId === null || boundaryId === undefined) {
      throw new ParameterRequiredError('boundaryId');
    }
    // verify required parameter 'boundaryStandardBaselineId' is not null or undefined
    if (boundaryStandardBaselineId === null || boundaryStandardBaselineId === undefined) {
      throw new ParameterRequiredError('boundaryStandardBaselineId');
    }
    return this.producer.getStandardBaseline(boundaryId, boundaryStandardBaselineId);
  }
  /**
   * Get element by standard and baseline and element id
   * @summary Get element by standard and baseline and element id
   * @param boundaryId 
   * @param boundaryStandardBaselineId 
   * @openapi operation=getBoundaryStandardBaselineFilterTree path=/app/boundaries/{boundaryId}/standardBaselines/{boundaryStandardBaselineId}/filterTree method=GET
   */
  public async getStandardBaselineFilterTree(boundaryId: UUID, boundaryStandardBaselineId: UUID): Promise<{ [key: string]: StandardFilterTreeNode; }> {
    // verify required parameter 'boundaryId' is not null or undefined
    if (boundaryId === null || boundaryId === undefined) {
      throw new ParameterRequiredError('boundaryId');
    }
    // verify required parameter 'boundaryStandardBaselineId' is not null or undefined
    if (boundaryStandardBaselineId === null || boundaryStandardBaselineId === undefined) {
      throw new ParameterRequiredError('boundaryStandardBaselineId');
    }
    return this.producer.getStandardBaselineFilterTree(boundaryId, boundaryStandardBaselineId);
  }
  /**
   * Retrieves a boundary suggested product overview
   * @summary Retrieves a boundary suggested product overview
   * @param boundaryId 
   * @param boundarySuggestedProductId 
   * @openapi operation=getBoundarySuggestedProductOverview path=/boundaries/{boundaryId}/suggestedProducts/{boundarySuggestedProductId}/overviews method=GET
   */
  public async getBoundarySuggestedProductOverview(boundaryId: UUID, boundarySuggestedProductId: UUID): Promise<BoundarySuggestedProductOverview> {
    // verify required parameter 'boundaryId' is not null or undefined
    if (boundaryId === null || boundaryId === undefined) {
      throw new ParameterRequiredError('boundaryId');
    }
    // verify required parameter 'boundarySuggestedProductId' is not null or undefined
    if (boundarySuggestedProductId === null || boundarySuggestedProductId === undefined) {
      throw new ParameterRequiredError('boundarySuggestedProductId');
    }
    return this.producer.getBoundarySuggestedProductOverview(boundaryId, boundarySuggestedProductId);
  }
  /**
   * Retrieves task metrics for a specific boundary
   * @summary Retrieves task metrics for a specific boundary
   * @param boundaryId 
   * @param pageNumber The requested page. This value is 1-indexed.
   * @param pageSize The number of items in each page of data.
   * @openapi operation=getBoundaryTaskMetrics path=/boundaries/{boundaryId}/taskMetrics method=GET
   */
  public async getBoundaryTaskMetrics(boundaryId: UUID, pageNumber: number = 1, pageSize: number = 50): Promise<BoundaryTaskMetrics> {
    // verify required parameter 'boundaryId' is not null or undefined
    if (boundaryId === null || boundaryId === undefined) {
      throw new ParameterRequiredError('boundaryId');
    }
    if (pageNumber) {
      await Int32.parse(pageNumber);
    }
    if (pageSize) {
      await Int32.parse(pageSize);
    }
    return this.producer.getBoundaryTaskMetrics(boundaryId, pageNumber, pageSize);
  }
  /**
   * Retrieves a team for a boundary
   * @summary Retrieves a team for a boundary
   * @param boundaryId 
   * @param teamId 
   * @openapi operation=getBoundaryTeam path=/boundaries/{boundaryId}/teams/{teamId} method=GET
   */
  public async getBoundaryTeam(boundaryId: UUID, teamId: UUID): Promise<BoundaryTeam> {
    // verify required parameter 'boundaryId' is not null or undefined
    if (boundaryId === null || boundaryId === undefined) {
      throw new ParameterRequiredError('boundaryId');
    }
    // verify required parameter 'teamId' is not null or undefined
    if (teamId === null || teamId === undefined) {
      throw new ParameterRequiredError('teamId');
    }
    return this.producer.getBoundaryTeam(boundaryId, teamId);
  }
  /**
   * Retrieves domains summary info for a boundary team
   * @summary Retrieves domains summary info for a boundary team
   * @param boundaryId 
   * @param teamId 
   * @param sourceId 
   * @openapi operation=getBoundaryTeamDomainSummary path=/boundaries/{boundaryId}/teams/{teamId}/domains method=GET
   */
  public async getBoundaryTeamDomainSummary(boundaryId: UUID, teamId: UUID, sourceId?: UUID): Promise<BoundaryTeamDomainSummary> {
    // verify required parameter 'boundaryId' is not null or undefined
    if (boundaryId === null || boundaryId === undefined) {
      throw new ParameterRequiredError('boundaryId');
    }
    // verify required parameter 'teamId' is not null or undefined
    if (teamId === null || teamId === undefined) {
      throw new ParameterRequiredError('teamId');
    }
    return this.producer.getBoundaryTeamDomainSummary(boundaryId, teamId, sourceId);
  }
  /**
   * Retrieves a teams metrics for a boundary
   * @summary Retrieves a teams metrics for a boundary
   * @param boundaryId 
   * @param teamId 
   * @openapi operation=getBoundaryTeamMetric path=/boundaries/{boundaryId}/teamMetrics/{teamId} method=GET
   */
  public async getBoundaryTeamMetric(boundaryId: UUID, teamId: UUID): Promise<BoundaryTeamMetrics> {
    // verify required parameter 'boundaryId' is not null or undefined
    if (boundaryId === null || boundaryId === undefined) {
      throw new ParameterRequiredError('boundaryId');
    }
    // verify required parameter 'teamId' is not null or undefined
    if (teamId === null || teamId === undefined) {
      throw new ParameterRequiredError('teamId');
    }
    return this.producer.getBoundaryTeamMetric(boundaryId, teamId);
  }
  /**
   * Retrieves scf control data for a boundary team
   * @summary Retrieves scf control data for a boundary team
   * @param boundaryId 
   * @param teamId 
   * @param scfControlId 
   * @openapi operation=getBoundaryTeamScfControl path=/boundaries/{boundaryId}/teams/{teamId}/scfControls/{scfControlId} method=GET
   */
  public async getBoundaryTeamScfControl(boundaryId: UUID, teamId: UUID, scfControlId: UUID): Promise<BoundaryTeamScfControl> {
    // verify required parameter 'boundaryId' is not null or undefined
    if (boundaryId === null || boundaryId === undefined) {
      throw new ParameterRequiredError('boundaryId');
    }
    // verify required parameter 'teamId' is not null or undefined
    if (teamId === null || teamId === undefined) {
      throw new ParameterRequiredError('teamId');
    }
    // verify required parameter 'scfControlId' is not null or undefined
    if (scfControlId === null || scfControlId === undefined) {
      throw new ParameterRequiredError('scfControlId');
    }
    return this.producer.getBoundaryTeamScfControl(boundaryId, teamId, scfControlId);
  }
  /**
   * Retrieves a scf control defailts within a boundary team
   * @summary Retrieves a scf control defailts within a boundary team
   * @param boundaryId 
   * @param teamId 
   * @param scfControlId 
   * @openapi operation=getBoundaryTeamScfControlDetails path=/boundaries/{boundaryId}/teams/{teamId}/scfControlTree/{scfControlId} method=GET
   */
  public async getBoundaryTeamScfControlDetails(boundaryId: UUID, teamId: UUID, scfControlId: UUID): Promise<BoundaryTeamScfControlOverview> {
    // verify required parameter 'boundaryId' is not null or undefined
    if (boundaryId === null || boundaryId === undefined) {
      throw new ParameterRequiredError('boundaryId');
    }
    // verify required parameter 'teamId' is not null or undefined
    if (teamId === null || teamId === undefined) {
      throw new ParameterRequiredError('teamId');
    }
    // verify required parameter 'scfControlId' is not null or undefined
    if (scfControlId === null || scfControlId === undefined) {
      throw new ParameterRequiredError('scfControlId');
    }
    return this.producer.getBoundaryTeamScfControlDetails(boundaryId, teamId, scfControlId);
  }
  /**
   * Retrieves a list of scf controls for a boundary in a tree form
   * @summary Retrieves a list of scf controls for a boundary in a tree form
   * @param boundaryId 
   * @param teamId 
   * @param frameworkVersionId 
   * @openapi operation=getBoundaryTeamScfControlOverview path=/boundaries/{boundaryId}/teams/{teamId}/scfControlOverview method=GET
   */
  public async getBoundaryTeamScfControlOverview(boundaryId: UUID, teamId: UUID, frameworkVersionId?: UUID): Promise<BoundaryFrameworkControlsOverview> {
    // verify required parameter 'boundaryId' is not null or undefined
    if (boundaryId === null || boundaryId === undefined) {
      throw new ParameterRequiredError('boundaryId');
    }
    // verify required parameter 'teamId' is not null or undefined
    if (teamId === null || teamId === undefined) {
      throw new ParameterRequiredError('teamId');
    }
    return this.producer.getBoundaryTeamScfControlOverview(boundaryId, teamId, frameworkVersionId);
  }
  /**
   * Retrieves a list of scf controls for a boundary in a tree form
   * @summary Retrieves a list of scf controls for a boundary in a tree form
   * @param boundaryId 
   * @param teamId 
   * @param frameworkVersionId 
   * @openapi operation=getBoundaryTeamScfControlTree path=/boundaries/{boundaryId}/teams/{teamId}/scfControlTree method=GET
   */
  public async getBoundaryTeamScfControlTree(boundaryId: UUID, teamId: UUID, frameworkVersionId?: UUID): Promise<{ [key: string]: BoundaryFrameworkControlTreeNode; }> {
    // verify required parameter 'boundaryId' is not null or undefined
    if (boundaryId === null || boundaryId === undefined) {
      throw new ParameterRequiredError('boundaryId');
    }
    // verify required parameter 'teamId' is not null or undefined
    if (teamId === null || teamId === undefined) {
      throw new ParameterRequiredError('teamId');
    }
    return this.producer.getBoundaryTeamScfControlTree(boundaryId, teamId, frameworkVersionId);
  }
  /**
   * List test within a boundary by id
   * @summary List test within a boundary by id
   * @param boundaryId 
   * @param testId 
   * @openapi operation=getBoundaryTest path=/app/boundaries/{boundaryId}/tests/{testId} method=GET
   */
  public async getTest(boundaryId: UUID, testId: UUID): Promise<TestExtended> {
    // verify required parameter 'boundaryId' is not null or undefined
    if (boundaryId === null || boundaryId === undefined) {
      throw new ParameterRequiredError('boundaryId');
    }
    // verify required parameter 'testId' is not null or undefined
    if (testId === null || testId === undefined) {
      throw new ParameterRequiredError('testId');
    }
    return this.producer.getTest(boundaryId, testId);
  }
  /**
   * Retrieves a list of all products for a boundary
   * @summary Retrieves a list of all products for a boundary
   * @param boundaryId 
   * @param pageNumber The requested page. This value is 1-indexed.
   * @param pageSize The number of items in each page of data.
   * @param keywords Search like filter
   * @param status Search like filter
   * @param sort Sort object
   * @openapi operation=listAllBoundaryProducts path=/boundaries/{boundaryId}/allProducts method=GET
   */
  public async listAllBoundaryProducts(boundaryId: UUID, pageNumber: number = 1, pageSize: number = 50, keywords?: string, status?: BoundaryProductForListStatusDef, sort?: SortObject): Promise<PagedResults<BoundaryProductForList>> {
    // verify required parameter 'boundaryId' is not null or undefined
    if (boundaryId === null || boundaryId === undefined) {
      throw new ParameterRequiredError('boundaryId');
    }
    if (pageNumber) {
      await Int32.parse(pageNumber);
    }
    if (pageSize) {
      await Int32.parse(pageSize);
    }
    const bag = new PagedResults<BoundaryProductForList>();
    bag.pageNumber = pageNumber;
    bag.pageSize = pageSize;
    await this.producer.listAllBoundaryProducts(bag, boundaryId, keywords, status, sort);
    if (bag.items === null || bag.items === undefined) {
      throw new UnexpectedError("Producers must return 'items' for PagedResults queries");
    }
    return bag;
  }
  /**
   * Retrieves a list of all boundaries
   * @summary Retrieves a list of all boundaries
   * @param pageNumber The requested page. This value is 1-indexed.
   * @param pageSize The number of items in each page of data.
   * @param name Filter by name
   * @param status Filter by status
   * @param type Filter by type
   * @param sort Sort object
   * @openapi operation=listBoundaries path=/boundaries method=GET
   */
  public async listBoundaries(pageNumber: number = 1, pageSize: number = 50, name?: string, status?: BoundaryStatusEnumDef, type?: BoundaryTypeEnumDef, sort?: SortObject): Promise<PagedResults<BoundaryExtended>> {
    if (pageNumber) {
      await Int32.parse(pageNumber);
    }
    if (pageSize) {
      await Int32.parse(pageSize);
    }
    const bag = new PagedResults<BoundaryExtended>();
    bag.pageNumber = pageNumber;
    bag.pageSize = pageSize;
    await this.producer.listBoundaries(bag, name, status, type, sort);
    if (bag.items === null || bag.items === undefined) {
      throw new UnexpectedError("Producers must return 'items' for PagedResults queries");
    }
    return bag;
  }
  /**
   * List alerts raised by this bot
   * @summary List alerts raised by this bot
   * @param boundaryId 
   * @param boundaryAlertBotId 
   * @param pageNumber The requested page. This value is 1-indexed.
   * @param pageSize The number of items in each page of data.
   * @param sort Sort object
   * @openapi operation=listBoundaryAlertBotAlerts path=/app/boundaries/{boundaryId}/alertBots/{boundaryAlertBotId}/alerts method=GET
   */
  public async listAlertBotAlerts(boundaryId: UUID, boundaryAlertBotId: UUID, pageNumber: number = 1, pageSize: number = 50, sort?: SortObject): Promise<PagedResults<BoundaryAlertView>> {
    // verify required parameter 'boundaryId' is not null or undefined
    if (boundaryId === null || boundaryId === undefined) {
      throw new ParameterRequiredError('boundaryId');
    }
    // verify required parameter 'boundaryAlertBotId' is not null or undefined
    if (boundaryAlertBotId === null || boundaryAlertBotId === undefined) {
      throw new ParameterRequiredError('boundaryAlertBotId');
    }
    if (pageNumber) {
      await Int32.parse(pageNumber);
    }
    if (pageSize) {
      await Int32.parse(pageSize);
    }
    const bag = new PagedResults<BoundaryAlertView>();
    bag.pageNumber = pageNumber;
    bag.pageSize = pageSize;
    await this.producer.listAlertBotAlerts(bag, boundaryId, boundaryAlertBotId, sort);
    if (bag.items === null || bag.items === undefined) {
      throw new UnexpectedError("Producers must return 'items' for PagedResults queries");
    }
    return bag;
  }
  /**
   * 
   * @summary Retrieves subjects that may be associated with a Boundary Alert
   * @param boundaryId The ID of the boundary
   * @param id The ID of the alert
   * @param pageNumber The requested page. This value is 1-indexed.
   * @param pageSize The number of items in each page of data.
   * @param sort Sort object
   * @openapi operation=listBoundaryAlertSubjects path=/app/boundaries/{boundaryId}/alerts/{id}/subjects method=GET
   */
  public async listBoundaryAlertSubjects(boundaryId: UUID, id: UUID, pageNumber: number = 1, pageSize: number = 50, sort?: SortObject): Promise<PagedResults<BoundaryAlertSubjectExtended>> {
    // verify required parameter 'boundaryId' is not null or undefined
    if (boundaryId === null || boundaryId === undefined) {
      throw new ParameterRequiredError('boundaryId');
    }
    // verify required parameter 'id' is not null or undefined
    if (id === null || id === undefined) {
      throw new ParameterRequiredError('id');
    }
    if (pageNumber) {
      await Int32.parse(pageNumber);
    }
    if (pageSize) {
      await Int32.parse(pageSize);
    }
    const bag = new PagedResults<BoundaryAlertSubjectExtended>();
    bag.pageNumber = pageNumber;
    bag.pageSize = pageSize;
    await this.producer.listBoundaryAlertSubjects(bag, boundaryId, id, sort);
    if (bag.items === null || bag.items === undefined) {
      throw new UnexpectedError("Producers must return 'items' for PagedResults queries");
    }
    return bag;
  }
  /**
   * List boundary alert bots subscriptions
   * @summary List boundary alert bots subscriptions
   * @param boundaryAlertBotId 
   * @param boundaryId 
   * @param pageNumber The requested page. This value is 1-indexed.
   * @param pageSize The number of items in each page of data.
   * @param sort Sort object
   * @openapi operation=listBoundaryAlertbotSubscriptions path=/app/boundaries/{boundaryId}/alertBots/{boundaryAlertBotId}/subscriptions method=GET
   */
  public async listAlertBotSubscriptions(boundaryAlertBotId: UUID, boundaryId: UUID, pageNumber: number = 1, pageSize: number = 50, sort?: SortObject): Promise<PagedResults<AlertSubscriptionExtended>> {
    // verify required parameter 'boundaryAlertBotId' is not null or undefined
    if (boundaryAlertBotId === null || boundaryAlertBotId === undefined) {
      throw new ParameterRequiredError('boundaryAlertBotId');
    }
    // verify required parameter 'boundaryId' is not null or undefined
    if (boundaryId === null || boundaryId === undefined) {
      throw new ParameterRequiredError('boundaryId');
    }
    if (pageNumber) {
      await Int32.parse(pageNumber);
    }
    if (pageSize) {
      await Int32.parse(pageSize);
    }
    const bag = new PagedResults<AlertSubscriptionExtended>();
    bag.pageNumber = pageNumber;
    bag.pageSize = pageSize;
    await this.producer.listAlertBotSubscriptions(bag, boundaryAlertBotId, boundaryId, sort);
    if (bag.items === null || bag.items === undefined) {
      throw new UnexpectedError("Producers must return 'items' for PagedResults queries");
    }
    return bag;
  }
  /**
   * List boundary alert bots
   * @summary List boundary alert bots
   * @param boundaryId 
   * @param pageNumber The requested page. This value is 1-indexed.
   * @param pageSize The number of items in each page of data.
   * @param queryId 
   * @param queryVersionId 
   * @param sort Sort object
   * @openapi operation=listBoundaryAlertbots path=/app/boundaries/{boundaryId}/alertBots method=GET
   */
  public async listAlertBots(boundaryId: UUID, pageNumber: number = 1, pageSize: number = 50, queryId?: UUID, queryVersionId?: UUID, sort?: SortObject): Promise<PagedResults<BoundaryAlertBotExtended>> {
    // verify required parameter 'boundaryId' is not null or undefined
    if (boundaryId === null || boundaryId === undefined) {
      throw new ParameterRequiredError('boundaryId');
    }
    if (pageNumber) {
      await Int32.parse(pageNumber);
    }
    if (pageSize) {
      await Int32.parse(pageSize);
    }
    const bag = new PagedResults<BoundaryAlertBotExtended>();
    bag.pageNumber = pageNumber;
    bag.pageSize = pageSize;
    await this.producer.listAlertBots(bag, boundaryId, queryId, queryVersionId, sort);
    if (bag.items === null || bag.items === undefined) {
      throw new UnexpectedError("Producers must return 'items' for PagedResults queries");
    }
    return bag;
  }
  /**
   * List all alerts in a boundary
   * @summary List all alerts in a boundary
   * @param boundaryId 
   * @param pageNumber The requested page. This value is 1-indexed.
   * @param pageSize The number of items in each page of data.
   * @param sort Sort object
   * @openapi operation=listBoundaryAlerts path=/app/boundaries/{boundaryId}/alerts method=GET
   */
  public async listBoundaryAlerts(boundaryId: UUID, pageNumber: number = 1, pageSize: number = 50, sort?: SortObject): Promise<PagedResults<BoundaryAlertView>> {
    // verify required parameter 'boundaryId' is not null or undefined
    if (boundaryId === null || boundaryId === undefined) {
      throw new ParameterRequiredError('boundaryId');
    }
    if (pageNumber) {
      await Int32.parse(pageNumber);
    }
    if (pageSize) {
      await Int32.parse(pageSize);
    }
    const bag = new PagedResults<BoundaryAlertView>();
    bag.pageNumber = pageNumber;
    bag.pageSize = pageSize;
    await this.producer.listBoundaryAlerts(bag, boundaryId, sort);
    if (bag.items === null || bag.items === undefined) {
      throw new UnexpectedError("Producers must return 'items' for PagedResults queries");
    }
    return bag;
  }
  /**
   * Retrieves audit metrics for a specific boundary
   * @summary Retrieves audit metrics for a specific boundary
   * @param boundaryId 
   * @param pageNumber The requested page. This value is 1-indexed.
   * @param pageSize The number of items in each page of data.
   * @param status Filter by status
   * @param type Filter by type
   * @openapi operation=listBoundaryAuditMetrics path=/boundaries/{boundaryId}/auditMetrics method=GET
   */
  public async listBoundaryAuditMetrics(boundaryId: UUID, pageNumber: number = 1, pageSize: number = 50, status?: AuditStatusEnumDef, type?: AuditTypeEnumDef): Promise<PagedResults<BoundaryAuditMetrics>> {
    // verify required parameter 'boundaryId' is not null or undefined
    if (boundaryId === null || boundaryId === undefined) {
      throw new ParameterRequiredError('boundaryId');
    }
    if (pageNumber) {
      await Int32.parse(pageNumber);
    }
    if (pageSize) {
      await Int32.parse(pageSize);
    }
    const bag = new PagedResults<BoundaryAuditMetrics>();
    bag.pageNumber = pageNumber;
    bag.pageSize = pageSize;
    await this.producer.listBoundaryAuditMetrics(bag, boundaryId, status, type);
    if (bag.items === null || bag.items === undefined) {
      throw new UnexpectedError("Producers must return 'items' for PagedResults queries");
    }
    return bag;
  }
  /**
   * Retrieves a list of audits for a boundary
   * @summary Retrieves a list of audits for a boundary
   * @param boundaryId 
   * @param pageNumber The requested page. This value is 1-indexed.
   * @param pageSize The number of items in each page of data.
   * @param status Filter by status
   * @param type Filter by type
   * @param audited Filter by audited flag
   * @openapi operation=listBoundaryAudits path=/boundaries/{boundaryId}/audits method=GET
   */
  public async listBoundaryAudits(boundaryId: UUID, pageNumber: number = 1, pageSize: number = 50, status?: AuditStatusEnumDef, type?: AuditTypeEnumDef, audited?: boolean): Promise<PagedResults<Audit & AuditExtended>> {
    // verify required parameter 'boundaryId' is not null or undefined
    if (boundaryId === null || boundaryId === undefined) {
      throw new ParameterRequiredError('boundaryId');
    }
    if (pageNumber) {
      await Int32.parse(pageNumber);
    }
    if (pageSize) {
      await Int32.parse(pageSize);
    }
    const bag = new PagedResults<Audit & AuditExtended>();
    bag.pageNumber = pageNumber;
    bag.pageSize = pageSize;
    await this.producer.listBoundaryAudits(bag, boundaryId, status, type, audited);
    if (bag.items === null || bag.items === undefined) {
      throw new UnexpectedError("Producers must return 'items' for PagedResults queries");
    }
    return bag;
  }
  /**
   * Page boundary components
   * @summary Page boundary components
   * @param pageNumber The requested page. This value is 1-indexed.
   * @param pageSize The number of items in each page of data.
   * @param boundaryId Boundary Id filter
   * @param componentId Component ID filter
   * @openapi operation=listBoundaryComponents path=/app/boundaryComponents method=GET
   */
  public async listBoundaryComponents(pageNumber: number = 1, pageSize: number = 50, boundaryId?: UUID, componentId?: UUID): Promise<PagedResults<BoundaryComponentExtended>> {
    if (pageNumber) {
      await Int32.parse(pageNumber);
    }
    if (pageSize) {
      await Int32.parse(pageSize);
    }
    const bag = new PagedResults<BoundaryComponentExtended>();
    bag.pageNumber = pageNumber;
    bag.pageSize = pageSize;
    await this.producer.listBoundaryComponents(bag, boundaryId, componentId);
    if (bag.items === null || bag.items === undefined) {
      throw new UnexpectedError("Producers must return 'items' for PagedResults queries");
    }
    return bag;
  }
  /**
   * Page boundary components by boundary id
   * @summary Page boundary components by boundary id
   * @param boundaryId 
   * @param pageNumber The requested page. This value is 1-indexed.
   * @param pageSize The number of items in each page of data.
   * @openapi operation=listBoundaryComponentsByBoundaryId path=/app/boundaries/{boundaryId}/components method=GET
   */
  public async listBoundaryComponentsByBoundaryId(boundaryId: UUID, pageNumber: number = 1, pageSize: number = 50): Promise<PagedResults<BoundaryComponentExtended>> {
    // verify required parameter 'boundaryId' is not null or undefined
    if (boundaryId === null || boundaryId === undefined) {
      throw new ParameterRequiredError('boundaryId');
    }
    if (pageNumber) {
      await Int32.parse(pageNumber);
    }
    if (pageSize) {
      await Int32.parse(pageSize);
    }
    const bag = new PagedResults<BoundaryComponentExtended>();
    bag.pageNumber = pageNumber;
    bag.pageSize = pageSize;
    await this.producer.listBoundaryComponentsByBoundaryId(bag, boundaryId);
    if (bag.items === null || bag.items === undefined) {
      throw new UnexpectedError("Producers must return 'items' for PagedResults queries");
    }
    return bag;
  }
  /**
   * Retrieves a list of all connections for a boundary
   * @summary Retrieves a list of all connections for a boundary
   * @param boundaryId 
   * @param pageNumber The requested page. This value is 1-indexed.
   * @param pageSize The number of items in each page of data.
   * @openapi operation=listBoundaryConnections path=/boundaries/{boundaryId}/connections method=GET
   */
  public async listBoundaryConnections(boundaryId: UUID, pageNumber: number = 1, pageSize: number = 50): Promise<PagedResults<BoundaryConnectionForList>> {
    // verify required parameter 'boundaryId' is not null or undefined
    if (boundaryId === null || boundaryId === undefined) {
      throw new ParameterRequiredError('boundaryId');
    }
    if (pageNumber) {
      await Int32.parse(pageNumber);
    }
    if (pageSize) {
      await Int32.parse(pageSize);
    }
    const bag = new PagedResults<BoundaryConnectionForList>();
    bag.pageNumber = pageNumber;
    bag.pageSize = pageSize;
    await this.producer.listBoundaryConnections(bag, boundaryId);
    if (bag.items === null || bag.items === undefined) {
      throw new UnexpectedError("Producers must return 'items' for PagedResults queries");
    }
    return bag;
  }
  /**
   * Retrieves a list of events for a boundary
   * @summary Retrieves a list of events for a boundary
   * @param boundaryId 
   * @param pageNumber The requested page. This value is 1-indexed.
   * @param pageSize The number of items in each page of data.
   * @openapi operation=listBoundaryEvents path=/boundaries/{boundaryId}/events method=GET
   */
  public async listBoundaryEvents(boundaryId: UUID, pageNumber: number = 1, pageSize: number = 50): Promise<PagedResults<BoundaryEvent & ExtendedBoundaryEvent>> {
    // verify required parameter 'boundaryId' is not null or undefined
    if (boundaryId === null || boundaryId === undefined) {
      throw new ParameterRequiredError('boundaryId');
    }
    if (pageNumber) {
      await Int32.parse(pageNumber);
    }
    if (pageSize) {
      await Int32.parse(pageSize);
    }
    const bag = new PagedResults<BoundaryEvent & ExtendedBoundaryEvent>();
    bag.pageNumber = pageNumber;
    bag.pageSize = pageSize;
    await this.producer.listBoundaryEvents(bag, boundaryId);
    if (bag.items === null || bag.items === undefined) {
      throw new UnexpectedError("Producers must return 'items' for PagedResults queries");
    }
    return bag;
  }
  /**
   * Retrieves a list of all boundary evidence by boundary id
   * @summary Retrieves a list of all boundary evidence by boundary id
   * @param boundaryId 
   * @param pageNumber The requested page. This value is 1-indexed.
   * @param pageSize The number of items in each page of data.
   * @param status 
   * @param productId 
   * @param evidenceDefinitionIds 
   * @param sortColumn 
   * @param sortOrder 
   * @openapi operation=listBoundaryEvidence path=/boundaries/{boundaryId}/evidence method=GET
   */
  public async listBoundaryEvidence(boundaryId: UUID, pageNumber: number = 1, pageSize: number = 50, status?: BoundaryEvidenceStatusEnumDef, productId?: UUID, evidenceDefinitionIds?: Array<UUID>, sortColumn?: BoundaryEvidenceSortColumnsDef, sortOrder?: SortOrderOptionsDef): Promise<PagedResults<BoundaryEvidence & ExtendedBoundaryEvidence>> {
    // verify required parameter 'boundaryId' is not null or undefined
    if (boundaryId === null || boundaryId === undefined) {
      throw new ParameterRequiredError('boundaryId');
    }
    if (pageNumber) {
      await Int32.parse(pageNumber);
    }
    if (pageSize) {
      await Int32.parse(pageSize);
    }
    const bag = new PagedResults<BoundaryEvidence & ExtendedBoundaryEvidence>();
    bag.pageNumber = pageNumber;
    bag.pageSize = pageSize;
    await this.producer.listBoundaryEvidence(bag, boundaryId, status, productId, evidenceDefinitionIds, sortColumn, sortOrder);
    if (bag.items === null || bag.items === undefined) {
      throw new UnexpectedError("Producers must return 'items' for PagedResults queries");
    }
    return bag;
  }
  /**
   * Retrieves a list of parties for a boundary
   * @summary Retrieves a list of parties for a boundary
   * @param boundaryId 
   * @param pageNumber The requested page. This value is 1-indexed.
   * @param pageSize The number of items in each page of data.
   * @param partyType 
   * @param assignable 
   * @param search comma separated string of keywords to search against
   * @param sort Sort object
   * @openapi operation=listBoundaryParties path=/boundaries/{boundaryId}/parties method=GET
   */
  public async listBoundaryParties(boundaryId: UUID, pageNumber: number = 1, pageSize: number = 50, partyType?: PartyTypeEnumDef, assignable?: boolean, search?: string, sort?: SortObject): Promise<PagedResults<PartyExtended>> {
    // verify required parameter 'boundaryId' is not null or undefined
    if (boundaryId === null || boundaryId === undefined) {
      throw new ParameterRequiredError('boundaryId');
    }
    if (pageNumber) {
      await Int32.parse(pageNumber);
    }
    if (pageSize) {
      await Int32.parse(pageSize);
    }
    const bag = new PagedResults<PartyExtended>();
    bag.pageNumber = pageNumber;
    bag.pageSize = pageSize;
    await this.producer.listBoundaryParties(bag, boundaryId, partyType, assignable, search, sort);
    if (bag.items === null || bag.items === undefined) {
      throw new UnexpectedError("Producers must return 'items' for PagedResults queries");
    }
    return bag;
  }
  /**
   * Retrieves a boundary party Raci RollUP matrix
   * @summary Retrieves a boundary party Raci RollUP matrix
   * @param boundaryId 
   * @param partyId 
   * @openapi operation=listBoundaryPartyRaci path=/boundaries/{boundaryId}/parties/{partyId}/responsibilityMatrix method=GET
   */
  public async listBoundaryPartyRaci(boundaryId: UUID, partyId: UUID): Promise<Array<RaciRollup>> {
    // verify required parameter 'boundaryId' is not null or undefined
    if (boundaryId === null || boundaryId === undefined) {
      throw new ParameterRequiredError('boundaryId');
    }
    // verify required parameter 'partyId' is not null or undefined
    if (partyId === null || partyId === undefined) {
      throw new ParameterRequiredError('partyId');
    }
    return this.producer.listBoundaryPartyRaci(boundaryId, partyId);
  }
  /**
   * Retrieves paged list of roles assigned to a party on a boundary
   * @summary Retrieves paged list of roles assigned to a party on a boundary
   * @param boundaryId 
   * @param partyId 
   * @param pageNumber The requested page. This value is 1-indexed.
   * @param pageSize The number of items in each page of data.
   * @openapi operation=listBoundaryPartyRoles path=/app/boundaries/{boundaryId}/parties/{partyId}/roles method=GET
   */
  public async listBoundaryPartyRoles(boundaryId: UUID, partyId: UUID, pageNumber: number = 1, pageSize: number = 50): Promise<PagedResults<BoundaryPartyRoleExtended>> {
    // verify required parameter 'boundaryId' is not null or undefined
    if (boundaryId === null || boundaryId === undefined) {
      throw new ParameterRequiredError('boundaryId');
    }
    // verify required parameter 'partyId' is not null or undefined
    if (partyId === null || partyId === undefined) {
      throw new ParameterRequiredError('partyId');
    }
    if (pageNumber) {
      await Int32.parse(pageNumber);
    }
    if (pageSize) {
      await Int32.parse(pageSize);
    }
    const bag = new PagedResults<BoundaryPartyRoleExtended>();
    bag.pageNumber = pageNumber;
    bag.pageSize = pageSize;
    await this.producer.listBoundaryPartyRoles(bag, boundaryId, partyId);
    if (bag.items === null || bag.items === undefined) {
      throw new UnexpectedError("Producers must return 'items' for PagedResults queries");
    }
    return bag;
  }
  /**
   * Page boundary party roles by boundary id
   * @summary Page boundary party roles by boundary id
   * @param boundaryId 
   * @param pageNumber The requested page. This value is 1-indexed.
   * @param pageSize The number of items in each page of data.
   * @param partyId Party Id filter
   * @openapi operation=listBoundaryPartyRolesByBoundaryId path=/app/boundaries/{boundaryId}/partyRoles method=GET
   */
  public async listBoundaryPartyRolesByBoundaryId(boundaryId: UUID, pageNumber: number = 1, pageSize: number = 50, partyId?: UUID): Promise<PagedResults<BoundaryPartyRoleExtended>> {
    // verify required parameter 'boundaryId' is not null or undefined
    if (boundaryId === null || boundaryId === undefined) {
      throw new ParameterRequiredError('boundaryId');
    }
    if (pageNumber) {
      await Int32.parse(pageNumber);
    }
    if (pageSize) {
      await Int32.parse(pageSize);
    }
    const bag = new PagedResults<BoundaryPartyRoleExtended>();
    bag.pageNumber = pageNumber;
    bag.pageSize = pageSize;
    await this.producer.listBoundaryPartyRolesByBoundaryId(bag, boundaryId, partyId);
    if (bag.items === null || bag.items === undefined) {
      throw new UnexpectedError("Producers must return 'items' for PagedResults queries");
    }
    return bag;
  }
  /**
   * List pipelines for a certain boundary
   * @summary List pipelines for a certain boundary
   * @param boundaryId 
   * @param pageNumber The requested page. This value is 1-indexed.
   * @param pageSize The number of items in each page of data.
   * @param keywords 
   * @param productId 
   * @param adminStatus 
   * @param executionStatus 
   * @param type 
   * @param sort Sort object
   * @openapi operation=listBoundaryPipelines path=/boundaries/{boundaryId}/pipelines method=GET
   */
  public async listBoundaryPipelines(boundaryId: UUID, pageNumber: number = 1, pageSize: number = 50, keywords?: string, productId?: UUID, adminStatus?: PipelineAdminStatusEnumDef, executionStatus?: PipelineExecutionStatusEnumDef, type?: PipelineFormatEnumDef, sort?: SortObject): Promise<PagedResults<Pipeline>> {
    // verify required parameter 'boundaryId' is not null or undefined
    if (boundaryId === null || boundaryId === undefined) {
      throw new ParameterRequiredError('boundaryId');
    }
    if (pageNumber) {
      await Int32.parse(pageNumber);
    }
    if (pageSize) {
      await Int32.parse(pageSize);
    }
    const bag = new PagedResults<Pipeline>();
    bag.pageNumber = pageNumber;
    bag.pageSize = pageSize;
    await this.producer.listBoundaryPipelines(bag, boundaryId, keywords, productId, adminStatus, executionStatus, type, sort);
    if (bag.items === null || bag.items === undefined) {
      throw new UnexpectedError("Producers must return 'items' for PagedResults queries");
    }
    return bag;
  }
  /**
   * Retrieves a list of all connections for a boundary
   * @summary Retrieves a list of all connections for a boundary
   * @param boundaryId 
   * @param boundaryProductId 
   * @param pageNumber The requested page. This value is 1-indexed.
   * @param pageSize The number of items in each page of data.
   * @param sort Sort object
   * @openapi operation=listBoundaryProductConnections path=/boundaries/{boundaryId}/products/{boundaryProductId}/connections method=GET
   */
  public async listBoundaryProductConnections(boundaryId: UUID, boundaryProductId: UUID, pageNumber: number = 1, pageSize: number = 50, sort?: SortObject): Promise<PagedResults<BoundaryConnectionForList>> {
    // verify required parameter 'boundaryId' is not null or undefined
    if (boundaryId === null || boundaryId === undefined) {
      throw new ParameterRequiredError('boundaryId');
    }
    // verify required parameter 'boundaryProductId' is not null or undefined
    if (boundaryProductId === null || boundaryProductId === undefined) {
      throw new ParameterRequiredError('boundaryProductId');
    }
    if (pageNumber) {
      await Int32.parse(pageNumber);
    }
    if (pageSize) {
      await Int32.parse(pageSize);
    }
    const bag = new PagedResults<BoundaryConnectionForList>();
    bag.pageNumber = pageNumber;
    bag.pageSize = pageSize;
    await this.producer.listBoundaryProductConnections(bag, boundaryId, boundaryProductId, sort);
    if (bag.items === null || bag.items === undefined) {
      throw new UnexpectedError("Producers must return 'items' for PagedResults queries");
    }
    return bag;
  }
  /**
   * Retrieves a boundary product
   * @summary Retrieves a boundary product
   * @param boundaryId 
   * @param boundaryProductId 
   * @param pageNumber The requested page. This value is 1-indexed.
   * @param pageSize The number of items in each page of data.
   * @param search 
   * @param format 
   * @param targetId 
   * @param sort Sort object
   * @param showPreviews 
   * @openapi operation=listBoundaryProductPipelines path=/boundaries/{boundaryId}/products/{boundaryProductId}/pipelines method=GET
   */
  public async listBoundaryProductPipelines(boundaryId: UUID, boundaryProductId: UUID, pageNumber: number = 1, pageSize: number = 50, search?: string, format?: PipelineFormatEnumDef, targetId?: UUID, sort?: SortObject, showPreviews?: boolean): Promise<PagedResults<BoundaryProductPipeline>> {
    // verify required parameter 'boundaryId' is not null or undefined
    if (boundaryId === null || boundaryId === undefined) {
      throw new ParameterRequiredError('boundaryId');
    }
    // verify required parameter 'boundaryProductId' is not null or undefined
    if (boundaryProductId === null || boundaryProductId === undefined) {
      throw new ParameterRequiredError('boundaryProductId');
    }
    if (pageNumber) {
      await Int32.parse(pageNumber);
    }
    if (pageSize) {
      await Int32.parse(pageSize);
    }
    const bag = new PagedResults<BoundaryProductPipeline>();
    bag.pageNumber = pageNumber;
    bag.pageSize = pageSize;
    await this.producer.listBoundaryProductPipelines(bag, boundaryId, boundaryProductId, search, format, targetId, sort, showPreviews);
    if (bag.items === null || bag.items === undefined) {
      throw new UnexpectedError("Producers must return 'items' for PagedResults queries");
    }
    return bag;
  }
  /**
   * Retrieves a list of products for a boundary
   * @summary Retrieves a list of products for a boundary
   * @param boundaryId 
   * @param pageNumber The requested page. This value is 1-indexed.
   * @param pageSize The number of items in each page of data.
   * @param status Filter by status
   * @param keywords Search like filter
   * @param sort 
   * @openapi operation=listBoundaryProductsByBoundary path=/boundaries/{boundaryId}/products method=GET
   */
  public async listBoundaryProductsByBoundary(boundaryId: UUID, pageNumber: number = 1, pageSize: number = 50, status?: CatalogPublishStatusEnumDef, keywords?: string, sort?: SortObject): Promise<PagedResults<BoundaryProductExtended>> {
    // verify required parameter 'boundaryId' is not null or undefined
    if (boundaryId === null || boundaryId === undefined) {
      throw new ParameterRequiredError('boundaryId');
    }
    if (pageNumber) {
      await Int32.parse(pageNumber);
    }
    if (pageSize) {
      await Int32.parse(pageSize);
    }
    const bag = new PagedResults<BoundaryProductExtended>();
    bag.pageNumber = pageNumber;
    bag.pageSize = pageSize;
    await this.producer.listBoundaryProductsByBoundary(bag, boundaryId, status, keywords, sort);
    if (bag.items === null || bag.items === undefined) {
      throw new UnexpectedError("Producers must return 'items' for PagedResults queries");
    }
    return bag;
  }
  /**
   * List all alerts bound to a query
   * @summary List all alerts bound to a query
   * @param boundaryId 
   * @param queryId A queryId or queryVersionId.
   * @param pageNumber The requested page. This value is 1-indexed.
   * @param pageSize The number of items in each page of data.
   * @param sort Sort object
   * @openapi operation=listBoundaryQueryAlerts path=/app/boundaries/{boundaryId}/queries/{queryId}/alerts method=GET
   */
  public async listBoundaryQueryAlerts(boundaryId: UUID, queryId: UUID, pageNumber: number = 1, pageSize: number = 50, sort?: SortObject): Promise<PagedResults<BoundaryAlertView>> {
    // verify required parameter 'boundaryId' is not null or undefined
    if (boundaryId === null || boundaryId === undefined) {
      throw new ParameterRequiredError('boundaryId');
    }
    // verify required parameter 'queryId' is not null or undefined
    if (queryId === null || queryId === undefined) {
      throw new ParameterRequiredError('queryId');
    }
    if (pageNumber) {
      await Int32.parse(pageNumber);
    }
    if (pageSize) {
      await Int32.parse(pageSize);
    }
    const bag = new PagedResults<BoundaryAlertView>();
    bag.pageNumber = pageNumber;
    bag.pageSize = pageSize;
    await this.producer.listBoundaryQueryAlerts(bag, boundaryId, queryId, sort);
    if (bag.items === null || bag.items === undefined) {
      throw new UnexpectedError("Producers must return 'items' for PagedResults queries");
    }
    return bag;
  }
  /**
   * Retrieve paged list of boundary roles and parties if assigned
   * @summary Retrieve paged list of boundary roles and parties if assigned
   * @param boundaryId 
   * @param pageNumber The requested page. This value is 1-indexed.
   * @param pageSize The number of items in each page of data.
   * @param roleCategoryId 
   * @openapi operation=listBoundaryRoles path=/app/boundaries/{boundaryId}/roles method=GET
   */
  public async listBoundaryRoles(boundaryId: UUID, pageNumber: number = 1, pageSize: number = 50, roleCategoryId?: UUID): Promise<PagedResults<BoundaryRoleExtended>> {
    // verify required parameter 'boundaryId' is not null or undefined
    if (boundaryId === null || boundaryId === undefined) {
      throw new ParameterRequiredError('boundaryId');
    }
    if (pageNumber) {
      await Int32.parse(pageNumber);
    }
    if (pageSize) {
      await Int32.parse(pageSize);
    }
    const bag = new PagedResults<BoundaryRoleExtended>();
    bag.pageNumber = pageNumber;
    bag.pageSize = pageSize;
    await this.producer.listBoundaryRoles(bag, boundaryId, roleCategoryId);
    if (bag.items === null || bag.items === undefined) {
      throw new UnexpectedError("Producers must return 'items' for PagedResults queries");
    }
    return bag;
  }
  /**
   * Retrieves a list of scf controls for a boundary
   * @summary Retrieves a list of scf controls for a boundary
   * @param boundaryId 
   * @param pageNumber The requested page. This value is 1-indexed.
   * @param pageSize The number of items in each page of data.
   * @param frameworkElementId 
   * @param scfDomainCode 
   * @param performed 
   * @param answered 
   * @openapi operation=listBoundaryScfControls path=/boundaries/{boundaryId}/scfControls method=GET
   */
  public async listBoundaryScfControls(boundaryId: UUID, pageNumber: number = 1, pageSize: number = 50, frameworkElementId?: UUID, scfDomainCode?: string, performed?: boolean, answered?: boolean): Promise<PagedResults<ExtendedBoundaryScfControl>> {
    // verify required parameter 'boundaryId' is not null or undefined
    if (boundaryId === null || boundaryId === undefined) {
      throw new ParameterRequiredError('boundaryId');
    }
    if (pageNumber) {
      await Int32.parse(pageNumber);
    }
    if (pageSize) {
      await Int32.parse(pageSize);
    }
    const bag = new PagedResults<ExtendedBoundaryScfControl>();
    bag.pageNumber = pageNumber;
    bag.pageSize = pageSize;
    await this.producer.listBoundaryScfControls(bag, boundaryId, frameworkElementId, scfDomainCode, performed, answered);
    if (bag.items === null || bag.items === undefined) {
      throw new UnexpectedError("Producers must return 'items' for PagedResults queries");
    }
    return bag;
  }
  /**
   * List standard baselines that have been added to a boundary
   * @summary List standard baselines that have been added to a boundary
   * @param boundaryId 
   * @param boundaryStandardBaselineId 
   * @param pageNumber The requested page. This value is 1-indexed.
   * @param pageSize The number of items in each page of data.
   * @param sort Sort object
   * @openapi operation=listBoundaryStandardBaselineElements path=/app/boundaries/{boundaryId}/standardBaselines/{boundaryStandardBaselineId}/elements method=GET
   */
  public async listStandardBaselineElements(boundaryId: UUID, boundaryStandardBaselineId: UUID, pageNumber: number = 1, pageSize: number = 50, sort?: SortObject): Promise<PagedResults<ElementExtended>> {
    // verify required parameter 'boundaryId' is not null or undefined
    if (boundaryId === null || boundaryId === undefined) {
      throw new ParameterRequiredError('boundaryId');
    }
    // verify required parameter 'boundaryStandardBaselineId' is not null or undefined
    if (boundaryStandardBaselineId === null || boundaryStandardBaselineId === undefined) {
      throw new ParameterRequiredError('boundaryStandardBaselineId');
    }
    if (pageNumber) {
      await Int32.parse(pageNumber);
    }
    if (pageSize) {
      await Int32.parse(pageSize);
    }
    const bag = new PagedResults<ElementExtended>();
    bag.pageNumber = pageNumber;
    bag.pageSize = pageSize;
    await this.producer.listStandardBaselineElements(bag, boundaryId, boundaryStandardBaselineId, sort);
    if (bag.items === null || bag.items === undefined) {
      throw new UnexpectedError("Producers must return 'items' for PagedResults queries");
    }
    return bag;
  }
  /**
   * List standard baselines that have been added to a boundary
   * @summary List standard baselines that have been added to a boundary
   * @param boundaryId 
   * @param pageNumber The requested page. This value is 1-indexed.
   * @param pageSize The number of items in each page of data.
   * @openapi operation=listBoundaryStandardBaselines path=/app/boundaries/{boundaryId}/standardBaselines method=GET
   */
  public async listStandardBaselines(boundaryId: UUID, pageNumber: number = 1, pageSize: number = 50): Promise<PagedResults<BoundaryStandardBaselineExtended>> {
    // verify required parameter 'boundaryId' is not null or undefined
    if (boundaryId === null || boundaryId === undefined) {
      throw new ParameterRequiredError('boundaryId');
    }
    if (pageNumber) {
      await Int32.parse(pageNumber);
    }
    if (pageSize) {
      await Int32.parse(pageSize);
    }
    const bag = new PagedResults<BoundaryStandardBaselineExtended>();
    bag.pageNumber = pageNumber;
    bag.pageSize = pageSize;
    await this.producer.listStandardBaselines(bag, boundaryId);
    if (bag.items === null || bag.items === undefined) {
      throw new UnexpectedError("Producers must return 'items' for PagedResults queries");
    }
    return bag;
  }
  /**
   * Retrieves a list of suggested products for a boundary
   * @summary Retrieves a list of suggested products for a boundary
   * @param boundaryId 
   * @param pageNumber The requested page. This value is 1-indexed.
   * @param pageSize The number of items in each page of data.
   * @param keywords Search like filter
   * @openapi operation=listBoundarySuggestedProducts path=/boundaries/{boundaryId}/suggestedProducts method=GET
   */
  public async listBoundarySuggestedProducts(boundaryId: UUID, pageNumber: number = 1, pageSize: number = 50, keywords?: string): Promise<PagedResults<BoundarySuggestedProduct>> {
    // verify required parameter 'boundaryId' is not null or undefined
    if (boundaryId === null || boundaryId === undefined) {
      throw new ParameterRequiredError('boundaryId');
    }
    if (pageNumber) {
      await Int32.parse(pageNumber);
    }
    if (pageSize) {
      await Int32.parse(pageSize);
    }
    const bag = new PagedResults<BoundarySuggestedProduct>();
    bag.pageNumber = pageNumber;
    bag.pageSize = pageSize;
    await this.producer.listBoundarySuggestedProducts(bag, boundaryId, keywords);
    if (bag.items === null || bag.items === undefined) {
      throw new UnexpectedError("Producers must return 'items' for PagedResults queries");
    }
    return bag;
  }
  /**
   * Retrieves a list of targets for a boundary
   * @summary Retrieves a list of targets for a boundary
   * @param boundaryId 
   * @param boundaryProductId 
   * @param pageNumber The requested page. This value is 1-indexed.
   * @param pageSize The number of items in each page of data.
   * @param keywords Search like filter
   * @openapi operation=listBoundaryTargetsByProduct path=/boundaries/{boundaryId}/products/{boundaryProductId}/targets method=GET
   */
  public async listBoundaryTargetsByProduct(boundaryId: UUID, boundaryProductId: UUID, pageNumber: number = 1, pageSize: number = 50, keywords?: string): Promise<PagedResults<BoundaryProductTarget & ExtendedBoundaryProductTarget>> {
    // verify required parameter 'boundaryId' is not null or undefined
    if (boundaryId === null || boundaryId === undefined) {
      throw new ParameterRequiredError('boundaryId');
    }
    // verify required parameter 'boundaryProductId' is not null or undefined
    if (boundaryProductId === null || boundaryProductId === undefined) {
      throw new ParameterRequiredError('boundaryProductId');
    }
    if (pageNumber) {
      await Int32.parse(pageNumber);
    }
    if (pageSize) {
      await Int32.parse(pageSize);
    }
    const bag = new PagedResults<BoundaryProductTarget & ExtendedBoundaryProductTarget>();
    bag.pageNumber = pageNumber;
    bag.pageSize = pageSize;
    await this.producer.listBoundaryTargetsByProduct(bag, boundaryId, boundaryProductId, keywords);
    if (bag.items === null || bag.items === undefined) {
      throw new UnexpectedError("Producers must return 'items' for PagedResults queries");
    }
    return bag;
  }
  /**
   * Retrieves a list of teams metrics for a boundary
   * @summary Retrieves a list of teams metrics for a boundary
   * @param boundaryId 
   * @param pageNumber The requested page. This value is 1-indexed.
   * @param pageSize The number of items in each page of data.
   * @openapi operation=listBoundaryTeamMetrics path=/boundaries/{boundaryId}/teamMetrics method=GET
   */
  public async listBoundaryTeamMetrics(boundaryId: UUID, pageNumber: number = 1, pageSize: number = 50): Promise<PagedResults<BoundaryTeamMetrics>> {
    // verify required parameter 'boundaryId' is not null or undefined
    if (boundaryId === null || boundaryId === undefined) {
      throw new ParameterRequiredError('boundaryId');
    }
    if (pageNumber) {
      await Int32.parse(pageNumber);
    }
    if (pageSize) {
      await Int32.parse(pageSize);
    }
    const bag = new PagedResults<BoundaryTeamMetrics>();
    bag.pageNumber = pageNumber;
    bag.pageSize = pageSize;
    await this.producer.listBoundaryTeamMetrics(bag, boundaryId);
    if (bag.items === null || bag.items === undefined) {
      throw new UnexpectedError("Producers must return 'items' for PagedResults queries");
    }
    return bag;
  }
  /**
   * Retrieves a list of evidence definitions in scope for a boundary team scf control
   * @summary Retrieves a list of evidence definitions in scope for a boundary team scf control
   * @param boundaryId 
   * @param teamId 
   * @param scfControlId 
   * @param pageNumber The requested page. This value is 1-indexed.
   * @param pageSize The number of items in each page of data.
   * @openapi operation=listBoundaryTeamScfControlEvidenceDefintions path=/boundaries/{boundaryId}/teams/{teamId}/scfControlTree/{scfControlId}/evidenceDefinitions method=GET
   */
  public async listBoundaryTeamScfControlEvidenceDefintions(boundaryId: UUID, teamId: UUID, scfControlId: UUID, pageNumber: number = 1, pageSize: number = 50): Promise<PagedResults<BoundaryTeamScfControlEvidenceDefinitionImplementation>> {
    // verify required parameter 'boundaryId' is not null or undefined
    if (boundaryId === null || boundaryId === undefined) {
      throw new ParameterRequiredError('boundaryId');
    }
    // verify required parameter 'teamId' is not null or undefined
    if (teamId === null || teamId === undefined) {
      throw new ParameterRequiredError('teamId');
    }
    // verify required parameter 'scfControlId' is not null or undefined
    if (scfControlId === null || scfControlId === undefined) {
      throw new ParameterRequiredError('scfControlId');
    }
    if (pageNumber) {
      await Int32.parse(pageNumber);
    }
    if (pageSize) {
      await Int32.parse(pageSize);
    }
    const bag = new PagedResults<BoundaryTeamScfControlEvidenceDefinitionImplementation>();
    bag.pageNumber = pageNumber;
    bag.pageSize = pageSize;
    await this.producer.listBoundaryTeamScfControlEvidenceDefintions(bag, boundaryId, teamId, scfControlId);
    if (bag.items === null || bag.items === undefined) {
      throw new UnexpectedError("Producers must return 'items' for PagedResults queries");
    }
    return bag;
  }
  /**
   * Retrieves a list of scf control data for a boundary team
   * @summary Retrieves a list of scf control data for a boundary team
   * @param boundaryId 
   * @param teamId 
   * @param pageNumber The requested page. This value is 1-indexed.
   * @param pageSize The number of items in each page of data.
   * @param domain Filter by domain
   * @param code Filter by code
   * @openapi operation=listBoundaryTeamScfControls path=/boundaries/{boundaryId}/teams/{teamId}/scfControls method=GET
   */
  public async listBoundaryTeamScfControls(boundaryId: UUID, teamId: UUID, pageNumber: number = 1, pageSize: number = 50, domain?: string, code?: string): Promise<PagedResults<BoundaryTeamScfControl>> {
    // verify required parameter 'boundaryId' is not null or undefined
    if (boundaryId === null || boundaryId === undefined) {
      throw new ParameterRequiredError('boundaryId');
    }
    // verify required parameter 'teamId' is not null or undefined
    if (teamId === null || teamId === undefined) {
      throw new ParameterRequiredError('teamId');
    }
    if (pageNumber) {
      await Int32.parse(pageNumber);
    }
    if (pageSize) {
      await Int32.parse(pageSize);
    }
    const bag = new PagedResults<BoundaryTeamScfControl>();
    bag.pageNumber = pageNumber;
    bag.pageSize = pageSize;
    await this.producer.listBoundaryTeamScfControls(bag, boundaryId, teamId, domain, code);
    if (bag.items === null || bag.items === undefined) {
      throw new UnexpectedError("Producers must return 'items' for PagedResults queries");
    }
    return bag;
  }
  /**
   * Retrieves a list of teams for a boundary
   * @summary Retrieves a list of teams for a boundary
   * @param boundaryId 
   * @param pageNumber The requested page. This value is 1-indexed.
   * @param pageSize The number of items in each page of data.
   * @param sort Sort object
   * @openapi operation=listBoundaryTeams path=/boundaries/{boundaryId}/teams method=GET
   */
  public async listBoundaryTeams(boundaryId: UUID, pageNumber: number = 1, pageSize: number = 50, sort?: SortObject): Promise<PagedResults<BoundaryTeam>> {
    // verify required parameter 'boundaryId' is not null or undefined
    if (boundaryId === null || boundaryId === undefined) {
      throw new ParameterRequiredError('boundaryId');
    }
    if (pageNumber) {
      await Int32.parse(pageNumber);
    }
    if (pageSize) {
      await Int32.parse(pageSize);
    }
    const bag = new PagedResults<BoundaryTeam>();
    bag.pageNumber = pageNumber;
    bag.pageSize = pageSize;
    await this.producer.listBoundaryTeams(bag, boundaryId, sort);
    if (bag.items === null || bag.items === undefined) {
      throw new UnexpectedError("Producers must return 'items' for PagedResults queries");
    }
    return bag;
  }
  /**
   * List tests within a boundary with filters
   * @summary List tests within a boundary with filters
   * @param boundaryId 
   * @param pageNumber The requested page. This value is 1-indexed.
   * @param pageSize The number of items in each page of data.
   * @param standardId 
   * @param benchmarkId 
   * @param testCaseId 
   * @param componentId 
   * @param status 
   * @param sort Sort object
   * @openapi operation=listBoundaryTests path=/app/boundaries/{boundaryId}/tests method=GET
   */
  public async listTests(boundaryId: UUID, pageNumber: number = 1, pageSize: number = 50, standardId?: UUID, benchmarkId?: UUID, testCaseId?: UUID, componentId?: UUID, status?: TestResultEnumDef, sort?: SortObject): Promise<PagedResults<TestExtended>> {
    // verify required parameter 'boundaryId' is not null or undefined
    if (boundaryId === null || boundaryId === undefined) {
      throw new ParameterRequiredError('boundaryId');
    }
    if (pageNumber) {
      await Int32.parse(pageNumber);
    }
    if (pageSize) {
      await Int32.parse(pageSize);
    }
    const bag = new PagedResults<TestExtended>();
    bag.pageNumber = pageNumber;
    bag.pageSize = pageSize;
    await this.producer.listTests(bag, boundaryId, standardId, benchmarkId, testCaseId, componentId, status, sort);
    if (bag.items === null || bag.items === undefined) {
      throw new UnexpectedError("Producers must return 'items' for PagedResults queries");
    }
    return bag;
  }
  /**
   * Retrieves a list of scf domains unmanaged for a boundary
   * @summary Retrieves a list of scf domains unmanaged for a boundary
   * @param boundaryId 
   * @param pageNumber The requested page. This value is 1-indexed.
   * @param pageSize The number of items in each page of data.
   * @openapi operation=listBoundaryUnmanagedDomains path=/boundaries/{boundaryId}/unmanagedDomains method=GET
   */
  public async listBoundaryUnmanagedDomains(boundaryId: UUID, pageNumber: number = 1, pageSize: number = 50): Promise<PagedResults<ScfDomain>> {
    // verify required parameter 'boundaryId' is not null or undefined
    if (boundaryId === null || boundaryId === undefined) {
      throw new ParameterRequiredError('boundaryId');
    }
    if (pageNumber) {
      await Int32.parse(pageNumber);
    }
    if (pageSize) {
      await Int32.parse(pageSize);
    }
    const bag = new PagedResults<ScfDomain>();
    bag.pageNumber = pageNumber;
    bag.pageSize = pageSize;
    await this.producer.listBoundaryUnmanagedDomains(bag, boundaryId);
    if (bag.items === null || bag.items === undefined) {
      throw new UnexpectedError("Producers must return 'items' for PagedResults queries");
    }
    return bag;
  }
  /**
   * Page boundary party roles with filters
   * @summary Page boundary party roles with filters
   * @param pageNumber The requested page. This value is 1-indexed.
   * @param pageSize The number of items in each page of data.
   * @param partyId Party Id filter
   * @param boundaryId Boundary Id filter
   * @param roleId Role ID filter
   * @openapi operation=listFilterBoundaryPartyRoles path=/app/boundaryPartyRoles method=GET
   */
  public async listFilterBoundaryPartyRoles(pageNumber: number = 1, pageSize: number = 50, partyId?: UUID, boundaryId?: UUID, roleId?: UUID): Promise<PagedResults<BoundaryPartyRoleExtended>> {
    if (pageNumber) {
      await Int32.parse(pageNumber);
    }
    if (pageSize) {
      await Int32.parse(pageSize);
    }
    const bag = new PagedResults<BoundaryPartyRoleExtended>();
    bag.pageNumber = pageNumber;
    bag.pageSize = pageSize;
    await this.producer.listFilterBoundaryPartyRoles(bag, partyId, boundaryId, roleId);
    if (bag.items === null || bag.items === undefined) {
      throw new UnexpectedError("Producers must return 'items' for PagedResults queries");
    }
    return bag;
  }
  /**
   * Remove crosswalk version from boundary
   * @summary Remove crosswalk version from boundary
   * @param boundaryId 
   * @param boundaryCrosswalkVersionId 
   * @openapi operation=removeBoundaryCrosswalkVersion path=/app/boundaries/{boundaryId}/crosswalkVersions/{boundaryCrosswalkVersionId} method=DELETE
   */
  public async removeCrosswalkVersion(boundaryId: UUID, boundaryCrosswalkVersionId: UUID): Promise<void> {
    // verify required parameter 'boundaryId' is not null or undefined
    if (boundaryId === null || boundaryId === undefined) {
      throw new ParameterRequiredError('boundaryId');
    }
    // verify required parameter 'boundaryCrosswalkVersionId' is not null or undefined
    if (boundaryCrosswalkVersionId === null || boundaryCrosswalkVersionId === undefined) {
      throw new ParameterRequiredError('boundaryCrosswalkVersionId');
    }
    return this.producer.removeCrosswalkVersion(boundaryId, boundaryCrosswalkVersionId);
  }
  /**
   * Remove standard baseline from boundary
   * @summary Remove standard baseline from boundary
   * @param boundaryId 
   * @param boundaryStandardBaselineId 
   * @openapi operation=removeBoundaryStandardBaseline path=/app/boundaries/{boundaryId}/standardBaselines/{boundaryStandardBaselineId} method=DELETE
   */
  public async removeStandardBaseline(boundaryId: UUID, boundaryStandardBaselineId: UUID): Promise<void> {
    // verify required parameter 'boundaryId' is not null or undefined
    if (boundaryId === null || boundaryId === undefined) {
      throw new ParameterRequiredError('boundaryId');
    }
    // verify required parameter 'boundaryStandardBaselineId' is not null or undefined
    if (boundaryStandardBaselineId === null || boundaryStandardBaselineId === undefined) {
      throw new ParameterRequiredError('boundaryStandardBaselineId');
    }
    return this.producer.removeStandardBaseline(boundaryId, boundaryStandardBaselineId);
  }
  /**
   * Manually run an alert bot
   * @summary Manually run an alert bot
   * @param boundaryId 
   * @param boundaryAlertBotId 
   * @openapi operation=runBoundaryAlertBot path=/app/boundaries/{boundaryId}/alertBots/{boundaryAlertBotId} method=POST
   */
  public async runAlertBot(boundaryId: UUID, boundaryAlertBotId: UUID): Promise<void> {
    // verify required parameter 'boundaryId' is not null or undefined
    if (boundaryId === null || boundaryId === undefined) {
      throw new ParameterRequiredError('boundaryId');
    }
    // verify required parameter 'boundaryAlertBotId' is not null or undefined
    if (boundaryAlertBotId === null || boundaryAlertBotId === undefined) {
      throw new ParameterRequiredError('boundaryAlertBotId');
    }
    return this.producer.runAlertBot(boundaryId, boundaryAlertBotId);
  }
  /**
   * Subscribe to an Alert Bot's alerts
   * @summary Subscribe to an Alert Bot's alerts
   * @param boundaryId 
   * @param boundaryAlertBotId 
   * @openapi operation=subscribeToBoundaryAlertBotAlerts path=/app/boundaries/{boundaryId}/alertBots/{boundaryAlertBotId}/subscribe method=PUT
   */
  public async subscribe(boundaryId: UUID, boundaryAlertBotId: UUID): Promise<AlertSubscriptionExtended> {
    // verify required parameter 'boundaryId' is not null or undefined
    if (boundaryId === null || boundaryId === undefined) {
      throw new ParameterRequiredError('boundaryId');
    }
    // verify required parameter 'boundaryAlertBotId' is not null or undefined
    if (boundaryAlertBotId === null || boundaryAlertBotId === undefined) {
      throw new ParameterRequiredError('boundaryAlertBotId');
    }
    return this.producer.subscribe(boundaryId, boundaryAlertBotId);
  }
  /**
   * Unsubscribe from and alert bot's alerts
   * @summary Unsubscribe from and alert bot's alerts
   * @param boundaryId 
   * @param boundaryAlertBotId 
   * @openapi operation=unsubscribeFromBoundaryAlertBotAlerts path=/app/boundaries/{boundaryId}/alertBots/{boundaryAlertBotId}/unsubscribe method=PUT
   */
  public async unsubscribe(boundaryId: UUID, boundaryAlertBotId: UUID): Promise<AlertSubscriptionExtended> {
    // verify required parameter 'boundaryId' is not null or undefined
    if (boundaryId === null || boundaryId === undefined) {
      throw new ParameterRequiredError('boundaryId');
    }
    // verify required parameter 'boundaryAlertBotId' is not null or undefined
    if (boundaryAlertBotId === null || boundaryAlertBotId === undefined) {
      throw new ParameterRequiredError('boundaryAlertBotId');
    }
    return this.producer.unsubscribe(boundaryId, boundaryAlertBotId);
  }
  /**
   * Updates a boundary
   * @summary Updates a boundary
   * @param boundaryId 
   * @param updateBoundary 
   * @openapi operation=updateBoundary path=/boundaries/{boundaryId} method=PUT
   */
  public async updateBoundary(boundaryId: UUID, updateBoundary: UpdateBoundary): Promise<Boundary> {
    // verify required parameter 'boundaryId' is not null or undefined
    if (boundaryId === null || boundaryId === undefined) {
      throw new ParameterRequiredError('boundaryId');
    }
    // verify required parameter 'updateBoundary' is not null or undefined
    if (updateBoundary === null || updateBoundary === undefined) {
      throw new ParameterRequiredError('updateBoundary');
    }
    return this.producer.updateBoundary(boundaryId, updateBoundary);
  }
  /**
   * Update an alert bot
   * @summary Update an alert bot
   * @param boundaryId 
   * @param boundaryAlertBotId 
   * @param updateBoundaryAlertBot 
   * @openapi operation=updateBoundaryAlertBot path=/app/boundaries/{boundaryId}/alertBots/{boundaryAlertBotId} method=PATCH
   */
  public async updateAlertBot(boundaryId: UUID, boundaryAlertBotId: UUID, updateBoundaryAlertBot: UpdateBoundaryAlertBot): Promise<BoundaryAlertBotExtended> {
    // verify required parameter 'boundaryId' is not null or undefined
    if (boundaryId === null || boundaryId === undefined) {
      throw new ParameterRequiredError('boundaryId');
    }
    // verify required parameter 'boundaryAlertBotId' is not null or undefined
    if (boundaryAlertBotId === null || boundaryAlertBotId === undefined) {
      throw new ParameterRequiredError('boundaryAlertBotId');
    }
    // verify required parameter 'updateBoundaryAlertBot' is not null or undefined
    if (updateBoundaryAlertBot === null || updateBoundaryAlertBot === undefined) {
      throw new ParameterRequiredError('updateBoundaryAlertBot');
    }
    return this.producer.updateAlertBot(boundaryId, boundaryAlertBotId, updateBoundaryAlertBot);
  }
  /**
   * Updates a boundary evidence
   * @summary Updates a boundary evidence
   * @param boundaryId 
   * @param evidenceId 
   * @param updateBoundaryEvidence 
   * @openapi operation=updateBoundaryEvidence path=/boundaries/{boundaryId}/evidence/{evidenceId} method=PUT
   */
  public async updateBoundaryEvidence(boundaryId: UUID, evidenceId: UUID, updateBoundaryEvidence: UpdateBoundaryEvidence): Promise<BoundaryEvidence> {
    // verify required parameter 'boundaryId' is not null or undefined
    if (boundaryId === null || boundaryId === undefined) {
      throw new ParameterRequiredError('boundaryId');
    }
    // verify required parameter 'evidenceId' is not null or undefined
    if (evidenceId === null || evidenceId === undefined) {
      throw new ParameterRequiredError('evidenceId');
    }
    // verify required parameter 'updateBoundaryEvidence' is not null or undefined
    if (updateBoundaryEvidence === null || updateBoundaryEvidence === undefined) {
      throw new ParameterRequiredError('updateBoundaryEvidence');
    }
    return this.producer.updateBoundaryEvidence(boundaryId, evidenceId, updateBoundaryEvidence);
  }
  /**
   * Updates a boundary product
   * @summary Updates a boundary product
   * @param boundaryId 
   * @param boundaryProductId 
   * @param updateBoundaryProduct 
   * @openapi operation=updateBoundaryProduct path=/boundaries/{boundaryId}/products/{boundaryProductId} method=PUT
   */
  public async updateBoundaryProduct(boundaryId: UUID, boundaryProductId: UUID, updateBoundaryProduct: UpdateBoundaryProduct): Promise<BoundaryProduct> {
    // verify required parameter 'boundaryId' is not null or undefined
    if (boundaryId === null || boundaryId === undefined) {
      throw new ParameterRequiredError('boundaryId');
    }
    // verify required parameter 'boundaryProductId' is not null or undefined
    if (boundaryProductId === null || boundaryProductId === undefined) {
      throw new ParameterRequiredError('boundaryProductId');
    }
    // verify required parameter 'updateBoundaryProduct' is not null or undefined
    if (updateBoundaryProduct === null || updateBoundaryProduct === undefined) {
      throw new ParameterRequiredError('updateBoundaryProduct');
    }
    return this.producer.updateBoundaryProduct(boundaryId, boundaryProductId, updateBoundaryProduct);
  }
  /**
   * Updates a scf control for a boundary
   * @summary Updates a scf control for a boundary
   * @param boundaryId 
   * @param boundaryScfControlId 
   * @param updateBoundaryScfControl 
   * @openapi operation=updateBoundaryScfControl path=/boundaries/{boundaryId}/scfControls/{boundaryScfControlId} method=PUT
   */
  public async updateBoundaryScfControl(boundaryId: UUID, boundaryScfControlId: UUID, updateBoundaryScfControl: UpdateBoundaryScfControl): Promise<ExtendedBoundaryScfControl> {
    // verify required parameter 'boundaryId' is not null or undefined
    if (boundaryId === null || boundaryId === undefined) {
      throw new ParameterRequiredError('boundaryId');
    }
    // verify required parameter 'boundaryScfControlId' is not null or undefined
    if (boundaryScfControlId === null || boundaryScfControlId === undefined) {
      throw new ParameterRequiredError('boundaryScfControlId');
    }
    // verify required parameter 'updateBoundaryScfControl' is not null or undefined
    if (updateBoundaryScfControl === null || updateBoundaryScfControl === undefined) {
      throw new ParameterRequiredError('updateBoundaryScfControl');
    }
    return this.producer.updateBoundaryScfControl(boundaryId, boundaryScfControlId, updateBoundaryScfControl);
  }
  /**
   * Updates a boundary team
   * @summary Updates a boundary team
   * @param boundaryId 
   * @param teamId 
   * @param updateBoundaryTeam 
   * @openapi operation=updateBoundaryTeam path=/boundaries/{boundaryId}/teams/{teamId} method=PUT
   */
  public async updateBoundaryTeam(boundaryId: UUID, teamId: UUID, updateBoundaryTeam: UpdateBoundaryTeam): Promise<BoundaryTeam> {
    // verify required parameter 'boundaryId' is not null or undefined
    if (boundaryId === null || boundaryId === undefined) {
      throw new ParameterRequiredError('boundaryId');
    }
    // verify required parameter 'teamId' is not null or undefined
    if (teamId === null || teamId === undefined) {
      throw new ParameterRequiredError('teamId');
    }
    // verify required parameter 'updateBoundaryTeam' is not null or undefined
    if (updateBoundaryTeam === null || updateBoundaryTeam === undefined) {
      throw new ParameterRequiredError('updateBoundaryTeam');
    }
    return this.producer.updateBoundaryTeam(boundaryId, teamId, updateBoundaryTeam);
  }
  /**
   * Updates a boundary team scf control question
   * @summary Updates a boundary team scf control question
   * @param boundaryId 
   * @param teamId 
   * @param scfControlId 
   * @param updateBoundaryTeamScfControl 
   * @openapi operation=updateBoundaryTeamScfControl path=/boundaries/{boundaryId}/teams/{teamId}/scfControlTree/{scfControlId} method=PUT
   */
  public async updateBoundaryTeamScfControl(boundaryId: UUID, teamId: UUID, scfControlId: UUID, updateBoundaryTeamScfControl: UpdateBoundaryTeamScfControl): Promise<BoundaryTeamScfControl> {
    // verify required parameter 'boundaryId' is not null or undefined
    if (boundaryId === null || boundaryId === undefined) {
      throw new ParameterRequiredError('boundaryId');
    }
    // verify required parameter 'teamId' is not null or undefined
    if (teamId === null || teamId === undefined) {
      throw new ParameterRequiredError('teamId');
    }
    // verify required parameter 'scfControlId' is not null or undefined
    if (scfControlId === null || scfControlId === undefined) {
      throw new ParameterRequiredError('scfControlId');
    }
    // verify required parameter 'updateBoundaryTeamScfControl' is not null or undefined
    if (updateBoundaryTeamScfControl === null || updateBoundaryTeamScfControl === undefined) {
      throw new ParameterRequiredError('updateBoundaryTeamScfControl');
    }
    return this.producer.updateBoundaryTeamScfControl(boundaryId, teamId, scfControlId, updateBoundaryTeamScfControl);
  }
  /**
   * Updates a boundary team scf control evidence definition implementation
   * @summary Updates a boundary team scf control evidence definition implementation
   * @param boundaryId 
   * @param teamId 
   * @param scfControlId 
   * @param evidenceDefinitionId 
   * @param updateBoundaryTeamScfControlEvidenceDefinition 
   * @openapi operation=updateBoundaryTeamScfControlEvidenceDefinition path=/boundaries/{boundaryId}/teams/{teamId}/scfControlTree/{scfControlId}/evidenceDefinitions/{evidenceDefinitionId} method=PUT
   */
  public async updateBoundaryTeamScfControlEvidenceDefinition(boundaryId: UUID, teamId: UUID, scfControlId: UUID, evidenceDefinitionId: UUID, updateBoundaryTeamScfControlEvidenceDefinition: UpdateBoundaryTeamScfControlEvidenceDefinition): Promise<BoundaryTeamScfControlEvidenceDefinitionImplementation> {
    // verify required parameter 'boundaryId' is not null or undefined
    if (boundaryId === null || boundaryId === undefined) {
      throw new ParameterRequiredError('boundaryId');
    }
    // verify required parameter 'teamId' is not null or undefined
    if (teamId === null || teamId === undefined) {
      throw new ParameterRequiredError('teamId');
    }
    // verify required parameter 'scfControlId' is not null or undefined
    if (scfControlId === null || scfControlId === undefined) {
      throw new ParameterRequiredError('scfControlId');
    }
    // verify required parameter 'evidenceDefinitionId' is not null or undefined
    if (evidenceDefinitionId === null || evidenceDefinitionId === undefined) {
      throw new ParameterRequiredError('evidenceDefinitionId');
    }
    // verify required parameter 'updateBoundaryTeamScfControlEvidenceDefinition' is not null or undefined
    if (updateBoundaryTeamScfControlEvidenceDefinition === null || updateBoundaryTeamScfControlEvidenceDefinition === undefined) {
      throw new ParameterRequiredError('updateBoundaryTeamScfControlEvidenceDefinition');
    }
    return this.producer.updateBoundaryTeamScfControlEvidenceDefinition(boundaryId, teamId, scfControlId, evidenceDefinitionId, updateBoundaryTeamScfControlEvidenceDefinition);
  }
  /**
   * Creates or Updates an alert bot for a query, query version, and boundary
   * @summary Creates or Updates an alert bot for a query, query version, and boundary
   * @param boundaryId 
   * @param newBoundaryAlertBot 
   * @param executeAndVerifyQuery 
   * @openapi operation=upsertBoundaryAlertBot path=/app/boundaries/{boundaryId}/alertBots method=PUT
   */
  public async upsertAlertBot(boundaryId: UUID, newBoundaryAlertBot: NewBoundaryAlertBot, executeAndVerifyQuery: boolean = false): Promise<BoundaryAlertBotExtended> {
    // verify required parameter 'boundaryId' is not null or undefined
    if (boundaryId === null || boundaryId === undefined) {
      throw new ParameterRequiredError('boundaryId');
    }
    // verify required parameter 'newBoundaryAlertBot' is not null or undefined
    if (newBoundaryAlertBot === null || newBoundaryAlertBot === undefined) {
      throw new ParameterRequiredError('newBoundaryAlertBot');
    }
    return this.producer.upsertAlertBot(boundaryId, newBoundaryAlertBot, executeAndVerifyQuery);
  }
  /**
   * Updates a boundary product targets
   * @summary Updates a boundary product targets
   * @param boundaryId 
   * @param boundaryProductId 
   * @param newBoundaryProductTarget 
   * @openapi operation=upsertBoundaryProductTargets path=/boundaries/{boundaryId}/products/{boundaryProductId}/targets method=PUT
   */
  public async upsertBoundaryProductTargets(boundaryId: UUID, boundaryProductId: UUID, newBoundaryProductTarget: NewBoundaryProductTarget): Promise<Array<BoundaryProductTarget>> {
    // verify required parameter 'boundaryId' is not null or undefined
    if (boundaryId === null || boundaryId === undefined) {
      throw new ParameterRequiredError('boundaryId');
    }
    // verify required parameter 'boundaryProductId' is not null or undefined
    if (boundaryProductId === null || boundaryProductId === undefined) {
      throw new ParameterRequiredError('boundaryProductId');
    }
    // verify required parameter 'newBoundaryProductTarget' is not null or undefined
    if (newBoundaryProductTarget === null || newBoundaryProductTarget === undefined) {
      throw new ParameterRequiredError('newBoundaryProductTarget');
    }
    return this.producer.upsertBoundaryProductTargets(boundaryId, boundaryProductId, newBoundaryProductTarget);
  }
  /**
   * Updates a boundarys products
   * @summary Updates a boundarys products
   * @param boundaryId 
   * @param upsertBoundaryProducts 
   * @openapi operation=upsertBoundaryProducts path=/boundaries/{boundaryId}/products method=PUT
   */
  public async upsertBoundaryProducts(boundaryId: UUID, upsertBoundaryProducts: UpsertBoundaryProducts): Promise<Array<BoundaryProduct>> {
    // verify required parameter 'boundaryId' is not null or undefined
    if (boundaryId === null || boundaryId === undefined) {
      throw new ParameterRequiredError('boundaryId');
    }
    // verify required parameter 'upsertBoundaryProducts' is not null or undefined
    if (upsertBoundaryProducts === null || upsertBoundaryProducts === undefined) {
      throw new ParameterRequiredError('upsertBoundaryProducts');
    }
    return this.producer.upsertBoundaryProducts(boundaryId, upsertBoundaryProducts);
  }
}

/**
 * Wrap producer with mapping implementation
 */
export function wrapBoundaryProducer(producer: BoundaryProducerApi): BoundaryApi {
  return new BoundaryApiMappingImpl(producer);
}

/**
 * BoundaryApiHttpImpl - Direct HTTP implementation
 *
 * Makes direct HTTP calls to the API using Axios.
 * Used by SDK clients for platform service access.
 */
export class BoundaryApiHttpImpl implements BoundaryProducerApi {
  private client: AxiosInstance;
  private headers: Record<string, string>;

  constructor(client: AxiosInstance, headers: Record<string, string> = {}) {
    this.client = client;
    this.headers = headers;
  }

  async addCrosswalkVersion(boundaryId: UUID, newBoundaryCrosswalkVersion: NewBoundaryCrosswalkVersion): Promise<BoundaryCrosswalkVersionExtended> {
  const _queryParams = {
      
  };
  const _bodyParams = {
      newBoundaryCrosswalkVersion,
  };
  let _path = '/app/boundaries/{boundaryId}/crosswalkVersions';
  _path = _path.replace('{boundaryId}', encodeURIComponent(String(boundaryId)));
  return this.client.post(
    _path,
    _bodyParams)
    .then((response) => {
      // BaseApiClient uses validateStatus: () => true, so we must check status manually
      if (response.status >= 400) {
        throw CoreError.deserialize(response.data);
      }
      return ObjectSerializer.deserialize(response.data, 'BoundaryCrosswalkVersionExtended')
    })
    .catch((error) => {
      if (error.data) {
        throw CoreError.deserialize(error.data);
      } else {
        throw error;
      }
    });
  }
  async addStandardBaseline(boundaryId: UUID, newBoundaryStandardBaseline: NewBoundaryStandardBaseline): Promise<BoundaryStandardBaselineExtended> {
  const _queryParams = {
      
  };
  const _bodyParams = {
      newBoundaryStandardBaseline,
  };
  let _path = '/app/boundaries/{boundaryId}/standardBaselines';
  _path = _path.replace('{boundaryId}', encodeURIComponent(String(boundaryId)));
  return this.client.post(
    _path,
    _bodyParams)
    .then((response) => {
      // BaseApiClient uses validateStatus: () => true, so we must check status manually
      if (response.status >= 400) {
        throw CoreError.deserialize(response.data);
      }
      return ObjectSerializer.deserialize(response.data, 'BoundaryStandardBaselineExtended')
    })
    .catch((error) => {
      if (error.data) {
        throw CoreError.deserialize(error.data);
      } else {
        throw error;
      }
    });
  }
  async addStandardBaselineElements(boundaryId: UUID, boundaryStandardBaselineId: UUID, newBoundaryStandardBaselineElements: NewBoundaryStandardBaselineElements): Promise<Array<ElementExtended>> {
  const _queryParams = {
      
  };
  const _bodyParams = {
      newBoundaryStandardBaselineElements,
  };
  let _path = '/app/boundaries/{boundaryId}/standardBaselines/{boundaryStandardBaselineId}/elements';
  _path = _path.replace('{boundaryId}', encodeURIComponent(String(boundaryId)));
  _path = _path.replace('{boundaryStandardBaselineId}', encodeURIComponent(String(boundaryStandardBaselineId)));
  return this.client.post(
    _path,
    _bodyParams)
    .then((response) => {
      // BaseApiClient uses validateStatus: () => true, so we must check status manually
      if (response.status >= 400) {
        throw CoreError.deserialize(response.data);
      }
      return ObjectSerializer.deserialize(response.data, 'Array<ElementExtended>')
    })
    .catch((error) => {
      if (error.data) {
        throw CoreError.deserialize(error.data);
      } else {
        throw error;
      }
    });
  }
  async deleteSubscription(boundaryId: UUID, boundaryAlertBotId: UUID, subscriptionId: UUID): Promise<void> {
  const _queryParams = {
      
  };
  const _bodyParams = {
      
  };
  let _path = '/app/boundaries/{boundaryId}/alertBots/{boundaryAlertBotId}/subscriptions/{subscriptionId}';
  _path = _path.replace('{boundaryId}', encodeURIComponent(String(boundaryId)));
  _path = _path.replace('{boundaryAlertBotId}', encodeURIComponent(String(boundaryAlertBotId)));
  _path = _path.replace('{subscriptionId}', encodeURIComponent(String(subscriptionId)));
  return this.client.delete(
    _path,
    { params: _queryParams })
    .then((response) => {
      // BaseApiClient uses validateStatus: () => true, so we must check status manually
      if (response.status >= 400) {
        throw CoreError.deserialize(response.data);
      }
      return ObjectSerializer.deserialize(response.data, '')
    })
    .catch((error) => {
      if (error.data) {
        throw CoreError.deserialize(error.data);
      } else {
        throw error;
      }
    });
  }
  async addSubscription(boundaryId: UUID, boundaryAlertBotId: UUID, newAlertSubscription: NewAlertSubscription): Promise<AlertSubscriptionExtended> {
  const _queryParams = {
      
  };
  const _bodyParams = {
      newAlertSubscription,
  };
  let _path = '/app/boundaries/{boundaryId}/alertBots/{boundaryAlertBotId}/subscriptions';
  _path = _path.replace('{boundaryId}', encodeURIComponent(String(boundaryId)));
  _path = _path.replace('{boundaryAlertBotId}', encodeURIComponent(String(boundaryAlertBotId)));
  return this.client.post(
    _path,
    _bodyParams)
    .then((response) => {
      // BaseApiClient uses validateStatus: () => true, so we must check status manually
      if (response.status >= 400) {
        throw CoreError.deserialize(response.data);
      }
      return ObjectSerializer.deserialize(response.data, 'AlertSubscriptionExtended')
    })
    .catch((error) => {
      if (error.data) {
        throw CoreError.deserialize(error.data);
      } else {
        throw error;
      }
    });
  }
  async boundaryExecuteQuery(boundaryId: UUID, queryId: UUID, executeGraphqlQuery: ExecuteGraphqlQuery): Promise<ExecuteGraphqlQueryResult> {
  const _queryParams = {
      
  };
  const _bodyParams = {
      executeGraphqlQuery,
  };
  let _path = '/app/boundaries/{boundaryId}/queries/{queryId}';
  _path = _path.replace('{boundaryId}', encodeURIComponent(String(boundaryId)));
  _path = _path.replace('{queryId}', encodeURIComponent(String(queryId)));
  return this.client.put(
    _path,
    _bodyParams)
    .then((response) => {
      // BaseApiClient uses validateStatus: () => true, so we must check status manually
      if (response.status >= 400) {
        throw CoreError.deserialize(response.data);
      }
      return ObjectSerializer.deserialize(response.data, 'ExecuteGraphqlQueryResult')
    })
    .catch((error) => {
      if (error.data) {
        throw CoreError.deserialize(error.data);
      } else {
        throw error;
      }
    });
  }
  async boundaryKeywordSearch(boundaryId: UUID, boundaryKeywordSearchBody: BoundaryKeywordSearchBody): Promise<BoundaryKeywordSearchResult> {
  const _queryParams = {
      
  };
  const _bodyParams = {
      boundaryKeywordSearchBody,
  };
  let _path = '/boundaries/{boundaryId}/keywordSearch';
  _path = _path.replace('{boundaryId}', encodeURIComponent(String(boundaryId)));
  return this.client.post(
    _path,
    _bodyParams)
    .then((response) => {
      // BaseApiClient uses validateStatus: () => true, so we must check status manually
      if (response.status >= 400) {
        throw CoreError.deserialize(response.data);
      }
      return ObjectSerializer.deserialize(response.data, 'BoundaryKeywordSearchResult')
    })
    .catch((error) => {
      if (error.data) {
        throw CoreError.deserialize(error.data);
      } else {
        throw error;
      }
    });
  }
  async boundaryKeywordSearchForClass(boundaryId: UUID, classId: UUID, boundaryKeywordSearchBody: BoundaryKeywordSearchBody): Promise<BoundaryKeywordSearchForClassResult> {
  const _queryParams = {
      
  };
  const _bodyParams = {
      boundaryKeywordSearchBody,
  };
  let _path = '/boundaries/{boundaryId}/keywordSearch/{classId}';
  _path = _path.replace('{boundaryId}', encodeURIComponent(String(boundaryId)));
  _path = _path.replace('{classId}', encodeURIComponent(String(classId)));
  return this.client.post(
    _path,
    _bodyParams)
    .then((response) => {
      // BaseApiClient uses validateStatus: () => true, so we must check status manually
      if (response.status >= 400) {
        throw CoreError.deserialize(response.data);
      }
      return ObjectSerializer.deserialize(response.data, 'BoundaryKeywordSearchForClassResult')
    })
    .catch((error) => {
      if (error.data) {
        throw CoreError.deserialize(error.data);
      } else {
        throw error;
      }
    });
  }
  async boundaryObjectCount(boundaryId: UUID, boundaryObjectCountFilter: BoundaryObjectCountFilter): Promise<BoundaryObjectCountResult> {
  const _queryParams = {
      
  };
  const _bodyParams = {
      boundaryObjectCountFilter,
  };
  let _path = '/boundaries/{boundaryId}/objectCount';
  _path = _path.replace('{boundaryId}', encodeURIComponent(String(boundaryId)));
  return this.client.post(
    _path,
    _bodyParams)
    .then((response) => {
      // BaseApiClient uses validateStatus: () => true, so we must check status manually
      if (response.status >= 400) {
        throw CoreError.deserialize(response.data);
      }
      return ObjectSerializer.deserialize(response.data, 'BoundaryObjectCountResult')
    })
    .catch((error) => {
      if (error.data) {
        throw CoreError.deserialize(error.data);
      } else {
        throw error;
      }
    });
  }
  async boundaryObjectSearch(results: PagedResults<BoundarySearchResult>, boundaryId: UUID, boundaryObjectSearchFilter: BoundaryObjectSearchFilter): Promise<void> {
  const _body = {
      boundaryId,boundaryObjectSearchFilter,
  };
  let _path = '/boundaries/{boundaryId}/objectSearch';
  _path = _path.replace('{boundaryId}', encodeURIComponent(String(boundaryId)));
  return this.client.post(
    _path,
    {
      ..._body,
      pageNumber: results.pageNumber,
      pageSize: results.pageSize,
    })
    .then((response) => {
      // BaseApiClient uses validateStatus: () => true, so we must check status manually
      if (response.status >= 400) {
        throw CoreError.deserialize(response.data);
      }
      results.items = ObjectSerializer.deserialize(response.data, 'Array<BoundarySearchResult>');
      results.count = response.headers.count ? Number(response.headers.count) : -1;
      results.pageToken = response.headers.pagetoken ?? response.headers.pageToken;
      results.headers = this.headers;
      results.baseUrl = new URL(`${this.client.getUri()}/boundaries/{boundaryId}/objectSearch`);
      results.httpMethod = HttpMethod.Post;
      results.body = _body;
      results.mapper = (obj) => ObjectSerializer.deserialize(obj, 'BoundarySearchResult');
    })
    .catch((error) => {
      if (error.data) {
        throw CoreError.deserialize(error.data);
      } else {
        throw error;
      }
    });
  }
  async boundaryObjectSearchMetadata(boundaryId: UUID, boundaryObjectSearchFilter: BoundaryObjectSearchFilter): Promise<BoundaryObjectSearchResultsMetadata> {
  const _queryParams = {
      
  };
  const _bodyParams = {
      boundaryObjectSearchFilter,
  };
  let _path = '/boundaries/{boundaryId}/objectSearchMetadata';
  _path = _path.replace('{boundaryId}', encodeURIComponent(String(boundaryId)));
  return this.client.post(
    _path,
    _bodyParams)
    .then((response) => {
      // BaseApiClient uses validateStatus: () => true, so we must check status manually
      if (response.status >= 400) {
        throw CoreError.deserialize(response.data);
      }
      return ObjectSerializer.deserialize(response.data, 'BoundaryObjectSearchResultsMetadata')
    })
    .catch((error) => {
      if (error.data) {
        throw CoreError.deserialize(error.data);
      } else {
        throw error;
      }
    });
  }
  async boundarySearch(results: PagedResults<BoundarySearchResult>, boundaryId: UUID, boundarySearchFilter: BoundarySearchFilter): Promise<void> {
  const _body = {
      boundaryId,boundarySearchFilter,
  };
  let _path = '/boundaries/{boundaryId}/search';
  _path = _path.replace('{boundaryId}', encodeURIComponent(String(boundaryId)));
  return this.client.post(
    _path,
    {
      ..._body,
      pageNumber: results.pageNumber,
      pageSize: results.pageSize,
    })
    .then((response) => {
      // BaseApiClient uses validateStatus: () => true, so we must check status manually
      if (response.status >= 400) {
        throw CoreError.deserialize(response.data);
      }
      results.items = ObjectSerializer.deserialize(response.data, 'Array<BoundarySearchResult>');
      results.count = response.headers.count ? Number(response.headers.count) : -1;
      results.pageToken = response.headers.pagetoken ?? response.headers.pageToken;
      results.headers = this.headers;
      results.baseUrl = new URL(`${this.client.getUri()}/boundaries/{boundaryId}/search`);
      results.httpMethod = HttpMethod.Post;
      results.body = _body;
      results.mapper = (obj) => ObjectSerializer.deserialize(obj, 'BoundarySearchResult');
    })
    .catch((error) => {
      if (error.data) {
        throw CoreError.deserialize(error.data);
      } else {
        throw error;
      }
    });
  }
  async createBoundary(newBoundary: NewBoundary): Promise<Boundary> {
  const _queryParams = {
      
  };
  const _bodyParams = {
      ...newBoundary,
  };
  let _path = '/boundaries';
  return this.client.post(
    _path,
    _bodyParams)
    .then((response) => {
      // BaseApiClient uses validateStatus: () => true, so we must check status manually
      if (response.status >= 400) {
        throw CoreError.deserialize(response.data);
      }
      return ObjectSerializer.deserialize(response.data, 'Boundary')
    })
    .catch((error) => {
      if (error.data) {
        throw CoreError.deserialize(error.data);
      } else {
        throw error;
      }
    });
  }
  async createBoundaryEvent(boundaryId: UUID, newBoundaryEvent: NewBoundaryEvent): Promise<BoundaryEvent> {
  const _queryParams = {
      
  };
  const _bodyParams = {
      newBoundaryEvent,
  };
  let _path = '/boundaries/{boundaryId}/events';
  _path = _path.replace('{boundaryId}', encodeURIComponent(String(boundaryId)));
  return this.client.post(
    _path,
    _bodyParams)
    .then((response) => {
      // BaseApiClient uses validateStatus: () => true, so we must check status manually
      if (response.status >= 400) {
        throw CoreError.deserialize(response.data);
      }
      return ObjectSerializer.deserialize(response.data, 'BoundaryEvent')
    })
    .catch((error) => {
      if (error.data) {
        throw CoreError.deserialize(error.data);
      } else {
        throw error;
      }
    });
  }
  async createBoundaryEvidence(boundaryId: UUID): Promise<CreateBoundaryEvidenceCounts> {
  const _queryParams = {
      
  };
  const _bodyParams = {
      
  };
  let _path = '/boundaries/{boundaryId}/evidence';
  _path = _path.replace('{boundaryId}', encodeURIComponent(String(boundaryId)));
  return this.client.post(
    _path,
    _bodyParams)
    .then((response) => {
      // BaseApiClient uses validateStatus: () => true, so we must check status manually
      if (response.status >= 400) {
        throw CoreError.deserialize(response.data);
      }
      return ObjectSerializer.deserialize(response.data, 'CreateBoundaryEvidenceCounts')
    })
    .catch((error) => {
      if (error.data) {
        throw CoreError.deserialize(error.data);
      } else {
        throw error;
      }
    });
  }
  async createBoundaryParty(boundaryId: UUID, newBoundaryParty: NewBoundaryParty): Promise<PartyExtended> {
  const _queryParams = {
      
  };
  const _bodyParams = {
      newBoundaryParty,
  };
  let _path = '/boundaries/{boundaryId}/parties';
  _path = _path.replace('{boundaryId}', encodeURIComponent(String(boundaryId)));
  return this.client.post(
    _path,
    _bodyParams)
    .then((response) => {
      // BaseApiClient uses validateStatus: () => true, so we must check status manually
      if (response.status >= 400) {
        throw CoreError.deserialize(response.data);
      }
      return ObjectSerializer.deserialize(response.data, 'PartyExtended')
    })
    .catch((error) => {
      if (error.data) {
        throw CoreError.deserialize(error.data);
      } else {
        throw error;
      }
    });
  }
  async createBoundaryPartyRole(boundaryId: UUID, newBoundaryPartyRole: NewBoundaryPartyRole): Promise<BoundaryPartyRoleExtended> {
  const _queryParams = {
      
  };
  const _bodyParams = {
      newBoundaryPartyRole,
  };
  let _path = '/app/boundaries/{boundaryId}/partyRoles';
  _path = _path.replace('{boundaryId}', encodeURIComponent(String(boundaryId)));
  return this.client.post(
    _path,
    _bodyParams)
    .then((response) => {
      // BaseApiClient uses validateStatus: () => true, so we must check status manually
      if (response.status >= 400) {
        throw CoreError.deserialize(response.data);
      }
      return ObjectSerializer.deserialize(response.data, 'BoundaryPartyRoleExtended')
    })
    .catch((error) => {
      if (error.data) {
        throw CoreError.deserialize(error.data);
      } else {
        throw error;
      }
    });
  }
  async createBoundaryProduct(boundaryId: UUID, newBoundaryProduct: NewBoundaryProduct): Promise<BoundaryProductProcessedResponse> {
  const _queryParams = {
      
  };
  const _bodyParams = {
      newBoundaryProduct,
  };
  let _path = '/boundaries/{boundaryId}/products';
  _path = _path.replace('{boundaryId}', encodeURIComponent(String(boundaryId)));
  return this.client.post(
    _path,
    _bodyParams)
    .then((response) => {
      // BaseApiClient uses validateStatus: () => true, so we must check status manually
      if (response.status >= 400) {
        throw CoreError.deserialize(response.data);
      }
      return ObjectSerializer.deserialize(response.data, 'BoundaryProductProcessedResponse')
    })
    .catch((error) => {
      if (error.data) {
        throw CoreError.deserialize(error.data);
      } else {
        throw error;
      }
    });
  }
  async createBoundaryProductTarget(boundaryId: UUID, boundaryProductId: UUID, newBoundaryProductTarget: NewBoundaryProductTarget): Promise<BoundaryProductTargetProcessedResponse> {
  const _queryParams = {
      
  };
  const _bodyParams = {
      newBoundaryProductTarget,
  };
  let _path = '/boundaries/{boundaryId}/products/{boundaryProductId}/targets';
  _path = _path.replace('{boundaryId}', encodeURIComponent(String(boundaryId)));
  _path = _path.replace('{boundaryProductId}', encodeURIComponent(String(boundaryProductId)));
  return this.client.post(
    _path,
    _bodyParams)
    .then((response) => {
      // BaseApiClient uses validateStatus: () => true, so we must check status manually
      if (response.status >= 400) {
        throw CoreError.deserialize(response.data);
      }
      return ObjectSerializer.deserialize(response.data, 'BoundaryProductTargetProcessedResponse')
    })
    .catch((error) => {
      if (error.data) {
        throw CoreError.deserialize(error.data);
      } else {
        throw error;
      }
    });
  }
  async createBoundaryTeam(boundaryId: UUID, newBoundaryTeam: NewBoundaryTeam): Promise<BoundaryTeam> {
  const _queryParams = {
      
  };
  const _bodyParams = {
      newBoundaryTeam,
  };
  let _path = '/boundaries/{boundaryId}/teams';
  _path = _path.replace('{boundaryId}', encodeURIComponent(String(boundaryId)));
  return this.client.post(
    _path,
    _bodyParams)
    .then((response) => {
      // BaseApiClient uses validateStatus: () => true, so we must check status manually
      if (response.status >= 400) {
        throw CoreError.deserialize(response.data);
      }
      return ObjectSerializer.deserialize(response.data, 'BoundaryTeam')
    })
    .catch((error) => {
      if (error.data) {
        throw CoreError.deserialize(error.data);
      } else {
        throw error;
      }
    });
  }
  async createSuggestedProduct(boundaryId: UUID, newSuggestedProduct: NewSuggestedProduct): Promise<SuggestedProduct> {
  const _queryParams = {
      
  };
  const _bodyParams = {
      newSuggestedProduct,
  };
  let _path = '/boundaries/{boundaryId}/suggestedProducts';
  _path = _path.replace('{boundaryId}', encodeURIComponent(String(boundaryId)));
  return this.client.post(
    _path,
    _bodyParams)
    .then((response) => {
      // BaseApiClient uses validateStatus: () => true, so we must check status manually
      if (response.status >= 400) {
        throw CoreError.deserialize(response.data);
      }
      return ObjectSerializer.deserialize(response.data, 'SuggestedProduct')
    })
    .catch((error) => {
      if (error.data) {
        throw CoreError.deserialize(error.data);
      } else {
        throw error;
      }
    });
  }
  async deleteBoundary(boundaryId: UUID): Promise<void> {
  const _queryParams = {
      
  };
  const _bodyParams = {
      
  };
  let _path = '/boundaries/{boundaryId}';
  _path = _path.replace('{boundaryId}', encodeURIComponent(String(boundaryId)));
  return this.client.delete(
    _path,
    { params: _queryParams })
    .then((response) => {
      // BaseApiClient uses validateStatus: () => true, so we must check status manually
      if (response.status >= 400) {
        throw CoreError.deserialize(response.data);
      }
      return ObjectSerializer.deserialize(response.data, '')
    })
    .catch((error) => {
      if (error.data) {
        throw CoreError.deserialize(error.data);
      } else {
        throw error;
      }
    });
  }
  async deleteAlertBot(boundaryId: UUID, boundaryAlertBotId: UUID): Promise<void> {
  const _queryParams = {
      
  };
  const _bodyParams = {
      
  };
  let _path = '/app/boundaries/{boundaryId}/alertBots/{boundaryAlertBotId}';
  _path = _path.replace('{boundaryId}', encodeURIComponent(String(boundaryId)));
  _path = _path.replace('{boundaryAlertBotId}', encodeURIComponent(String(boundaryAlertBotId)));
  return this.client.delete(
    _path,
    { params: _queryParams })
    .then((response) => {
      // BaseApiClient uses validateStatus: () => true, so we must check status manually
      if (response.status >= 400) {
        throw CoreError.deserialize(response.data);
      }
      return ObjectSerializer.deserialize(response.data, '')
    })
    .catch((error) => {
      if (error.data) {
        throw CoreError.deserialize(error.data);
      } else {
        throw error;
      }
    });
  }
  async deleteBoundaryPartyRole(boundaryId: UUID, roleId: UUID, partyId: UUID): Promise<void> {
  const _queryParams = {
      
  };
  const _bodyParams = {
      
  };
  let _path = '/app/boundaries/{boundaryId}/parties/{partyId}/roles/{roleId}';
  _path = _path.replace('{boundaryId}', encodeURIComponent(String(boundaryId)));
  _path = _path.replace('{roleId}', encodeURIComponent(String(roleId)));
  _path = _path.replace('{partyId}', encodeURIComponent(String(partyId)));
  return this.client.delete(
    _path,
    { params: _queryParams })
    .then((response) => {
      // BaseApiClient uses validateStatus: () => true, so we must check status manually
      if (response.status >= 400) {
        throw CoreError.deserialize(response.data);
      }
      return ObjectSerializer.deserialize(response.data, '')
    })
    .catch((error) => {
      if (error.data) {
        throw CoreError.deserialize(error.data);
      } else {
        throw error;
      }
    });
  }
  async deleteBoundaryPartyRoles(boundaryId: UUID): Promise<void> {
  const _queryParams = {
      
  };
  const _bodyParams = {
      
  };
  let _path = '/app/boundaries/{boundaryId}/partyRoles';
  _path = _path.replace('{boundaryId}', encodeURIComponent(String(boundaryId)));
  return this.client.delete(
    _path,
    { params: _queryParams })
    .then((response) => {
      // BaseApiClient uses validateStatus: () => true, so we must check status manually
      if (response.status >= 400) {
        throw CoreError.deserialize(response.data);
      }
      return ObjectSerializer.deserialize(response.data, '')
    })
    .catch((error) => {
      if (error.data) {
        throw CoreError.deserialize(error.data);
      } else {
        throw error;
      }
    });
  }
  async deleteBoundaryProductTargets(boundaryId: UUID, boundaryProductId: UUID, deleteBoundaryProductTarget: DeleteBoundaryProductTarget): Promise<BoundaryProductTargetProcessedResponse> {
  const _queryParams = {
      
  };
  const _bodyParams = {
      deleteBoundaryProductTarget,
  };
  let _path = '/boundaries/{boundaryId}/products/{boundaryProductId}/targets';
  _path = _path.replace('{boundaryId}', encodeURIComponent(String(boundaryId)));
  _path = _path.replace('{boundaryProductId}', encodeURIComponent(String(boundaryProductId)));
  return this.client.delete(
    _path,
    { params: _queryParams })
    .then((response) => {
      // BaseApiClient uses validateStatus: () => true, so we must check status manually
      if (response.status >= 400) {
        throw CoreError.deserialize(response.data);
      }
      return ObjectSerializer.deserialize(response.data, 'BoundaryProductTargetProcessedResponse')
    })
    .catch((error) => {
      if (error.data) {
        throw CoreError.deserialize(error.data);
      } else {
        throw error;
      }
    });
  }
  async deleteBoundaryProducts(boundaryId: UUID, deleteBoundaryProduct: DeleteBoundaryProduct): Promise<BoundaryProductProcessedResponse> {
  const _queryParams = {
      
  };
  const _bodyParams = {
      deleteBoundaryProduct,
  };
  let _path = '/boundaries/{boundaryId}/products';
  _path = _path.replace('{boundaryId}', encodeURIComponent(String(boundaryId)));
  return this.client.delete(
    _path,
    { params: _queryParams })
    .then((response) => {
      // BaseApiClient uses validateStatus: () => true, so we must check status manually
      if (response.status >= 400) {
        throw CoreError.deserialize(response.data);
      }
      return ObjectSerializer.deserialize(response.data, 'BoundaryProductProcessedResponse')
    })
    .catch((error) => {
      if (error.data) {
        throw CoreError.deserialize(error.data);
      } else {
        throw error;
      }
    });
  }
  async deleteBoundaryTeam(boundaryId: UUID, teamId: UUID): Promise<void> {
  const _queryParams = {
      
  };
  const _bodyParams = {
      
  };
  let _path = '/boundaries/{boundaryId}/teams/{teamId}';
  _path = _path.replace('{boundaryId}', encodeURIComponent(String(boundaryId)));
  _path = _path.replace('{teamId}', encodeURIComponent(String(teamId)));
  return this.client.delete(
    _path,
    { params: _queryParams })
    .then((response) => {
      // BaseApiClient uses validateStatus: () => true, so we must check status manually
      if (response.status >= 400) {
        throw CoreError.deserialize(response.data);
      }
      return ObjectSerializer.deserialize(response.data, '')
    })
    .catch((error) => {
      if (error.data) {
        throw CoreError.deserialize(error.data);
      } else {
        throw error;
      }
    });
  }
  async deleteEventsForBoundary(boundaryId: UUID): Promise<void> {
  const _queryParams = {
      
  };
  const _bodyParams = {
      
  };
  let _path = '/boundaries/{boundaryId}/events';
  _path = _path.replace('{boundaryId}', encodeURIComponent(String(boundaryId)));
  return this.client.delete(
    _path,
    { params: _queryParams })
    .then((response) => {
      // BaseApiClient uses validateStatus: () => true, so we must check status manually
      if (response.status >= 400) {
        throw CoreError.deserialize(response.data);
      }
      return ObjectSerializer.deserialize(response.data, '')
    })
    .catch((error) => {
      if (error.data) {
        throw CoreError.deserialize(error.data);
      } else {
        throw error;
      }
    });
  }
  async disableBoundaryTeamScfControlEvidenceDefinition(boundaryId: UUID, teamId: UUID, scfControlId: UUID, evidenceDefinitionId: UUID): Promise<void> {
  const _queryParams = {
      
  };
  const _bodyParams = {
      
  };
  let _path = '/boundaries/{boundaryId}/teams/{teamId}/scfControlTree/{scfControlId}/evidenceDefinitions/{evidenceDefinitionId}';
  _path = _path.replace('{boundaryId}', encodeURIComponent(String(boundaryId)));
  _path = _path.replace('{teamId}', encodeURIComponent(String(teamId)));
  _path = _path.replace('{scfControlId}', encodeURIComponent(String(scfControlId)));
  _path = _path.replace('{evidenceDefinitionId}', encodeURIComponent(String(evidenceDefinitionId)));
  return this.client.delete(
    _path,
    { params: _queryParams })
    .then((response) => {
      // BaseApiClient uses validateStatus: () => true, so we must check status manually
      if (response.status >= 400) {
        throw CoreError.deserialize(response.data);
      }
      return ObjectSerializer.deserialize(response.data, '')
    })
    .catch((error) => {
      if (error.data) {
        throw CoreError.deserialize(error.data);
      } else {
        throw error;
      }
    });
  }
  async enableBoundaryTeamScfControlEvidenceDefinition(boundaryId: UUID, teamId: UUID, scfControlId: UUID, enableBoundaryTeamScfControlEvidenceDefinition: EnableBoundaryTeamScfControlEvidenceDefinition): Promise<BoundaryTeamScfControlEvidenceDefinitionImplementation> {
  const _queryParams = {
      
  };
  const _bodyParams = {
      enableBoundaryTeamScfControlEvidenceDefinition,
  };
  let _path = '/boundaries/{boundaryId}/teams/{teamId}/scfControlTree/{scfControlId}/evidenceDefinitions';
  _path = _path.replace('{boundaryId}', encodeURIComponent(String(boundaryId)));
  _path = _path.replace('{teamId}', encodeURIComponent(String(teamId)));
  _path = _path.replace('{scfControlId}', encodeURIComponent(String(scfControlId)));
  return this.client.post(
    _path,
    _bodyParams)
    .then((response) => {
      // BaseApiClient uses validateStatus: () => true, so we must check status manually
      if (response.status >= 400) {
        throw CoreError.deserialize(response.data);
      }
      return ObjectSerializer.deserialize(response.data, 'BoundaryTeamScfControlEvidenceDefinitionImplementation')
    })
    .catch((error) => {
      if (error.data) {
        throw CoreError.deserialize(error.data);
      } else {
        throw error;
      }
    });
  }
  async getAnyBoundaryProduct(boundaryId: UUID, boundaryProductId: UUID): Promise<BoundaryProductAny> {
  const _queryParams = {
      
  };
  const _bodyParams = {
      
  };
  let _path = '/boundaries/{boundaryId}/allProducts/{boundaryProductId}';
  _path = _path.replace('{boundaryId}', encodeURIComponent(String(boundaryId)));
  _path = _path.replace('{boundaryProductId}', encodeURIComponent(String(boundaryProductId)));
  return this.client.get(
    _path,
    { params: _queryParams })
    .then((response) => {
      // BaseApiClient uses validateStatus: () => true, so we must check status manually
      if (response.status >= 400) {
        throw CoreError.deserialize(response.data);
      }
      return ObjectSerializer.deserialize(response.data, 'BoundaryProductAny')
    })
    .catch((error) => {
      if (error.data) {
        throw CoreError.deserialize(error.data);
      } else {
        throw error;
      }
    });
  }
  async getBoundary(boundaryId: UUID): Promise<BoundaryExtended> {
  const _queryParams = {
      
  };
  const _bodyParams = {
      
  };
  let _path = '/boundaries/{boundaryId}';
  _path = _path.replace('{boundaryId}', encodeURIComponent(String(boundaryId)));
  return this.client.get(
    _path,
    { params: _queryParams })
    .then((response) => {
      // BaseApiClient uses validateStatus: () => true, so we must check status manually
      if (response.status >= 400) {
        throw CoreError.deserialize(response.data);
      }
      return ObjectSerializer.deserialize(response.data, 'BoundaryExtended')
    })
    .catch((error) => {
      if (error.data) {
        throw CoreError.deserialize(error.data);
      } else {
        throw error;
      }
    });
  }
  async getBoundaryAlert(boundaryId: UUID, id: UUID): Promise<BoundaryAlertExtended> {
  const _queryParams = {
      
  };
  const _bodyParams = {
      
  };
  let _path = '/app/boundaries/{boundaryId}/alerts/{id}';
  _path = _path.replace('{boundaryId}', encodeURIComponent(String(boundaryId)));
  _path = _path.replace('{id}', encodeURIComponent(String(id)));
  return this.client.get(
    _path,
    { params: _queryParams })
    .then((response) => {
      // BaseApiClient uses validateStatus: () => true, so we must check status manually
      if (response.status >= 400) {
        throw CoreError.deserialize(response.data);
      }
      return ObjectSerializer.deserialize(response.data, 'BoundaryAlertExtended')
    })
    .catch((error) => {
      if (error.data) {
        throw CoreError.deserialize(error.data);
      } else {
        throw error;
      }
    });
  }
  async getBoundaryComponent(boundaryId: UUID, componentId: UUID): Promise<BoundaryComponentExtended> {
  const _queryParams = {
      
  };
  const _bodyParams = {
      
  };
  let _path = '/app/boundaries/{boundaryId}/components/{componentId}';
  _path = _path.replace('{boundaryId}', encodeURIComponent(String(boundaryId)));
  _path = _path.replace('{componentId}', encodeURIComponent(String(componentId)));
  return this.client.get(
    _path,
    { params: _queryParams })
    .then((response) => {
      // BaseApiClient uses validateStatus: () => true, so we must check status manually
      if (response.status >= 400) {
        throw CoreError.deserialize(response.data);
      }
      return ObjectSerializer.deserialize(response.data, 'BoundaryComponentExtended')
    })
    .catch((error) => {
      if (error.data) {
        throw CoreError.deserialize(error.data);
      } else {
        throw error;
      }
    });
  }
  async getBoundaryConnectionOverview(boundaryId: UUID, connectionId: UUID): Promise<BoundaryConnectionOverview> {
  const _queryParams = {
      
  };
  const _bodyParams = {
      
  };
  let _path = '/boundaries/{boundaryId}/connections/{connectionId}';
  _path = _path.replace('{boundaryId}', encodeURIComponent(String(boundaryId)));
  _path = _path.replace('{connectionId}', encodeURIComponent(String(connectionId)));
  return this.client.get(
    _path,
    { params: _queryParams })
    .then((response) => {
      // BaseApiClient uses validateStatus: () => true, so we must check status manually
      if (response.status >= 400) {
        throw CoreError.deserialize(response.data);
      }
      return ObjectSerializer.deserialize(response.data, 'BoundaryConnectionOverview')
    })
    .catch((error) => {
      if (error.data) {
        throw CoreError.deserialize(error.data);
      } else {
        throw error;
      }
    });
  }
  async getBoundaryDomainSummary(boundaryId: UUID, sourceId?: UUID): Promise<BoundaryDomainSummary> {
  const _queryParams = {
      sourceId,
  };
  const _bodyParams = {
      
  };
  let _path = '/boundaries/{boundaryId}/domains';
  _path = _path.replace('{boundaryId}', encodeURIComponent(String(boundaryId)));
  return this.client.get(
    _path,
    { params: _queryParams })
    .then((response) => {
      // BaseApiClient uses validateStatus: () => true, so we must check status manually
      if (response.status >= 400) {
        throw CoreError.deserialize(response.data);
      }
      return ObjectSerializer.deserialize(response.data, 'BoundaryDomainSummary')
    })
    .catch((error) => {
      if (error.data) {
        throw CoreError.deserialize(error.data);
      } else {
        throw error;
      }
    });
  }
  async getBoundaryEvidence(boundaryId: UUID, evidenceId: UUID): Promise<BoundaryEvidence & ExtendedBoundaryEvidence> {
  const _queryParams = {
      
  };
  const _bodyParams = {
      
  };
  let _path = '/boundaries/{boundaryId}/evidence/{evidenceId}';
  _path = _path.replace('{boundaryId}', encodeURIComponent(String(boundaryId)));
  _path = _path.replace('{evidenceId}', encodeURIComponent(String(evidenceId)));
  return this.client.get(
    _path,
    { params: _queryParams })
    .then((response) => {
      // BaseApiClient uses validateStatus: () => true, so we must check status manually
      if (response.status >= 400) {
        throw CoreError.deserialize(response.data);
      }
      return ObjectSerializer.deserialize(response.data, 'BoundaryEvidence & ExtendedBoundaryEvidence')
    })
    .catch((error) => {
      if (error.data) {
        throw CoreError.deserialize(error.data);
      } else {
        throw error;
      }
    });
  }
  async getBoundaryMetrics(boundaryId: UUID): Promise<BoundaryMetric> {
  const _queryParams = {
      
  };
  const _bodyParams = {
      
  };
  let _path = '/boundaries/{boundaryId}/metrics';
  _path = _path.replace('{boundaryId}', encodeURIComponent(String(boundaryId)));
  return this.client.get(
    _path,
    { params: _queryParams })
    .then((response) => {
      // BaseApiClient uses validateStatus: () => true, so we must check status manually
      if (response.status >= 400) {
        throw CoreError.deserialize(response.data);
      }
      return ObjectSerializer.deserialize(response.data, 'BoundaryMetric')
    })
    .catch((error) => {
      if (error.data) {
        throw CoreError.deserialize(error.data);
      } else {
        throw error;
      }
    });
  }
  async getBoundaryParty(boundaryId: UUID, partyId: UUID): Promise<PartyExtended> {
  const _queryParams = {
      
  };
  const _bodyParams = {
      
  };
  let _path = '/boundaries/{boundaryId}/parties/{partyId}';
  _path = _path.replace('{boundaryId}', encodeURIComponent(String(boundaryId)));
  _path = _path.replace('{partyId}', encodeURIComponent(String(partyId)));
  return this.client.get(
    _path,
    { params: _queryParams })
    .then((response) => {
      // BaseApiClient uses validateStatus: () => true, so we must check status manually
      if (response.status >= 400) {
        throw CoreError.deserialize(response.data);
      }
      return ObjectSerializer.deserialize(response.data, 'PartyExtended')
    })
    .catch((error) => {
      if (error.data) {
        throw CoreError.deserialize(error.data);
      } else {
        throw error;
      }
    });
  }
  async getBoundaryPartyRole(boundaryId: UUID, roleId: UUID, partyId: UUID): Promise<BoundaryPartyRoleExtended> {
  const _queryParams = {
      
  };
  const _bodyParams = {
      
  };
  let _path = '/app/boundaries/{boundaryId}/parties/{partyId}/roles/{roleId}';
  _path = _path.replace('{boundaryId}', encodeURIComponent(String(boundaryId)));
  _path = _path.replace('{roleId}', encodeURIComponent(String(roleId)));
  _path = _path.replace('{partyId}', encodeURIComponent(String(partyId)));
  return this.client.get(
    _path,
    { params: _queryParams })
    .then((response) => {
      // BaseApiClient uses validateStatus: () => true, so we must check status manually
      if (response.status >= 400) {
        throw CoreError.deserialize(response.data);
      }
      return ObjectSerializer.deserialize(response.data, 'BoundaryPartyRoleExtended')
    })
    .catch((error) => {
      if (error.data) {
        throw CoreError.deserialize(error.data);
      } else {
        throw error;
      }
    });
  }
  async getBoundaryProduct(boundaryId: UUID, boundaryProductId: UUID): Promise<BoundaryProduct & ExtendedBoundaryProduct> {
  const _queryParams = {
      
  };
  const _bodyParams = {
      
  };
  let _path = '/boundaries/{boundaryId}/products/{boundaryProductId}';
  _path = _path.replace('{boundaryId}', encodeURIComponent(String(boundaryId)));
  _path = _path.replace('{boundaryProductId}', encodeURIComponent(String(boundaryProductId)));
  return this.client.get(
    _path,
    { params: _queryParams })
    .then((response) => {
      // BaseApiClient uses validateStatus: () => true, so we must check status manually
      if (response.status >= 400) {
        throw CoreError.deserialize(response.data);
      }
      return ObjectSerializer.deserialize(response.data, 'BoundaryProduct & ExtendedBoundaryProduct')
    })
    .catch((error) => {
      if (error.data) {
        throw CoreError.deserialize(error.data);
      } else {
        throw error;
      }
    });
  }
  async getBoundaryProductConnectionOverview(boundaryId: UUID, boundaryProductId: UUID, connectionId: UUID): Promise<BoundaryConnectionOverview> {
  const _queryParams = {
      
  };
  const _bodyParams = {
      
  };
  let _path = '/boundaries/{boundaryId}/products/{boundaryProductId}/connections/{connectionId}';
  _path = _path.replace('{boundaryId}', encodeURIComponent(String(boundaryId)));
  _path = _path.replace('{boundaryProductId}', encodeURIComponent(String(boundaryProductId)));
  _path = _path.replace('{connectionId}', encodeURIComponent(String(connectionId)));
  return this.client.get(
    _path,
    { params: _queryParams })
    .then((response) => {
      // BaseApiClient uses validateStatus: () => true, so we must check status manually
      if (response.status >= 400) {
        throw CoreError.deserialize(response.data);
      }
      return ObjectSerializer.deserialize(response.data, 'BoundaryConnectionOverview')
    })
    .catch((error) => {
      if (error.data) {
        throw CoreError.deserialize(error.data);
      } else {
        throw error;
      }
    });
  }
  async getBoundaryProductOverview(boundaryId: UUID, boundaryProductId: UUID): Promise<BoundaryProductOverview> {
  const _queryParams = {
      
  };
  const _bodyParams = {
      
  };
  let _path = '/boundaries/{boundaryId}/products/{boundaryProductId}/overviews';
  _path = _path.replace('{boundaryId}', encodeURIComponent(String(boundaryId)));
  _path = _path.replace('{boundaryProductId}', encodeURIComponent(String(boundaryProductId)));
  return this.client.get(
    _path,
    { params: _queryParams })
    .then((response) => {
      // BaseApiClient uses validateStatus: () => true, so we must check status manually
      if (response.status >= 400) {
        throw CoreError.deserialize(response.data);
      }
      return ObjectSerializer.deserialize(response.data, 'BoundaryProductOverview')
    })
    .catch((error) => {
      if (error.data) {
        throw CoreError.deserialize(error.data);
      } else {
        throw error;
      }
    });
  }
  async getBoundaryScfControl(boundaryId: UUID, boundaryScfControlId: UUID): Promise<ExtendedBoundaryScfControl> {
  const _queryParams = {
      
  };
  const _bodyParams = {
      
  };
  let _path = '/boundaries/{boundaryId}/scfControls/{boundaryScfControlId}';
  _path = _path.replace('{boundaryId}', encodeURIComponent(String(boundaryId)));
  _path = _path.replace('{boundaryScfControlId}', encodeURIComponent(String(boundaryScfControlId)));
  return this.client.get(
    _path,
    { params: _queryParams })
    .then((response) => {
      // BaseApiClient uses validateStatus: () => true, so we must check status manually
      if (response.status >= 400) {
        throw CoreError.deserialize(response.data);
      }
      return ObjectSerializer.deserialize(response.data, 'ExtendedBoundaryScfControl')
    })
    .catch((error) => {
      if (error.data) {
        throw CoreError.deserialize(error.data);
      } else {
        throw error;
      }
    });
  }
  async getStandardBaseline(boundaryId: UUID, boundaryStandardBaselineId: UUID): Promise<BoundaryStandardBaselineExtended> {
  const _queryParams = {
      
  };
  const _bodyParams = {
      
  };
  let _path = '/app/boundaries/{boundaryId}/standardBaselines/{boundaryStandardBaselineId}';
  _path = _path.replace('{boundaryId}', encodeURIComponent(String(boundaryId)));
  _path = _path.replace('{boundaryStandardBaselineId}', encodeURIComponent(String(boundaryStandardBaselineId)));
  return this.client.get(
    _path,
    { params: _queryParams })
    .then((response) => {
      // BaseApiClient uses validateStatus: () => true, so we must check status manually
      if (response.status >= 400) {
        throw CoreError.deserialize(response.data);
      }
      return ObjectSerializer.deserialize(response.data, 'BoundaryStandardBaselineExtended')
    })
    .catch((error) => {
      if (error.data) {
        throw CoreError.deserialize(error.data);
      } else {
        throw error;
      }
    });
  }
  async getStandardBaselineFilterTree(boundaryId: UUID, boundaryStandardBaselineId: UUID): Promise<{ [key: string]: StandardFilterTreeNode; }> {
  const _queryParams = {
      
  };
  const _bodyParams = {
      
  };
  let _path = '/app/boundaries/{boundaryId}/standardBaselines/{boundaryStandardBaselineId}/filterTree';
  _path = _path.replace('{boundaryId}', encodeURIComponent(String(boundaryId)));
  _path = _path.replace('{boundaryStandardBaselineId}', encodeURIComponent(String(boundaryStandardBaselineId)));
  return this.client.get(
    _path,
    { params: _queryParams })
    .then((response) => {
      // BaseApiClient uses validateStatus: () => true, so we must check status manually
      if (response.status >= 400) {
        throw CoreError.deserialize(response.data);
      }
      return ObjectSerializer.deserialize(response.data, '{ [key: string]: StandardFilterTreeNode; }')
    })
    .catch((error) => {
      if (error.data) {
        throw CoreError.deserialize(error.data);
      } else {
        throw error;
      }
    });
  }
  async getBoundarySuggestedProductOverview(boundaryId: UUID, boundarySuggestedProductId: UUID): Promise<BoundarySuggestedProductOverview> {
  const _queryParams = {
      
  };
  const _bodyParams = {
      
  };
  let _path = '/boundaries/{boundaryId}/suggestedProducts/{boundarySuggestedProductId}/overviews';
  _path = _path.replace('{boundaryId}', encodeURIComponent(String(boundaryId)));
  _path = _path.replace('{boundarySuggestedProductId}', encodeURIComponent(String(boundarySuggestedProductId)));
  return this.client.get(
    _path,
    { params: _queryParams })
    .then((response) => {
      // BaseApiClient uses validateStatus: () => true, so we must check status manually
      if (response.status >= 400) {
        throw CoreError.deserialize(response.data);
      }
      return ObjectSerializer.deserialize(response.data, 'BoundarySuggestedProductOverview')
    })
    .catch((error) => {
      if (error.data) {
        throw CoreError.deserialize(error.data);
      } else {
        throw error;
      }
    });
  }
  async getBoundaryTaskMetrics(boundaryId: UUID, pageNumber?: number, pageSize?: number): Promise<BoundaryTaskMetrics> {
  const _queryParams = {
      pageNumber,pageSize,
  };
  const _bodyParams = {
      
  };
  let _path = '/boundaries/{boundaryId}/taskMetrics';
  _path = _path.replace('{boundaryId}', encodeURIComponent(String(boundaryId)));
  return this.client.get(
    _path,
    { params: _queryParams })
    .then((response) => {
      // BaseApiClient uses validateStatus: () => true, so we must check status manually
      if (response.status >= 400) {
        throw CoreError.deserialize(response.data);
      }
      return ObjectSerializer.deserialize(response.data, 'BoundaryTaskMetrics')
    })
    .catch((error) => {
      if (error.data) {
        throw CoreError.deserialize(error.data);
      } else {
        throw error;
      }
    });
  }
  async getBoundaryTeam(boundaryId: UUID, teamId: UUID): Promise<BoundaryTeam> {
  const _queryParams = {
      
  };
  const _bodyParams = {
      
  };
  let _path = '/boundaries/{boundaryId}/teams/{teamId}';
  _path = _path.replace('{boundaryId}', encodeURIComponent(String(boundaryId)));
  _path = _path.replace('{teamId}', encodeURIComponent(String(teamId)));
  return this.client.get(
    _path,
    { params: _queryParams })
    .then((response) => {
      // BaseApiClient uses validateStatus: () => true, so we must check status manually
      if (response.status >= 400) {
        throw CoreError.deserialize(response.data);
      }
      return ObjectSerializer.deserialize(response.data, 'BoundaryTeam')
    })
    .catch((error) => {
      if (error.data) {
        throw CoreError.deserialize(error.data);
      } else {
        throw error;
      }
    });
  }
  async getBoundaryTeamDomainSummary(boundaryId: UUID, teamId: UUID, sourceId?: UUID): Promise<BoundaryTeamDomainSummary> {
  const _queryParams = {
      sourceId,
  };
  const _bodyParams = {
      
  };
  let _path = '/boundaries/{boundaryId}/teams/{teamId}/domains';
  _path = _path.replace('{boundaryId}', encodeURIComponent(String(boundaryId)));
  _path = _path.replace('{teamId}', encodeURIComponent(String(teamId)));
  return this.client.get(
    _path,
    { params: _queryParams })
    .then((response) => {
      // BaseApiClient uses validateStatus: () => true, so we must check status manually
      if (response.status >= 400) {
        throw CoreError.deserialize(response.data);
      }
      return ObjectSerializer.deserialize(response.data, 'BoundaryTeamDomainSummary')
    })
    .catch((error) => {
      if (error.data) {
        throw CoreError.deserialize(error.data);
      } else {
        throw error;
      }
    });
  }
  async getBoundaryTeamMetric(boundaryId: UUID, teamId: UUID): Promise<BoundaryTeamMetrics> {
  const _queryParams = {
      
  };
  const _bodyParams = {
      
  };
  let _path = '/boundaries/{boundaryId}/teamMetrics/{teamId}';
  _path = _path.replace('{boundaryId}', encodeURIComponent(String(boundaryId)));
  _path = _path.replace('{teamId}', encodeURIComponent(String(teamId)));
  return this.client.get(
    _path,
    { params: _queryParams })
    .then((response) => {
      // BaseApiClient uses validateStatus: () => true, so we must check status manually
      if (response.status >= 400) {
        throw CoreError.deserialize(response.data);
      }
      return ObjectSerializer.deserialize(response.data, 'BoundaryTeamMetrics')
    })
    .catch((error) => {
      if (error.data) {
        throw CoreError.deserialize(error.data);
      } else {
        throw error;
      }
    });
  }
  async getBoundaryTeamScfControl(boundaryId: UUID, teamId: UUID, scfControlId: UUID): Promise<BoundaryTeamScfControl> {
  const _queryParams = {
      
  };
  const _bodyParams = {
      
  };
  let _path = '/boundaries/{boundaryId}/teams/{teamId}/scfControls/{scfControlId}';
  _path = _path.replace('{boundaryId}', encodeURIComponent(String(boundaryId)));
  _path = _path.replace('{teamId}', encodeURIComponent(String(teamId)));
  _path = _path.replace('{scfControlId}', encodeURIComponent(String(scfControlId)));
  return this.client.get(
    _path,
    { params: _queryParams })
    .then((response) => {
      // BaseApiClient uses validateStatus: () => true, so we must check status manually
      if (response.status >= 400) {
        throw CoreError.deserialize(response.data);
      }
      return ObjectSerializer.deserialize(response.data, 'BoundaryTeamScfControl')
    })
    .catch((error) => {
      if (error.data) {
        throw CoreError.deserialize(error.data);
      } else {
        throw error;
      }
    });
  }
  async getBoundaryTeamScfControlDetails(boundaryId: UUID, teamId: UUID, scfControlId: UUID): Promise<BoundaryTeamScfControlOverview> {
  const _queryParams = {
      
  };
  const _bodyParams = {
      
  };
  let _path = '/boundaries/{boundaryId}/teams/{teamId}/scfControlTree/{scfControlId}';
  _path = _path.replace('{boundaryId}', encodeURIComponent(String(boundaryId)));
  _path = _path.replace('{teamId}', encodeURIComponent(String(teamId)));
  _path = _path.replace('{scfControlId}', encodeURIComponent(String(scfControlId)));
  return this.client.get(
    _path,
    { params: _queryParams })
    .then((response) => {
      // BaseApiClient uses validateStatus: () => true, so we must check status manually
      if (response.status >= 400) {
        throw CoreError.deserialize(response.data);
      }
      return ObjectSerializer.deserialize(response.data, 'BoundaryTeamScfControlOverview')
    })
    .catch((error) => {
      if (error.data) {
        throw CoreError.deserialize(error.data);
      } else {
        throw error;
      }
    });
  }
  async getBoundaryTeamScfControlOverview(boundaryId: UUID, teamId: UUID, frameworkVersionId?: UUID): Promise<BoundaryFrameworkControlsOverview> {
  const _queryParams = {
      frameworkVersionId,
  };
  const _bodyParams = {
      
  };
  let _path = '/boundaries/{boundaryId}/teams/{teamId}/scfControlOverview';
  _path = _path.replace('{boundaryId}', encodeURIComponent(String(boundaryId)));
  _path = _path.replace('{teamId}', encodeURIComponent(String(teamId)));
  return this.client.get(
    _path,
    { params: _queryParams })
    .then((response) => {
      // BaseApiClient uses validateStatus: () => true, so we must check status manually
      if (response.status >= 400) {
        throw CoreError.deserialize(response.data);
      }
      return ObjectSerializer.deserialize(response.data, 'BoundaryFrameworkControlsOverview')
    })
    .catch((error) => {
      if (error.data) {
        throw CoreError.deserialize(error.data);
      } else {
        throw error;
      }
    });
  }
  async getBoundaryTeamScfControlTree(boundaryId: UUID, teamId: UUID, frameworkVersionId?: UUID): Promise<{ [key: string]: BoundaryFrameworkControlTreeNode; }> {
  const _queryParams = {
      frameworkVersionId,
  };
  const _bodyParams = {
      
  };
  let _path = '/boundaries/{boundaryId}/teams/{teamId}/scfControlTree';
  _path = _path.replace('{boundaryId}', encodeURIComponent(String(boundaryId)));
  _path = _path.replace('{teamId}', encodeURIComponent(String(teamId)));
  return this.client.get(
    _path,
    { params: _queryParams })
    .then((response) => {
      // BaseApiClient uses validateStatus: () => true, so we must check status manually
      if (response.status >= 400) {
        throw CoreError.deserialize(response.data);
      }
      return ObjectSerializer.deserialize(response.data, '{ [key: string]: BoundaryFrameworkControlTreeNode; }')
    })
    .catch((error) => {
      if (error.data) {
        throw CoreError.deserialize(error.data);
      } else {
        throw error;
      }
    });
  }
  async getTest(boundaryId: UUID, testId: UUID): Promise<TestExtended> {
  const _queryParams = {
      
  };
  const _bodyParams = {
      
  };
  let _path = '/app/boundaries/{boundaryId}/tests/{testId}';
  _path = _path.replace('{boundaryId}', encodeURIComponent(String(boundaryId)));
  _path = _path.replace('{testId}', encodeURIComponent(String(testId)));
  return this.client.get(
    _path,
    { params: _queryParams })
    .then((response) => {
      // BaseApiClient uses validateStatus: () => true, so we must check status manually
      if (response.status >= 400) {
        throw CoreError.deserialize(response.data);
      }
      return ObjectSerializer.deserialize(response.data, 'TestExtended')
    })
    .catch((error) => {
      if (error.data) {
        throw CoreError.deserialize(error.data);
      } else {
        throw error;
      }
    });
  }
  async listAllBoundaryProducts(results: PagedResults<BoundaryProductForList>, boundaryId: UUID, keywords?: string, status?: BoundaryProductForListStatusDef, sort?: SortObject): Promise<void> {
  const _body = {
      boundaryId,keywords,status,sort,
  };
  let _path = '/boundaries/{boundaryId}/allProducts';
  _path = _path.replace('{boundaryId}', encodeURIComponent(String(boundaryId)));
  return this.client.get(
    _path,
    {
      params: {
        ..._body,
        pageNumber: results.pageNumber,
        pageSize: results.pageSize,
      }
    })
    .then((response) => {
      // BaseApiClient uses validateStatus: () => true, so we must check status manually
      if (response.status >= 400) {
        throw CoreError.deserialize(response.data);
      }
      results.items = ObjectSerializer.deserialize(response.data, 'Array<BoundaryProductForList>');
      results.count = response.headers.count ? Number(response.headers.count) : -1;
      results.pageToken = response.headers.pagetoken ?? response.headers.pageToken;
      results.headers = this.headers;
      results.baseUrl = new URL(`${this.client.getUri()}/boundaries/{boundaryId}/allProducts`);
      results.httpMethod = HttpMethod.Get;
      results.body = _body;
      results.mapper = (obj) => ObjectSerializer.deserialize(obj, 'BoundaryProductForList');
    })
    .catch((error) => {
      if (error.data) {
        throw CoreError.deserialize(error.data);
      } else {
        throw error;
      }
    });
  }
  async listBoundaries(results: PagedResults<BoundaryExtended>, name?: string, status?: BoundaryStatusEnumDef, type?: BoundaryTypeEnumDef, sort?: SortObject): Promise<void> {
  const _body = {
      name,status,type,sort,
  };
  let _path = '/boundaries';
  return this.client.get(
    _path,
    {
      params: {
        ..._body,
        pageNumber: results.pageNumber,
        pageSize: results.pageSize,
      }
    })
    .then((response) => {
      // BaseApiClient uses validateStatus: () => true, so we must check status manually
      if (response.status >= 400) {
        throw CoreError.deserialize(response.data);
      }
      results.items = ObjectSerializer.deserialize(response.data, 'Array<BoundaryExtended>');
      results.count = response.headers.count ? Number(response.headers.count) : -1;
      results.pageToken = response.headers.pagetoken ?? response.headers.pageToken;
      results.headers = this.headers;
      results.baseUrl = new URL(`${this.client.getUri()}/boundaries`);
      results.httpMethod = HttpMethod.Get;
      results.body = _body;
      results.mapper = (obj) => ObjectSerializer.deserialize(obj, 'BoundaryExtended');
    })
    .catch((error) => {
      if (error.data) {
        throw CoreError.deserialize(error.data);
      } else {
        throw error;
      }
    });
  }
  async listAlertBotAlerts(results: PagedResults<BoundaryAlertView>, boundaryId: UUID, boundaryAlertBotId: UUID, sort?: SortObject): Promise<void> {
  const _body = {
      boundaryId,boundaryAlertBotId,sort,
  };
  let _path = '/app/boundaries/{boundaryId}/alertBots/{boundaryAlertBotId}/alerts';
  _path = _path.replace('{boundaryId}', encodeURIComponent(String(boundaryId)));
  _path = _path.replace('{boundaryAlertBotId}', encodeURIComponent(String(boundaryAlertBotId)));
  return this.client.get(
    _path,
    {
      params: {
        ..._body,
        pageNumber: results.pageNumber,
        pageSize: results.pageSize,
      }
    })
    .then((response) => {
      // BaseApiClient uses validateStatus: () => true, so we must check status manually
      if (response.status >= 400) {
        throw CoreError.deserialize(response.data);
      }
      results.items = ObjectSerializer.deserialize(response.data, 'Array<BoundaryAlertView>');
      results.count = response.headers.count ? Number(response.headers.count) : -1;
      results.pageToken = response.headers.pagetoken ?? response.headers.pageToken;
      results.headers = this.headers;
      results.baseUrl = new URL(`${this.client.getUri()}/app/boundaries/{boundaryId}/alertBots/{boundaryAlertBotId}/alerts`);
      results.httpMethod = HttpMethod.Get;
      results.body = _body;
      results.mapper = (obj) => ObjectSerializer.deserialize(obj, 'BoundaryAlertView');
    })
    .catch((error) => {
      if (error.data) {
        throw CoreError.deserialize(error.data);
      } else {
        throw error;
      }
    });
  }
  async listBoundaryAlertSubjects(results: PagedResults<BoundaryAlertSubjectExtended>, boundaryId: UUID, id: UUID, sort?: SortObject): Promise<void> {
  const _body = {
      boundaryId,id,sort,
  };
  let _path = '/app/boundaries/{boundaryId}/alerts/{id}/subjects';
  _path = _path.replace('{boundaryId}', encodeURIComponent(String(boundaryId)));
  _path = _path.replace('{id}', encodeURIComponent(String(id)));
  return this.client.get(
    _path,
    {
      params: {
        ..._body,
        pageNumber: results.pageNumber,
        pageSize: results.pageSize,
      }
    })
    .then((response) => {
      // BaseApiClient uses validateStatus: () => true, so we must check status manually
      if (response.status >= 400) {
        throw CoreError.deserialize(response.data);
      }
      results.items = ObjectSerializer.deserialize(response.data, 'Array<BoundaryAlertSubjectExtended>');
      results.count = response.headers.count ? Number(response.headers.count) : -1;
      results.pageToken = response.headers.pagetoken ?? response.headers.pageToken;
      results.headers = this.headers;
      results.baseUrl = new URL(`${this.client.getUri()}/app/boundaries/{boundaryId}/alerts/{id}/subjects`);
      results.httpMethod = HttpMethod.Get;
      results.body = _body;
      results.mapper = (obj) => ObjectSerializer.deserialize(obj, 'BoundaryAlertSubjectExtended');
    })
    .catch((error) => {
      if (error.data) {
        throw CoreError.deserialize(error.data);
      } else {
        throw error;
      }
    });
  }
  async listAlertBotSubscriptions(results: PagedResults<AlertSubscriptionExtended>, boundaryAlertBotId: UUID, boundaryId: UUID, sort?: SortObject): Promise<void> {
  const _body = {
      boundaryAlertBotId,boundaryId,sort,
  };
  let _path = '/app/boundaries/{boundaryId}/alertBots/{boundaryAlertBotId}/subscriptions';
  _path = _path.replace('{boundaryAlertBotId}', encodeURIComponent(String(boundaryAlertBotId)));
  _path = _path.replace('{boundaryId}', encodeURIComponent(String(boundaryId)));
  return this.client.get(
    _path,
    {
      params: {
        ..._body,
        pageNumber: results.pageNumber,
        pageSize: results.pageSize,
      }
    })
    .then((response) => {
      // BaseApiClient uses validateStatus: () => true, so we must check status manually
      if (response.status >= 400) {
        throw CoreError.deserialize(response.data);
      }
      results.items = ObjectSerializer.deserialize(response.data, 'Array<AlertSubscriptionExtended>');
      results.count = response.headers.count ? Number(response.headers.count) : -1;
      results.pageToken = response.headers.pagetoken ?? response.headers.pageToken;
      results.headers = this.headers;
      results.baseUrl = new URL(`${this.client.getUri()}/app/boundaries/{boundaryId}/alertBots/{boundaryAlertBotId}/subscriptions`);
      results.httpMethod = HttpMethod.Get;
      results.body = _body;
      results.mapper = (obj) => ObjectSerializer.deserialize(obj, 'AlertSubscriptionExtended');
    })
    .catch((error) => {
      if (error.data) {
        throw CoreError.deserialize(error.data);
      } else {
        throw error;
      }
    });
  }
  async listAlertBots(results: PagedResults<BoundaryAlertBotExtended>, boundaryId: UUID, queryId?: UUID, queryVersionId?: UUID, sort?: SortObject): Promise<void> {
  const _body = {
      boundaryId,queryId,queryVersionId,sort,
  };
  let _path = '/app/boundaries/{boundaryId}/alertBots';
  _path = _path.replace('{boundaryId}', encodeURIComponent(String(boundaryId)));
  return this.client.get(
    _path,
    {
      params: {
        ..._body,
        pageNumber: results.pageNumber,
        pageSize: results.pageSize,
      }
    })
    .then((response) => {
      // BaseApiClient uses validateStatus: () => true, so we must check status manually
      if (response.status >= 400) {
        throw CoreError.deserialize(response.data);
      }
      results.items = ObjectSerializer.deserialize(response.data, 'Array<BoundaryAlertBotExtended>');
      results.count = response.headers.count ? Number(response.headers.count) : -1;
      results.pageToken = response.headers.pagetoken ?? response.headers.pageToken;
      results.headers = this.headers;
      results.baseUrl = new URL(`${this.client.getUri()}/app/boundaries/{boundaryId}/alertBots`);
      results.httpMethod = HttpMethod.Get;
      results.body = _body;
      results.mapper = (obj) => ObjectSerializer.deserialize(obj, 'BoundaryAlertBotExtended');
    })
    .catch((error) => {
      if (error.data) {
        throw CoreError.deserialize(error.data);
      } else {
        throw error;
      }
    });
  }
  async listBoundaryAlerts(results: PagedResults<BoundaryAlertView>, boundaryId: UUID, sort?: SortObject): Promise<void> {
  const _body = {
      boundaryId,sort,
  };
  let _path = '/app/boundaries/{boundaryId}/alerts';
  _path = _path.replace('{boundaryId}', encodeURIComponent(String(boundaryId)));
  return this.client.get(
    _path,
    {
      params: {
        ..._body,
        pageNumber: results.pageNumber,
        pageSize: results.pageSize,
      }
    })
    .then((response) => {
      // BaseApiClient uses validateStatus: () => true, so we must check status manually
      if (response.status >= 400) {
        throw CoreError.deserialize(response.data);
      }
      results.items = ObjectSerializer.deserialize(response.data, 'Array<BoundaryAlertView>');
      results.count = response.headers.count ? Number(response.headers.count) : -1;
      results.pageToken = response.headers.pagetoken ?? response.headers.pageToken;
      results.headers = this.headers;
      results.baseUrl = new URL(`${this.client.getUri()}/app/boundaries/{boundaryId}/alerts`);
      results.httpMethod = HttpMethod.Get;
      results.body = _body;
      results.mapper = (obj) => ObjectSerializer.deserialize(obj, 'BoundaryAlertView');
    })
    .catch((error) => {
      if (error.data) {
        throw CoreError.deserialize(error.data);
      } else {
        throw error;
      }
    });
  }
  async listBoundaryAuditMetrics(results: PagedResults<BoundaryAuditMetrics>, boundaryId: UUID, status?: AuditStatusEnumDef, type?: AuditTypeEnumDef): Promise<void> {
  const _body = {
      boundaryId,status,type,
  };
  let _path = '/boundaries/{boundaryId}/auditMetrics';
  _path = _path.replace('{boundaryId}', encodeURIComponent(String(boundaryId)));
  return this.client.get(
    _path,
    {
      params: {
        ..._body,
        pageNumber: results.pageNumber,
        pageSize: results.pageSize,
      }
    })
    .then((response) => {
      // BaseApiClient uses validateStatus: () => true, so we must check status manually
      if (response.status >= 400) {
        throw CoreError.deserialize(response.data);
      }
      results.items = ObjectSerializer.deserialize(response.data, 'Array<BoundaryAuditMetrics>');
      results.count = response.headers.count ? Number(response.headers.count) : -1;
      results.pageToken = response.headers.pagetoken ?? response.headers.pageToken;
      results.headers = this.headers;
      results.baseUrl = new URL(`${this.client.getUri()}/boundaries/{boundaryId}/auditMetrics`);
      results.httpMethod = HttpMethod.Get;
      results.body = _body;
      results.mapper = (obj) => ObjectSerializer.deserialize(obj, 'BoundaryAuditMetrics');
    })
    .catch((error) => {
      if (error.data) {
        throw CoreError.deserialize(error.data);
      } else {
        throw error;
      }
    });
  }
  async listBoundaryAudits(results: PagedResults<Audit & AuditExtended>, boundaryId: UUID, status?: AuditStatusEnumDef, type?: AuditTypeEnumDef, audited?: boolean): Promise<void> {
  const _body = {
      boundaryId,status,type,audited,
  };
  let _path = '/boundaries/{boundaryId}/audits';
  _path = _path.replace('{boundaryId}', encodeURIComponent(String(boundaryId)));
  return this.client.get(
    _path,
    {
      params: {
        ..._body,
        pageNumber: results.pageNumber,
        pageSize: results.pageSize,
      }
    })
    .then((response) => {
      // BaseApiClient uses validateStatus: () => true, so we must check status manually
      if (response.status >= 400) {
        throw CoreError.deserialize(response.data);
      }
      results.items = ObjectSerializer.deserialize(response.data, 'Array<Audit & AuditExtended>');
      results.count = response.headers.count ? Number(response.headers.count) : -1;
      results.pageToken = response.headers.pagetoken ?? response.headers.pageToken;
      results.headers = this.headers;
      results.baseUrl = new URL(`${this.client.getUri()}/boundaries/{boundaryId}/audits`);
      results.httpMethod = HttpMethod.Get;
      results.body = _body;
      results.mapper = (obj) => ObjectSerializer.deserialize(obj, 'Audit & AuditExtended');
    })
    .catch((error) => {
      if (error.data) {
        throw CoreError.deserialize(error.data);
      } else {
        throw error;
      }
    });
  }
  async listBoundaryComponents(results: PagedResults<BoundaryComponentExtended>, boundaryId?: UUID, componentId?: UUID): Promise<void> {
  const _body = {
      boundaryId,componentId,
  };
  let _path = '/app/boundaryComponents';
  return this.client.get(
    _path,
    {
      params: {
        ..._body,
        pageNumber: results.pageNumber,
        pageSize: results.pageSize,
      }
    })
    .then((response) => {
      // BaseApiClient uses validateStatus: () => true, so we must check status manually
      if (response.status >= 400) {
        throw CoreError.deserialize(response.data);
      }
      results.items = ObjectSerializer.deserialize(response.data, 'Array<BoundaryComponentExtended>');
      results.count = response.headers.count ? Number(response.headers.count) : -1;
      results.pageToken = response.headers.pagetoken ?? response.headers.pageToken;
      results.headers = this.headers;
      results.baseUrl = new URL(`${this.client.getUri()}/app/boundaryComponents`);
      results.httpMethod = HttpMethod.Get;
      results.body = _body;
      results.mapper = (obj) => ObjectSerializer.deserialize(obj, 'BoundaryComponentExtended');
    })
    .catch((error) => {
      if (error.data) {
        throw CoreError.deserialize(error.data);
      } else {
        throw error;
      }
    });
  }
  async listBoundaryComponentsByBoundaryId(results: PagedResults<BoundaryComponentExtended>, boundaryId: UUID): Promise<void> {
  const _body = {
      boundaryId,
  };
  let _path = '/app/boundaries/{boundaryId}/components';
  _path = _path.replace('{boundaryId}', encodeURIComponent(String(boundaryId)));
  return this.client.get(
    _path,
    {
      params: {
        ..._body,
        pageNumber: results.pageNumber,
        pageSize: results.pageSize,
      }
    })
    .then((response) => {
      // BaseApiClient uses validateStatus: () => true, so we must check status manually
      if (response.status >= 400) {
        throw CoreError.deserialize(response.data);
      }
      results.items = ObjectSerializer.deserialize(response.data, 'Array<BoundaryComponentExtended>');
      results.count = response.headers.count ? Number(response.headers.count) : -1;
      results.pageToken = response.headers.pagetoken ?? response.headers.pageToken;
      results.headers = this.headers;
      results.baseUrl = new URL(`${this.client.getUri()}/app/boundaries/{boundaryId}/components`);
      results.httpMethod = HttpMethod.Get;
      results.body = _body;
      results.mapper = (obj) => ObjectSerializer.deserialize(obj, 'BoundaryComponentExtended');
    })
    .catch((error) => {
      if (error.data) {
        throw CoreError.deserialize(error.data);
      } else {
        throw error;
      }
    });
  }
  async listBoundaryConnections(results: PagedResults<BoundaryConnectionForList>, boundaryId: UUID): Promise<void> {
  const _body = {
      boundaryId,
  };
  let _path = '/boundaries/{boundaryId}/connections';
  _path = _path.replace('{boundaryId}', encodeURIComponent(String(boundaryId)));
  return this.client.get(
    _path,
    {
      params: {
        ..._body,
        pageNumber: results.pageNumber,
        pageSize: results.pageSize,
      }
    })
    .then((response) => {
      // BaseApiClient uses validateStatus: () => true, so we must check status manually
      if (response.status >= 400) {
        throw CoreError.deserialize(response.data);
      }
      results.items = ObjectSerializer.deserialize(response.data, 'Array<BoundaryConnectionForList>');
      results.count = response.headers.count ? Number(response.headers.count) : -1;
      results.pageToken = response.headers.pagetoken ?? response.headers.pageToken;
      results.headers = this.headers;
      results.baseUrl = new URL(`${this.client.getUri()}/boundaries/{boundaryId}/connections`);
      results.httpMethod = HttpMethod.Get;
      results.body = _body;
      results.mapper = (obj) => ObjectSerializer.deserialize(obj, 'BoundaryConnectionForList');
    })
    .catch((error) => {
      if (error.data) {
        throw CoreError.deserialize(error.data);
      } else {
        throw error;
      }
    });
  }
  async listBoundaryEvents(results: PagedResults<BoundaryEvent & ExtendedBoundaryEvent>, boundaryId: UUID): Promise<void> {
  const _body = {
      boundaryId,
  };
  let _path = '/boundaries/{boundaryId}/events';
  _path = _path.replace('{boundaryId}', encodeURIComponent(String(boundaryId)));
  return this.client.get(
    _path,
    {
      params: {
        ..._body,
        pageNumber: results.pageNumber,
        pageSize: results.pageSize,
      }
    })
    .then((response) => {
      // BaseApiClient uses validateStatus: () => true, so we must check status manually
      if (response.status >= 400) {
        throw CoreError.deserialize(response.data);
      }
      results.items = ObjectSerializer.deserialize(response.data, 'Array<BoundaryEvent & ExtendedBoundaryEvent>');
      results.count = response.headers.count ? Number(response.headers.count) : -1;
      results.pageToken = response.headers.pagetoken ?? response.headers.pageToken;
      results.headers = this.headers;
      results.baseUrl = new URL(`${this.client.getUri()}/boundaries/{boundaryId}/events`);
      results.httpMethod = HttpMethod.Get;
      results.body = _body;
      results.mapper = (obj) => ObjectSerializer.deserialize(obj, 'BoundaryEvent & ExtendedBoundaryEvent');
    })
    .catch((error) => {
      if (error.data) {
        throw CoreError.deserialize(error.data);
      } else {
        throw error;
      }
    });
  }
  async listBoundaryEvidence(results: PagedResults<BoundaryEvidence & ExtendedBoundaryEvidence>, boundaryId: UUID, status?: BoundaryEvidenceStatusEnumDef, productId?: UUID, evidenceDefinitionIds?: Array<UUID>, sortColumn?: BoundaryEvidenceSortColumnsDef, sortOrder?: SortOrderOptionsDef): Promise<void> {
  const _body = {
      boundaryId,status,productId,evidenceDefinitionIds,sortColumn,sortOrder,
  };
  let _path = '/boundaries/{boundaryId}/evidence';
  _path = _path.replace('{boundaryId}', encodeURIComponent(String(boundaryId)));
  return this.client.get(
    _path,
    {
      params: {
        ..._body,
        pageNumber: results.pageNumber,
        pageSize: results.pageSize,
      }
    })
    .then((response) => {
      // BaseApiClient uses validateStatus: () => true, so we must check status manually
      if (response.status >= 400) {
        throw CoreError.deserialize(response.data);
      }
      results.items = ObjectSerializer.deserialize(response.data, 'Array<BoundaryEvidence & ExtendedBoundaryEvidence>');
      results.count = response.headers.count ? Number(response.headers.count) : -1;
      results.pageToken = response.headers.pagetoken ?? response.headers.pageToken;
      results.headers = this.headers;
      results.baseUrl = new URL(`${this.client.getUri()}/boundaries/{boundaryId}/evidence`);
      results.httpMethod = HttpMethod.Get;
      results.body = _body;
      results.mapper = (obj) => ObjectSerializer.deserialize(obj, 'BoundaryEvidence & ExtendedBoundaryEvidence');
    })
    .catch((error) => {
      if (error.data) {
        throw CoreError.deserialize(error.data);
      } else {
        throw error;
      }
    });
  }
  async listBoundaryParties(results: PagedResults<PartyExtended>, boundaryId: UUID, partyType?: PartyTypeEnumDef, assignable?: boolean, search?: string, sort?: SortObject): Promise<void> {
  const _body = {
      boundaryId,partyType,assignable,search,sort,
  };
  let _path = '/boundaries/{boundaryId}/parties';
  _path = _path.replace('{boundaryId}', encodeURIComponent(String(boundaryId)));
  return this.client.get(
    _path,
    {
      params: {
        ..._body,
        pageNumber: results.pageNumber,
        pageSize: results.pageSize,
      }
    })
    .then((response) => {
      // BaseApiClient uses validateStatus: () => true, so we must check status manually
      if (response.status >= 400) {
        throw CoreError.deserialize(response.data);
      }
      results.items = ObjectSerializer.deserialize(response.data, 'Array<PartyExtended>');
      results.count = response.headers.count ? Number(response.headers.count) : -1;
      results.pageToken = response.headers.pagetoken ?? response.headers.pageToken;
      results.headers = this.headers;
      results.baseUrl = new URL(`${this.client.getUri()}/boundaries/{boundaryId}/parties`);
      results.httpMethod = HttpMethod.Get;
      results.body = _body;
      results.mapper = (obj) => ObjectSerializer.deserialize(obj, 'PartyExtended');
    })
    .catch((error) => {
      if (error.data) {
        throw CoreError.deserialize(error.data);
      } else {
        throw error;
      }
    });
  }
  async listBoundaryPartyRaci(boundaryId: UUID, partyId: UUID): Promise<Array<RaciRollup>> {
  const _queryParams = {
      
  };
  const _bodyParams = {
      
  };
  let _path = '/boundaries/{boundaryId}/parties/{partyId}/responsibilityMatrix';
  _path = _path.replace('{boundaryId}', encodeURIComponent(String(boundaryId)));
  _path = _path.replace('{partyId}', encodeURIComponent(String(partyId)));
  return this.client.get(
    _path,
    { params: _queryParams })
    .then((response) => {
      // BaseApiClient uses validateStatus: () => true, so we must check status manually
      if (response.status >= 400) {
        throw CoreError.deserialize(response.data);
      }
      return ObjectSerializer.deserialize(response.data, 'Array<RaciRollup>')
    })
    .catch((error) => {
      if (error.data) {
        throw CoreError.deserialize(error.data);
      } else {
        throw error;
      }
    });
  }
  async listBoundaryPartyRoles(results: PagedResults<BoundaryPartyRoleExtended>, boundaryId: UUID, partyId: UUID): Promise<void> {
  const _body = {
      boundaryId,partyId,
  };
  let _path = '/app/boundaries/{boundaryId}/parties/{partyId}/roles';
  _path = _path.replace('{boundaryId}', encodeURIComponent(String(boundaryId)));
  _path = _path.replace('{partyId}', encodeURIComponent(String(partyId)));
  return this.client.get(
    _path,
    {
      params: {
        ..._body,
        pageNumber: results.pageNumber,
        pageSize: results.pageSize,
      }
    })
    .then((response) => {
      // BaseApiClient uses validateStatus: () => true, so we must check status manually
      if (response.status >= 400) {
        throw CoreError.deserialize(response.data);
      }
      results.items = ObjectSerializer.deserialize(response.data, 'Array<BoundaryPartyRoleExtended>');
      results.count = response.headers.count ? Number(response.headers.count) : -1;
      results.pageToken = response.headers.pagetoken ?? response.headers.pageToken;
      results.headers = this.headers;
      results.baseUrl = new URL(`${this.client.getUri()}/app/boundaries/{boundaryId}/parties/{partyId}/roles`);
      results.httpMethod = HttpMethod.Get;
      results.body = _body;
      results.mapper = (obj) => ObjectSerializer.deserialize(obj, 'BoundaryPartyRoleExtended');
    })
    .catch((error) => {
      if (error.data) {
        throw CoreError.deserialize(error.data);
      } else {
        throw error;
      }
    });
  }
  async listBoundaryPartyRolesByBoundaryId(results: PagedResults<BoundaryPartyRoleExtended>, boundaryId: UUID, partyId?: UUID): Promise<void> {
  const _body = {
      boundaryId,partyId,
  };
  let _path = '/app/boundaries/{boundaryId}/partyRoles';
  _path = _path.replace('{boundaryId}', encodeURIComponent(String(boundaryId)));
  return this.client.get(
    _path,
    {
      params: {
        ..._body,
        pageNumber: results.pageNumber,
        pageSize: results.pageSize,
      }
    })
    .then((response) => {
      // BaseApiClient uses validateStatus: () => true, so we must check status manually
      if (response.status >= 400) {
        throw CoreError.deserialize(response.data);
      }
      results.items = ObjectSerializer.deserialize(response.data, 'Array<BoundaryPartyRoleExtended>');
      results.count = response.headers.count ? Number(response.headers.count) : -1;
      results.pageToken = response.headers.pagetoken ?? response.headers.pageToken;
      results.headers = this.headers;
      results.baseUrl = new URL(`${this.client.getUri()}/app/boundaries/{boundaryId}/partyRoles`);
      results.httpMethod = HttpMethod.Get;
      results.body = _body;
      results.mapper = (obj) => ObjectSerializer.deserialize(obj, 'BoundaryPartyRoleExtended');
    })
    .catch((error) => {
      if (error.data) {
        throw CoreError.deserialize(error.data);
      } else {
        throw error;
      }
    });
  }
  async listBoundaryPipelines(results: PagedResults<Pipeline>, boundaryId: UUID, keywords?: string, productId?: UUID, adminStatus?: PipelineAdminStatusEnumDef, executionStatus?: PipelineExecutionStatusEnumDef, type?: PipelineFormatEnumDef, sort?: SortObject): Promise<void> {
  const _body = {
      boundaryId,keywords,productId,adminStatus,executionStatus,type,sort,
  };
  let _path = '/boundaries/{boundaryId}/pipelines';
  _path = _path.replace('{boundaryId}', encodeURIComponent(String(boundaryId)));
  return this.client.get(
    _path,
    {
      params: {
        ..._body,
        pageNumber: results.pageNumber,
        pageSize: results.pageSize,
      }
    })
    .then((response) => {
      // BaseApiClient uses validateStatus: () => true, so we must check status manually
      if (response.status >= 400) {
        throw CoreError.deserialize(response.data);
      }
      results.items = ObjectSerializer.deserialize(response.data, 'Array<Pipeline>');
      results.count = response.headers.count ? Number(response.headers.count) : -1;
      results.pageToken = response.headers.pagetoken ?? response.headers.pageToken;
      results.headers = this.headers;
      results.baseUrl = new URL(`${this.client.getUri()}/boundaries/{boundaryId}/pipelines`);
      results.httpMethod = HttpMethod.Get;
      results.body = _body;
      results.mapper = (obj) => ObjectSerializer.deserialize(obj, 'Pipeline');
    })
    .catch((error) => {
      if (error.data) {
        throw CoreError.deserialize(error.data);
      } else {
        throw error;
      }
    });
  }
  async listBoundaryProductConnections(results: PagedResults<BoundaryConnectionForList>, boundaryId: UUID, boundaryProductId: UUID, sort?: SortObject): Promise<void> {
  const _body = {
      boundaryId,boundaryProductId,sort,
  };
  let _path = '/boundaries/{boundaryId}/products/{boundaryProductId}/connections';
  _path = _path.replace('{boundaryId}', encodeURIComponent(String(boundaryId)));
  _path = _path.replace('{boundaryProductId}', encodeURIComponent(String(boundaryProductId)));
  return this.client.get(
    _path,
    {
      params: {
        ..._body,
        pageNumber: results.pageNumber,
        pageSize: results.pageSize,
      }
    })
    .then((response) => {
      // BaseApiClient uses validateStatus: () => true, so we must check status manually
      if (response.status >= 400) {
        throw CoreError.deserialize(response.data);
      }
      results.items = ObjectSerializer.deserialize(response.data, 'Array<BoundaryConnectionForList>');
      results.count = response.headers.count ? Number(response.headers.count) : -1;
      results.pageToken = response.headers.pagetoken ?? response.headers.pageToken;
      results.headers = this.headers;
      results.baseUrl = new URL(`${this.client.getUri()}/boundaries/{boundaryId}/products/{boundaryProductId}/connections`);
      results.httpMethod = HttpMethod.Get;
      results.body = _body;
      results.mapper = (obj) => ObjectSerializer.deserialize(obj, 'BoundaryConnectionForList');
    })
    .catch((error) => {
      if (error.data) {
        throw CoreError.deserialize(error.data);
      } else {
        throw error;
      }
    });
  }
  async listBoundaryProductPipelines(results: PagedResults<BoundaryProductPipeline>, boundaryId: UUID, boundaryProductId: UUID, search?: string, format?: PipelineFormatEnumDef, targetId?: UUID, sort?: SortObject, showPreviews?: boolean): Promise<void> {
  const _body = {
      boundaryId,boundaryProductId,search,format,targetId,sort,showPreviews,
  };
  let _path = '/boundaries/{boundaryId}/products/{boundaryProductId}/pipelines';
  _path = _path.replace('{boundaryId}', encodeURIComponent(String(boundaryId)));
  _path = _path.replace('{boundaryProductId}', encodeURIComponent(String(boundaryProductId)));
  return this.client.get(
    _path,
    {
      params: {
        ..._body,
        pageNumber: results.pageNumber,
        pageSize: results.pageSize,
      }
    })
    .then((response) => {
      // BaseApiClient uses validateStatus: () => true, so we must check status manually
      if (response.status >= 400) {
        throw CoreError.deserialize(response.data);
      }
      results.items = ObjectSerializer.deserialize(response.data, 'Array<BoundaryProductPipeline>');
      results.count = response.headers.count ? Number(response.headers.count) : -1;
      results.pageToken = response.headers.pagetoken ?? response.headers.pageToken;
      results.headers = this.headers;
      results.baseUrl = new URL(`${this.client.getUri()}/boundaries/{boundaryId}/products/{boundaryProductId}/pipelines`);
      results.httpMethod = HttpMethod.Get;
      results.body = _body;
      results.mapper = (obj) => ObjectSerializer.deserialize(obj, 'BoundaryProductPipeline');
    })
    .catch((error) => {
      if (error.data) {
        throw CoreError.deserialize(error.data);
      } else {
        throw error;
      }
    });
  }
  async listBoundaryProductsByBoundary(results: PagedResults<BoundaryProductExtended>, boundaryId: UUID, status?: CatalogPublishStatusEnumDef, keywords?: string, sort?: SortObject): Promise<void> {
  const _body = {
      boundaryId,status,keywords,sort,
  };
  let _path = '/boundaries/{boundaryId}/products';
  _path = _path.replace('{boundaryId}', encodeURIComponent(String(boundaryId)));
  return this.client.get(
    _path,
    {
      params: {
        ..._body,
        pageNumber: results.pageNumber,
        pageSize: results.pageSize,
      }
    })
    .then((response) => {
      // BaseApiClient uses validateStatus: () => true, so we must check status manually
      if (response.status >= 400) {
        throw CoreError.deserialize(response.data);
      }
      results.items = ObjectSerializer.deserialize(response.data, 'Array<BoundaryProductExtended>');
      results.count = response.headers.count ? Number(response.headers.count) : -1;
      results.pageToken = response.headers.pagetoken ?? response.headers.pageToken;
      results.headers = this.headers;
      results.baseUrl = new URL(`${this.client.getUri()}/boundaries/{boundaryId}/products`);
      results.httpMethod = HttpMethod.Get;
      results.body = _body;
      results.mapper = (obj) => ObjectSerializer.deserialize(obj, 'BoundaryProductExtended');
    })
    .catch((error) => {
      if (error.data) {
        throw CoreError.deserialize(error.data);
      } else {
        throw error;
      }
    });
  }
  async listBoundaryQueryAlerts(results: PagedResults<BoundaryAlertView>, boundaryId: UUID, queryId: UUID, sort?: SortObject): Promise<void> {
  const _body = {
      boundaryId,queryId,sort,
  };
  let _path = '/app/boundaries/{boundaryId}/queries/{queryId}/alerts';
  _path = _path.replace('{boundaryId}', encodeURIComponent(String(boundaryId)));
  _path = _path.replace('{queryId}', encodeURIComponent(String(queryId)));
  return this.client.get(
    _path,
    {
      params: {
        ..._body,
        pageNumber: results.pageNumber,
        pageSize: results.pageSize,
      }
    })
    .then((response) => {
      // BaseApiClient uses validateStatus: () => true, so we must check status manually
      if (response.status >= 400) {
        throw CoreError.deserialize(response.data);
      }
      results.items = ObjectSerializer.deserialize(response.data, 'Array<BoundaryAlertView>');
      results.count = response.headers.count ? Number(response.headers.count) : -1;
      results.pageToken = response.headers.pagetoken ?? response.headers.pageToken;
      results.headers = this.headers;
      results.baseUrl = new URL(`${this.client.getUri()}/app/boundaries/{boundaryId}/queries/{queryId}/alerts`);
      results.httpMethod = HttpMethod.Get;
      results.body = _body;
      results.mapper = (obj) => ObjectSerializer.deserialize(obj, 'BoundaryAlertView');
    })
    .catch((error) => {
      if (error.data) {
        throw CoreError.deserialize(error.data);
      } else {
        throw error;
      }
    });
  }
  async listBoundaryRoles(results: PagedResults<BoundaryRoleExtended>, boundaryId: UUID, roleCategoryId?: UUID): Promise<void> {
  const _body = {
      boundaryId,roleCategoryId,
  };
  let _path = '/app/boundaries/{boundaryId}/roles';
  _path = _path.replace('{boundaryId}', encodeURIComponent(String(boundaryId)));
  return this.client.get(
    _path,
    {
      params: {
        ..._body,
        pageNumber: results.pageNumber,
        pageSize: results.pageSize,
      }
    })
    .then((response) => {
      // BaseApiClient uses validateStatus: () => true, so we must check status manually
      if (response.status >= 400) {
        throw CoreError.deserialize(response.data);
      }
      results.items = ObjectSerializer.deserialize(response.data, 'Array<BoundaryRoleExtended>');
      results.count = response.headers.count ? Number(response.headers.count) : -1;
      results.pageToken = response.headers.pagetoken ?? response.headers.pageToken;
      results.headers = this.headers;
      results.baseUrl = new URL(`${this.client.getUri()}/app/boundaries/{boundaryId}/roles`);
      results.httpMethod = HttpMethod.Get;
      results.body = _body;
      results.mapper = (obj) => ObjectSerializer.deserialize(obj, 'BoundaryRoleExtended');
    })
    .catch((error) => {
      if (error.data) {
        throw CoreError.deserialize(error.data);
      } else {
        throw error;
      }
    });
  }
  async listBoundaryScfControls(results: PagedResults<ExtendedBoundaryScfControl>, boundaryId: UUID, frameworkElementId?: UUID, scfDomainCode?: string, performed?: boolean, answered?: boolean): Promise<void> {
  const _body = {
      boundaryId,frameworkElementId,scfDomainCode,performed,answered,
  };
  let _path = '/boundaries/{boundaryId}/scfControls';
  _path = _path.replace('{boundaryId}', encodeURIComponent(String(boundaryId)));
  return this.client.get(
    _path,
    {
      params: {
        ..._body,
        pageNumber: results.pageNumber,
        pageSize: results.pageSize,
      }
    })
    .then((response) => {
      // BaseApiClient uses validateStatus: () => true, so we must check status manually
      if (response.status >= 400) {
        throw CoreError.deserialize(response.data);
      }
      results.items = ObjectSerializer.deserialize(response.data, 'Array<ExtendedBoundaryScfControl>');
      results.count = response.headers.count ? Number(response.headers.count) : -1;
      results.pageToken = response.headers.pagetoken ?? response.headers.pageToken;
      results.headers = this.headers;
      results.baseUrl = new URL(`${this.client.getUri()}/boundaries/{boundaryId}/scfControls`);
      results.httpMethod = HttpMethod.Get;
      results.body = _body;
      results.mapper = (obj) => ObjectSerializer.deserialize(obj, 'ExtendedBoundaryScfControl');
    })
    .catch((error) => {
      if (error.data) {
        throw CoreError.deserialize(error.data);
      } else {
        throw error;
      }
    });
  }
  async listStandardBaselineElements(results: PagedResults<ElementExtended>, boundaryId: UUID, boundaryStandardBaselineId: UUID, sort?: SortObject): Promise<void> {
  const _body = {
      boundaryId,boundaryStandardBaselineId,sort,
  };
  let _path = '/app/boundaries/{boundaryId}/standardBaselines/{boundaryStandardBaselineId}/elements';
  _path = _path.replace('{boundaryId}', encodeURIComponent(String(boundaryId)));
  _path = _path.replace('{boundaryStandardBaselineId}', encodeURIComponent(String(boundaryStandardBaselineId)));
  return this.client.get(
    _path,
    {
      params: {
        ..._body,
        pageNumber: results.pageNumber,
        pageSize: results.pageSize,
      }
    })
    .then((response) => {
      // BaseApiClient uses validateStatus: () => true, so we must check status manually
      if (response.status >= 400) {
        throw CoreError.deserialize(response.data);
      }
      results.items = ObjectSerializer.deserialize(response.data, 'Array<ElementExtended>');
      results.count = response.headers.count ? Number(response.headers.count) : -1;
      results.pageToken = response.headers.pagetoken ?? response.headers.pageToken;
      results.headers = this.headers;
      results.baseUrl = new URL(`${this.client.getUri()}/app/boundaries/{boundaryId}/standardBaselines/{boundaryStandardBaselineId}/elements`);
      results.httpMethod = HttpMethod.Get;
      results.body = _body;
      results.mapper = (obj) => ObjectSerializer.deserialize(obj, 'ElementExtended');
    })
    .catch((error) => {
      if (error.data) {
        throw CoreError.deserialize(error.data);
      } else {
        throw error;
      }
    });
  }
  async listStandardBaselines(results: PagedResults<BoundaryStandardBaselineExtended>, boundaryId: UUID): Promise<void> {
  const _body = {
      boundaryId,
  };
  let _path = '/app/boundaries/{boundaryId}/standardBaselines';
  _path = _path.replace('{boundaryId}', encodeURIComponent(String(boundaryId)));
  return this.client.get(
    _path,
    {
      params: {
        ..._body,
        pageNumber: results.pageNumber,
        pageSize: results.pageSize,
      }
    })
    .then((response) => {
      // BaseApiClient uses validateStatus: () => true, so we must check status manually
      if (response.status >= 400) {
        throw CoreError.deserialize(response.data);
      }
      results.items = ObjectSerializer.deserialize(response.data, 'Array<BoundaryStandardBaselineExtended>');
      results.count = response.headers.count ? Number(response.headers.count) : -1;
      results.pageToken = response.headers.pagetoken ?? response.headers.pageToken;
      results.headers = this.headers;
      results.baseUrl = new URL(`${this.client.getUri()}/app/boundaries/{boundaryId}/standardBaselines`);
      results.httpMethod = HttpMethod.Get;
      results.body = _body;
      results.mapper = (obj) => ObjectSerializer.deserialize(obj, 'BoundaryStandardBaselineExtended');
    })
    .catch((error) => {
      if (error.data) {
        throw CoreError.deserialize(error.data);
      } else {
        throw error;
      }
    });
  }
  async listBoundarySuggestedProducts(results: PagedResults<BoundarySuggestedProduct>, boundaryId: UUID, keywords?: string): Promise<void> {
  const _body = {
      boundaryId,keywords,
  };
  let _path = '/boundaries/{boundaryId}/suggestedProducts';
  _path = _path.replace('{boundaryId}', encodeURIComponent(String(boundaryId)));
  return this.client.get(
    _path,
    {
      params: {
        ..._body,
        pageNumber: results.pageNumber,
        pageSize: results.pageSize,
      }
    })
    .then((response) => {
      // BaseApiClient uses validateStatus: () => true, so we must check status manually
      if (response.status >= 400) {
        throw CoreError.deserialize(response.data);
      }
      results.items = ObjectSerializer.deserialize(response.data, 'Array<BoundarySuggestedProduct>');
      results.count = response.headers.count ? Number(response.headers.count) : -1;
      results.pageToken = response.headers.pagetoken ?? response.headers.pageToken;
      results.headers = this.headers;
      results.baseUrl = new URL(`${this.client.getUri()}/boundaries/{boundaryId}/suggestedProducts`);
      results.httpMethod = HttpMethod.Get;
      results.body = _body;
      results.mapper = (obj) => ObjectSerializer.deserialize(obj, 'BoundarySuggestedProduct');
    })
    .catch((error) => {
      if (error.data) {
        throw CoreError.deserialize(error.data);
      } else {
        throw error;
      }
    });
  }
  async listBoundaryTargetsByProduct(results: PagedResults<BoundaryProductTarget & ExtendedBoundaryProductTarget>, boundaryId: UUID, boundaryProductId: UUID, keywords?: string): Promise<void> {
  const _body = {
      boundaryId,boundaryProductId,keywords,
  };
  let _path = '/boundaries/{boundaryId}/products/{boundaryProductId}/targets';
  _path = _path.replace('{boundaryId}', encodeURIComponent(String(boundaryId)));
  _path = _path.replace('{boundaryProductId}', encodeURIComponent(String(boundaryProductId)));
  return this.client.get(
    _path,
    {
      params: {
        ..._body,
        pageNumber: results.pageNumber,
        pageSize: results.pageSize,
      }
    })
    .then((response) => {
      // BaseApiClient uses validateStatus: () => true, so we must check status manually
      if (response.status >= 400) {
        throw CoreError.deserialize(response.data);
      }
      results.items = ObjectSerializer.deserialize(response.data, 'Array<BoundaryProductTarget & ExtendedBoundaryProductTarget>');
      results.count = response.headers.count ? Number(response.headers.count) : -1;
      results.pageToken = response.headers.pagetoken ?? response.headers.pageToken;
      results.headers = this.headers;
      results.baseUrl = new URL(`${this.client.getUri()}/boundaries/{boundaryId}/products/{boundaryProductId}/targets`);
      results.httpMethod = HttpMethod.Get;
      results.body = _body;
      results.mapper = (obj) => ObjectSerializer.deserialize(obj, 'BoundaryProductTarget & ExtendedBoundaryProductTarget');
    })
    .catch((error) => {
      if (error.data) {
        throw CoreError.deserialize(error.data);
      } else {
        throw error;
      }
    });
  }
  async listBoundaryTeamMetrics(results: PagedResults<BoundaryTeamMetrics>, boundaryId: UUID): Promise<void> {
  const _body = {
      boundaryId,
  };
  let _path = '/boundaries/{boundaryId}/teamMetrics';
  _path = _path.replace('{boundaryId}', encodeURIComponent(String(boundaryId)));
  return this.client.get(
    _path,
    {
      params: {
        ..._body,
        pageNumber: results.pageNumber,
        pageSize: results.pageSize,
      }
    })
    .then((response) => {
      // BaseApiClient uses validateStatus: () => true, so we must check status manually
      if (response.status >= 400) {
        throw CoreError.deserialize(response.data);
      }
      results.items = ObjectSerializer.deserialize(response.data, 'Array<BoundaryTeamMetrics>');
      results.count = response.headers.count ? Number(response.headers.count) : -1;
      results.pageToken = response.headers.pagetoken ?? response.headers.pageToken;
      results.headers = this.headers;
      results.baseUrl = new URL(`${this.client.getUri()}/boundaries/{boundaryId}/teamMetrics`);
      results.httpMethod = HttpMethod.Get;
      results.body = _body;
      results.mapper = (obj) => ObjectSerializer.deserialize(obj, 'BoundaryTeamMetrics');
    })
    .catch((error) => {
      if (error.data) {
        throw CoreError.deserialize(error.data);
      } else {
        throw error;
      }
    });
  }
  async listBoundaryTeamScfControlEvidenceDefintions(results: PagedResults<BoundaryTeamScfControlEvidenceDefinitionImplementation>, boundaryId: UUID, teamId: UUID, scfControlId: UUID): Promise<void> {
  const _body = {
      boundaryId,teamId,scfControlId,
  };
  let _path = '/boundaries/{boundaryId}/teams/{teamId}/scfControlTree/{scfControlId}/evidenceDefinitions';
  _path = _path.replace('{boundaryId}', encodeURIComponent(String(boundaryId)));
  _path = _path.replace('{teamId}', encodeURIComponent(String(teamId)));
  _path = _path.replace('{scfControlId}', encodeURIComponent(String(scfControlId)));
  return this.client.get(
    _path,
    {
      params: {
        ..._body,
        pageNumber: results.pageNumber,
        pageSize: results.pageSize,
      }
    })
    .then((response) => {
      // BaseApiClient uses validateStatus: () => true, so we must check status manually
      if (response.status >= 400) {
        throw CoreError.deserialize(response.data);
      }
      results.items = ObjectSerializer.deserialize(response.data, 'Array<BoundaryTeamScfControlEvidenceDefinitionImplementation>');
      results.count = response.headers.count ? Number(response.headers.count) : -1;
      results.pageToken = response.headers.pagetoken ?? response.headers.pageToken;
      results.headers = this.headers;
      results.baseUrl = new URL(`${this.client.getUri()}/boundaries/{boundaryId}/teams/{teamId}/scfControlTree/{scfControlId}/evidenceDefinitions`);
      results.httpMethod = HttpMethod.Get;
      results.body = _body;
      results.mapper = (obj) => ObjectSerializer.deserialize(obj, 'BoundaryTeamScfControlEvidenceDefinitionImplementation');
    })
    .catch((error) => {
      if (error.data) {
        throw CoreError.deserialize(error.data);
      } else {
        throw error;
      }
    });
  }
  async listBoundaryTeamScfControls(results: PagedResults<BoundaryTeamScfControl>, boundaryId: UUID, teamId: UUID, domain?: string, code?: string): Promise<void> {
  const _body = {
      boundaryId,teamId,domain,code,
  };
  let _path = '/boundaries/{boundaryId}/teams/{teamId}/scfControls';
  _path = _path.replace('{boundaryId}', encodeURIComponent(String(boundaryId)));
  _path = _path.replace('{teamId}', encodeURIComponent(String(teamId)));
  return this.client.get(
    _path,
    {
      params: {
        ..._body,
        pageNumber: results.pageNumber,
        pageSize: results.pageSize,
      }
    })
    .then((response) => {
      // BaseApiClient uses validateStatus: () => true, so we must check status manually
      if (response.status >= 400) {
        throw CoreError.deserialize(response.data);
      }
      results.items = ObjectSerializer.deserialize(response.data, 'Array<BoundaryTeamScfControl>');
      results.count = response.headers.count ? Number(response.headers.count) : -1;
      results.pageToken = response.headers.pagetoken ?? response.headers.pageToken;
      results.headers = this.headers;
      results.baseUrl = new URL(`${this.client.getUri()}/boundaries/{boundaryId}/teams/{teamId}/scfControls`);
      results.httpMethod = HttpMethod.Get;
      results.body = _body;
      results.mapper = (obj) => ObjectSerializer.deserialize(obj, 'BoundaryTeamScfControl');
    })
    .catch((error) => {
      if (error.data) {
        throw CoreError.deserialize(error.data);
      } else {
        throw error;
      }
    });
  }
  async listBoundaryTeams(results: PagedResults<BoundaryTeam>, boundaryId: UUID, sort?: SortObject): Promise<void> {
  const _body = {
      boundaryId,sort,
  };
  let _path = '/boundaries/{boundaryId}/teams';
  _path = _path.replace('{boundaryId}', encodeURIComponent(String(boundaryId)));
  return this.client.get(
    _path,
    {
      params: {
        ..._body,
        pageNumber: results.pageNumber,
        pageSize: results.pageSize,
      }
    })
    .then((response) => {
      // BaseApiClient uses validateStatus: () => true, so we must check status manually
      if (response.status >= 400) {
        throw CoreError.deserialize(response.data);
      }
      results.items = ObjectSerializer.deserialize(response.data, 'Array<BoundaryTeam>');
      results.count = response.headers.count ? Number(response.headers.count) : -1;
      results.pageToken = response.headers.pagetoken ?? response.headers.pageToken;
      results.headers = this.headers;
      results.baseUrl = new URL(`${this.client.getUri()}/boundaries/{boundaryId}/teams`);
      results.httpMethod = HttpMethod.Get;
      results.body = _body;
      results.mapper = (obj) => ObjectSerializer.deserialize(obj, 'BoundaryTeam');
    })
    .catch((error) => {
      if (error.data) {
        throw CoreError.deserialize(error.data);
      } else {
        throw error;
      }
    });
  }
  async listTests(results: PagedResults<TestExtended>, boundaryId: UUID, standardId?: UUID, benchmarkId?: UUID, testCaseId?: UUID, componentId?: UUID, status?: TestResultEnumDef, sort?: SortObject): Promise<void> {
  const _body = {
      boundaryId,standardId,benchmarkId,testCaseId,componentId,status,sort,
  };
  let _path = '/app/boundaries/{boundaryId}/tests';
  _path = _path.replace('{boundaryId}', encodeURIComponent(String(boundaryId)));
  return this.client.get(
    _path,
    {
      params: {
        ..._body,
        pageNumber: results.pageNumber,
        pageSize: results.pageSize,
      }
    })
    .then((response) => {
      // BaseApiClient uses validateStatus: () => true, so we must check status manually
      if (response.status >= 400) {
        throw CoreError.deserialize(response.data);
      }
      results.items = ObjectSerializer.deserialize(response.data, 'Array<TestExtended>');
      results.count = response.headers.count ? Number(response.headers.count) : -1;
      results.pageToken = response.headers.pagetoken ?? response.headers.pageToken;
      results.headers = this.headers;
      results.baseUrl = new URL(`${this.client.getUri()}/app/boundaries/{boundaryId}/tests`);
      results.httpMethod = HttpMethod.Get;
      results.body = _body;
      results.mapper = (obj) => ObjectSerializer.deserialize(obj, 'TestExtended');
    })
    .catch((error) => {
      if (error.data) {
        throw CoreError.deserialize(error.data);
      } else {
        throw error;
      }
    });
  }
  async listBoundaryUnmanagedDomains(results: PagedResults<ScfDomain>, boundaryId: UUID): Promise<void> {
  const _body = {
      boundaryId,
  };
  let _path = '/boundaries/{boundaryId}/unmanagedDomains';
  _path = _path.replace('{boundaryId}', encodeURIComponent(String(boundaryId)));
  return this.client.get(
    _path,
    {
      params: {
        ..._body,
        pageNumber: results.pageNumber,
        pageSize: results.pageSize,
      }
    })
    .then((response) => {
      // BaseApiClient uses validateStatus: () => true, so we must check status manually
      if (response.status >= 400) {
        throw CoreError.deserialize(response.data);
      }
      results.items = ObjectSerializer.deserialize(response.data, 'Array<ScfDomain>');
      results.count = response.headers.count ? Number(response.headers.count) : -1;
      results.pageToken = response.headers.pagetoken ?? response.headers.pageToken;
      results.headers = this.headers;
      results.baseUrl = new URL(`${this.client.getUri()}/boundaries/{boundaryId}/unmanagedDomains`);
      results.httpMethod = HttpMethod.Get;
      results.body = _body;
      results.mapper = (obj) => ObjectSerializer.deserialize(obj, 'ScfDomain');
    })
    .catch((error) => {
      if (error.data) {
        throw CoreError.deserialize(error.data);
      } else {
        throw error;
      }
    });
  }
  async listFilterBoundaryPartyRoles(results: PagedResults<BoundaryPartyRoleExtended>, partyId?: UUID, boundaryId?: UUID, roleId?: UUID): Promise<void> {
  const _body = {
      partyId,boundaryId,roleId,
  };
  let _path = '/app/boundaryPartyRoles';
  return this.client.get(
    _path,
    {
      params: {
        ..._body,
        pageNumber: results.pageNumber,
        pageSize: results.pageSize,
      }
    })
    .then((response) => {
      // BaseApiClient uses validateStatus: () => true, so we must check status manually
      if (response.status >= 400) {
        throw CoreError.deserialize(response.data);
      }
      results.items = ObjectSerializer.deserialize(response.data, 'Array<BoundaryPartyRoleExtended>');
      results.count = response.headers.count ? Number(response.headers.count) : -1;
      results.pageToken = response.headers.pagetoken ?? response.headers.pageToken;
      results.headers = this.headers;
      results.baseUrl = new URL(`${this.client.getUri()}/app/boundaryPartyRoles`);
      results.httpMethod = HttpMethod.Get;
      results.body = _body;
      results.mapper = (obj) => ObjectSerializer.deserialize(obj, 'BoundaryPartyRoleExtended');
    })
    .catch((error) => {
      if (error.data) {
        throw CoreError.deserialize(error.data);
      } else {
        throw error;
      }
    });
  }
  async removeCrosswalkVersion(boundaryId: UUID, boundaryCrosswalkVersionId: UUID): Promise<void> {
  const _queryParams = {
      
  };
  const _bodyParams = {
      
  };
  let _path = '/app/boundaries/{boundaryId}/crosswalkVersions/{boundaryCrosswalkVersionId}';
  _path = _path.replace('{boundaryId}', encodeURIComponent(String(boundaryId)));
  _path = _path.replace('{boundaryCrosswalkVersionId}', encodeURIComponent(String(boundaryCrosswalkVersionId)));
  return this.client.delete(
    _path,
    { params: _queryParams })
    .then((response) => {
      // BaseApiClient uses validateStatus: () => true, so we must check status manually
      if (response.status >= 400) {
        throw CoreError.deserialize(response.data);
      }
      return ObjectSerializer.deserialize(response.data, '')
    })
    .catch((error) => {
      if (error.data) {
        throw CoreError.deserialize(error.data);
      } else {
        throw error;
      }
    });
  }
  async removeStandardBaseline(boundaryId: UUID, boundaryStandardBaselineId: UUID): Promise<void> {
  const _queryParams = {
      
  };
  const _bodyParams = {
      
  };
  let _path = '/app/boundaries/{boundaryId}/standardBaselines/{boundaryStandardBaselineId}';
  _path = _path.replace('{boundaryId}', encodeURIComponent(String(boundaryId)));
  _path = _path.replace('{boundaryStandardBaselineId}', encodeURIComponent(String(boundaryStandardBaselineId)));
  return this.client.delete(
    _path,
    { params: _queryParams })
    .then((response) => {
      // BaseApiClient uses validateStatus: () => true, so we must check status manually
      if (response.status >= 400) {
        throw CoreError.deserialize(response.data);
      }
      return ObjectSerializer.deserialize(response.data, '')
    })
    .catch((error) => {
      if (error.data) {
        throw CoreError.deserialize(error.data);
      } else {
        throw error;
      }
    });
  }
  async runAlertBot(boundaryId: UUID, boundaryAlertBotId: UUID): Promise<void> {
  const _queryParams = {
      
  };
  const _bodyParams = {
      
  };
  let _path = '/app/boundaries/{boundaryId}/alertBots/{boundaryAlertBotId}';
  _path = _path.replace('{boundaryId}', encodeURIComponent(String(boundaryId)));
  _path = _path.replace('{boundaryAlertBotId}', encodeURIComponent(String(boundaryAlertBotId)));
  return this.client.post(
    _path,
    _bodyParams)
    .then((response) => {
      // BaseApiClient uses validateStatus: () => true, so we must check status manually
      if (response.status >= 400) {
        throw CoreError.deserialize(response.data);
      }
      return ObjectSerializer.deserialize(response.data, '')
    })
    .catch((error) => {
      if (error.data) {
        throw CoreError.deserialize(error.data);
      } else {
        throw error;
      }
    });
  }
  async subscribe(boundaryId: UUID, boundaryAlertBotId: UUID): Promise<AlertSubscriptionExtended> {
  const _queryParams = {
      
  };
  const _bodyParams = {
      
  };
  let _path = '/app/boundaries/{boundaryId}/alertBots/{boundaryAlertBotId}/subscribe';
  _path = _path.replace('{boundaryId}', encodeURIComponent(String(boundaryId)));
  _path = _path.replace('{boundaryAlertBotId}', encodeURIComponent(String(boundaryAlertBotId)));
  return this.client.put(
    _path,
    _bodyParams)
    .then((response) => {
      // BaseApiClient uses validateStatus: () => true, so we must check status manually
      if (response.status >= 400) {
        throw CoreError.deserialize(response.data);
      }
      return ObjectSerializer.deserialize(response.data, 'AlertSubscriptionExtended')
    })
    .catch((error) => {
      if (error.data) {
        throw CoreError.deserialize(error.data);
      } else {
        throw error;
      }
    });
  }
  async unsubscribe(boundaryId: UUID, boundaryAlertBotId: UUID): Promise<AlertSubscriptionExtended> {
  const _queryParams = {
      
  };
  const _bodyParams = {
      
  };
  let _path = '/app/boundaries/{boundaryId}/alertBots/{boundaryAlertBotId}/unsubscribe';
  _path = _path.replace('{boundaryId}', encodeURIComponent(String(boundaryId)));
  _path = _path.replace('{boundaryAlertBotId}', encodeURIComponent(String(boundaryAlertBotId)));
  return this.client.put(
    _path,
    _bodyParams)
    .then((response) => {
      // BaseApiClient uses validateStatus: () => true, so we must check status manually
      if (response.status >= 400) {
        throw CoreError.deserialize(response.data);
      }
      return ObjectSerializer.deserialize(response.data, 'AlertSubscriptionExtended')
    })
    .catch((error) => {
      if (error.data) {
        throw CoreError.deserialize(error.data);
      } else {
        throw error;
      }
    });
  }
  async updateBoundary(boundaryId: UUID, updateBoundary: UpdateBoundary): Promise<Boundary> {
  const _queryParams = {
      
  };
  const _bodyParams = {
      updateBoundary,
  };
  let _path = '/boundaries/{boundaryId}';
  _path = _path.replace('{boundaryId}', encodeURIComponent(String(boundaryId)));
  return this.client.put(
    _path,
    _bodyParams)
    .then((response) => {
      // BaseApiClient uses validateStatus: () => true, so we must check status manually
      if (response.status >= 400) {
        throw CoreError.deserialize(response.data);
      }
      return ObjectSerializer.deserialize(response.data, 'Boundary')
    })
    .catch((error) => {
      if (error.data) {
        throw CoreError.deserialize(error.data);
      } else {
        throw error;
      }
    });
  }
  async updateAlertBot(boundaryId: UUID, boundaryAlertBotId: UUID, updateBoundaryAlertBot: UpdateBoundaryAlertBot): Promise<BoundaryAlertBotExtended> {
  const _queryParams = {
      
  };
  const _bodyParams = {
      updateBoundaryAlertBot,
  };
  let _path = '/app/boundaries/{boundaryId}/alertBots/{boundaryAlertBotId}';
  _path = _path.replace('{boundaryId}', encodeURIComponent(String(boundaryId)));
  _path = _path.replace('{boundaryAlertBotId}', encodeURIComponent(String(boundaryAlertBotId)));
  return this.client.patch(
    _path,
    _bodyParams)
    .then((response) => {
      // BaseApiClient uses validateStatus: () => true, so we must check status manually
      if (response.status >= 400) {
        throw CoreError.deserialize(response.data);
      }
      return ObjectSerializer.deserialize(response.data, 'BoundaryAlertBotExtended')
    })
    .catch((error) => {
      if (error.data) {
        throw CoreError.deserialize(error.data);
      } else {
        throw error;
      }
    });
  }
  async updateBoundaryEvidence(boundaryId: UUID, evidenceId: UUID, updateBoundaryEvidence: UpdateBoundaryEvidence): Promise<BoundaryEvidence> {
  const _queryParams = {
      
  };
  const _bodyParams = {
      updateBoundaryEvidence,
  };
  let _path = '/boundaries/{boundaryId}/evidence/{evidenceId}';
  _path = _path.replace('{boundaryId}', encodeURIComponent(String(boundaryId)));
  _path = _path.replace('{evidenceId}', encodeURIComponent(String(evidenceId)));
  return this.client.put(
    _path,
    _bodyParams)
    .then((response) => {
      // BaseApiClient uses validateStatus: () => true, so we must check status manually
      if (response.status >= 400) {
        throw CoreError.deserialize(response.data);
      }
      return ObjectSerializer.deserialize(response.data, 'BoundaryEvidence')
    })
    .catch((error) => {
      if (error.data) {
        throw CoreError.deserialize(error.data);
      } else {
        throw error;
      }
    });
  }
  async updateBoundaryProduct(boundaryId: UUID, boundaryProductId: UUID, updateBoundaryProduct: UpdateBoundaryProduct): Promise<BoundaryProduct> {
  const _queryParams = {
      
  };
  const _bodyParams = {
      updateBoundaryProduct,
  };
  let _path = '/boundaries/{boundaryId}/products/{boundaryProductId}';
  _path = _path.replace('{boundaryId}', encodeURIComponent(String(boundaryId)));
  _path = _path.replace('{boundaryProductId}', encodeURIComponent(String(boundaryProductId)));
  return this.client.put(
    _path,
    _bodyParams)
    .then((response) => {
      // BaseApiClient uses validateStatus: () => true, so we must check status manually
      if (response.status >= 400) {
        throw CoreError.deserialize(response.data);
      }
      return ObjectSerializer.deserialize(response.data, 'BoundaryProduct')
    })
    .catch((error) => {
      if (error.data) {
        throw CoreError.deserialize(error.data);
      } else {
        throw error;
      }
    });
  }
  async updateBoundaryScfControl(boundaryId: UUID, boundaryScfControlId: UUID, updateBoundaryScfControl: UpdateBoundaryScfControl): Promise<ExtendedBoundaryScfControl> {
  const _queryParams = {
      
  };
  const _bodyParams = {
      updateBoundaryScfControl,
  };
  let _path = '/boundaries/{boundaryId}/scfControls/{boundaryScfControlId}';
  _path = _path.replace('{boundaryId}', encodeURIComponent(String(boundaryId)));
  _path = _path.replace('{boundaryScfControlId}', encodeURIComponent(String(boundaryScfControlId)));
  return this.client.put(
    _path,
    _bodyParams)
    .then((response) => {
      // BaseApiClient uses validateStatus: () => true, so we must check status manually
      if (response.status >= 400) {
        throw CoreError.deserialize(response.data);
      }
      return ObjectSerializer.deserialize(response.data, 'ExtendedBoundaryScfControl')
    })
    .catch((error) => {
      if (error.data) {
        throw CoreError.deserialize(error.data);
      } else {
        throw error;
      }
    });
  }
  async updateBoundaryTeam(boundaryId: UUID, teamId: UUID, updateBoundaryTeam: UpdateBoundaryTeam): Promise<BoundaryTeam> {
  const _queryParams = {
      
  };
  const _bodyParams = {
      updateBoundaryTeam,
  };
  let _path = '/boundaries/{boundaryId}/teams/{teamId}';
  _path = _path.replace('{boundaryId}', encodeURIComponent(String(boundaryId)));
  _path = _path.replace('{teamId}', encodeURIComponent(String(teamId)));
  return this.client.put(
    _path,
    _bodyParams)
    .then((response) => {
      // BaseApiClient uses validateStatus: () => true, so we must check status manually
      if (response.status >= 400) {
        throw CoreError.deserialize(response.data);
      }
      return ObjectSerializer.deserialize(response.data, 'BoundaryTeam')
    })
    .catch((error) => {
      if (error.data) {
        throw CoreError.deserialize(error.data);
      } else {
        throw error;
      }
    });
  }
  async updateBoundaryTeamScfControl(boundaryId: UUID, teamId: UUID, scfControlId: UUID, updateBoundaryTeamScfControl: UpdateBoundaryTeamScfControl): Promise<BoundaryTeamScfControl> {
  const _queryParams = {
      
  };
  const _bodyParams = {
      updateBoundaryTeamScfControl,
  };
  let _path = '/boundaries/{boundaryId}/teams/{teamId}/scfControlTree/{scfControlId}';
  _path = _path.replace('{boundaryId}', encodeURIComponent(String(boundaryId)));
  _path = _path.replace('{teamId}', encodeURIComponent(String(teamId)));
  _path = _path.replace('{scfControlId}', encodeURIComponent(String(scfControlId)));
  return this.client.put(
    _path,
    _bodyParams)
    .then((response) => {
      // BaseApiClient uses validateStatus: () => true, so we must check status manually
      if (response.status >= 400) {
        throw CoreError.deserialize(response.data);
      }
      return ObjectSerializer.deserialize(response.data, 'BoundaryTeamScfControl')
    })
    .catch((error) => {
      if (error.data) {
        throw CoreError.deserialize(error.data);
      } else {
        throw error;
      }
    });
  }
  async updateBoundaryTeamScfControlEvidenceDefinition(boundaryId: UUID, teamId: UUID, scfControlId: UUID, evidenceDefinitionId: UUID, updateBoundaryTeamScfControlEvidenceDefinition: UpdateBoundaryTeamScfControlEvidenceDefinition): Promise<BoundaryTeamScfControlEvidenceDefinitionImplementation> {
  const _queryParams = {
      
  };
  const _bodyParams = {
      updateBoundaryTeamScfControlEvidenceDefinition,
  };
  let _path = '/boundaries/{boundaryId}/teams/{teamId}/scfControlTree/{scfControlId}/evidenceDefinitions/{evidenceDefinitionId}';
  _path = _path.replace('{boundaryId}', encodeURIComponent(String(boundaryId)));
  _path = _path.replace('{teamId}', encodeURIComponent(String(teamId)));
  _path = _path.replace('{scfControlId}', encodeURIComponent(String(scfControlId)));
  _path = _path.replace('{evidenceDefinitionId}', encodeURIComponent(String(evidenceDefinitionId)));
  return this.client.put(
    _path,
    _bodyParams)
    .then((response) => {
      // BaseApiClient uses validateStatus: () => true, so we must check status manually
      if (response.status >= 400) {
        throw CoreError.deserialize(response.data);
      }
      return ObjectSerializer.deserialize(response.data, 'BoundaryTeamScfControlEvidenceDefinitionImplementation')
    })
    .catch((error) => {
      if (error.data) {
        throw CoreError.deserialize(error.data);
      } else {
        throw error;
      }
    });
  }
  async upsertAlertBot(boundaryId: UUID, newBoundaryAlertBot: NewBoundaryAlertBot, executeAndVerifyQuery?: boolean): Promise<BoundaryAlertBotExtended> {
  const _queryParams = {
      executeAndVerifyQuery,
  };
  const _bodyParams = {
      newBoundaryAlertBot,
  };
  let _path = '/app/boundaries/{boundaryId}/alertBots';
  _path = _path.replace('{boundaryId}', encodeURIComponent(String(boundaryId)));
  return this.client.put(
    _path,
    _bodyParams)
    .then((response) => {
      // BaseApiClient uses validateStatus: () => true, so we must check status manually
      if (response.status >= 400) {
        throw CoreError.deserialize(response.data);
      }
      return ObjectSerializer.deserialize(response.data, 'BoundaryAlertBotExtended')
    })
    .catch((error) => {
      if (error.data) {
        throw CoreError.deserialize(error.data);
      } else {
        throw error;
      }
    });
  }
  async upsertBoundaryProductTargets(boundaryId: UUID, boundaryProductId: UUID, newBoundaryProductTarget: NewBoundaryProductTarget): Promise<Array<BoundaryProductTarget>> {
  const _queryParams = {
      
  };
  const _bodyParams = {
      newBoundaryProductTarget,
  };
  let _path = '/boundaries/{boundaryId}/products/{boundaryProductId}/targets';
  _path = _path.replace('{boundaryId}', encodeURIComponent(String(boundaryId)));
  _path = _path.replace('{boundaryProductId}', encodeURIComponent(String(boundaryProductId)));
  return this.client.put(
    _path,
    _bodyParams)
    .then((response) => {
      // BaseApiClient uses validateStatus: () => true, so we must check status manually
      if (response.status >= 400) {
        throw CoreError.deserialize(response.data);
      }
      return ObjectSerializer.deserialize(response.data, 'Array<BoundaryProductTarget>')
    })
    .catch((error) => {
      if (error.data) {
        throw CoreError.deserialize(error.data);
      } else {
        throw error;
      }
    });
  }
  async upsertBoundaryProducts(boundaryId: UUID, upsertBoundaryProducts: UpsertBoundaryProducts): Promise<Array<BoundaryProduct>> {
  const _queryParams = {
      
  };
  const _bodyParams = {
      upsertBoundaryProducts,
  };
  let _path = '/boundaries/{boundaryId}/products';
  _path = _path.replace('{boundaryId}', encodeURIComponent(String(boundaryId)));
  return this.client.put(
    _path,
    _bodyParams)
    .then((response) => {
      // BaseApiClient uses validateStatus: () => true, so we must check status manually
      if (response.status >= 400) {
        throw CoreError.deserialize(response.data);
      }
      return ObjectSerializer.deserialize(response.data, 'Array<BoundaryProduct>')
    })
    .catch((error) => {
      if (error.data) {
        throw CoreError.deserialize(error.data);
      } else {
        throw error;
      }
    });
  }
}
