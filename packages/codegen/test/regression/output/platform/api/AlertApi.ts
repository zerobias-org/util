/* eslint-disable */
// ===============================================
// This file is autogenerated - Please do not edit
// ===============================================
import { AxiosInstance } from 'axios';
import { AlertLinkExtendedResource, AlertLinkType, AlertTriggerView, AlertView, CreateAlertTrigger, ResourceView, ResultsColumnOptionsWrapper } from '../model/index.js';
import { URL, EnumValue, IllegalArgumentError, PagedResults, Int32, Nmtoken, UUID, CoreError, ParameterRequiredError, UnexpectedError, HttpMethod } from '@zerobias-org/types-core-js';
import { RequestFile, ObjectSerializer } from '../model/index.js';

export namespace AlertApi {
}

/**
 * AlertApi - interface
 * @export
 * @interface AlertApi
 */
export interface AlertApi {
  /**
   * 
   * @summary Create an Alert Trigger
   * @param {CreateAlertTrigger} createAlertTrigger The trigger body
   * @param {*} [options] Override http request option.
   * @throws {@link @zerobias-org/types-core-js#ParameterRequiredError} if any required parameter is not provided
   * @example
   * ```typescript
   * const result = await api.createTrigger(null);
   * ```
   * @openapi operation=createTrigger path=/alertTriggers method=POST
   * @memberof AlertApi
   */
  createTrigger(createAlertTrigger: CreateAlertTrigger): Promise<void>;

  /**
   * 
   * @summary Retrieves a list of alerts
   * @param {UUID} id The ID of the alert to fetch
   * @param {*} [options] Override http request option.
   * @throws {@link @zerobias-org/types-core-js#ParameterRequiredError} if any required parameter is not provided
   * @example
   * ```typescript
   * const result = await api.getAlert('00000000-0000-0000-0000-000000000000');
   * ```
   * @openapi operation=getAlert path=/alerts/{id} method=GET
   * @memberof AlertApi
   */
  getAlert(id: UUID): Promise<AlertView>;

  /**
   * 
   * @summary Retrieves all alert/resource linktypes available in this application
   * @param {*} [options] Override http request option.
   * @throws {@link @zerobias-org/types-core-js#ParameterRequiredError} if any required parameter is not provided
   * @openapi operation=getAlertLinkTypes path=/alertLinkTypes method=GET
   * @memberof AlertApi
   */
  getAlertLinkTypes(): Promise<Array<AlertLinkType>>;

  /**
   * 
   * @summary Retrieves a trigger
   * @param {UUID} id The ID of the trigger to fetch
   * @param {*} [options] Override http request option.
   * @throws {@link @zerobias-org/types-core-js#ParameterRequiredError} if any required parameter is not provided
   * @example
   * ```typescript
   * const result = await api.getTrigger('00000000-0000-0000-0000-000000000000');
   * ```
   * @openapi operation=getTrigger path=/alertTriggers/{id} method=GET
   * @memberof AlertApi
   */
  getTrigger(id: UUID): Promise<AlertTriggerView>;

  /**
   * 
   * @summary Retrieves a list of alerts
   * @param {number} [pageNumber] The requested page. This value is 1-indexed.
   * @param {number} [pageSize] The number of items in each page of data.
   * @param {UUID} [triggerId] a trigger id
   * @param {*} [options] Override http request option.
   * @throws {@link @zerobias-org/types-core-js#ParameterRequiredError} if any required parameter is not provided
   * @example
   * ```typescript
   * const result = await api.listAlerts(1, 1, '00000000-0000-0000-0000-000000000000');
   * ```
   * @openapi operation=listAlerts path=/alerts method=GET
   * @memberof AlertApi
   */
  listAlerts(pageNumber?: number, pageSize?: number, triggerId?: UUID): Promise<PagedResults<AlertView>>;

  /**
   * Returns options/filters for resources impacted by an alert
   * @summary Returns options/filters for resources impacted by an alert
   * @param {UUID} id The ID of the alert
   * @param {*} [options] Override http request option.
   * @throws {@link @zerobias-org/types-core-js#ParameterRequiredError} if any required parameter is not provided
   * @example
   * ```typescript
   * const result = await api.listImpactedResourcesOptions('00000000-0000-0000-0000-000000000000');
   * ```
   * @openapi operation=listImpactedResourcesOptions path=/alerts/{id}/impacts/options method=GET
   * @memberof AlertApi
   */
  listImpactedResourcesOptions(id: UUID): Promise<ResultsColumnOptionsWrapper>;

  /**
   * 
   * @summary Retrieves a list of resources that are linked to the given alert alongside linktype information.  This takes away any link that is an `impactedBy` link. Those should be queried using listResourcesImpactedByAlert
   * @param {UUID} id The ID of the alert
   * @param {number} [pageNumber] The requested page. This value is 1-indexed.
   * @param {number} [pageSize] The number of items in each page of data.
   * @param {Array<Nmtoken>} [resourceTypes] resource types to filter by
   * @param {Array<Nmtoken>} [alertResourceLinkTypes] alert resource link types to filter by
   * @param {string} [name] the name of the resource on the other side of the link
   * @param {string} [description] the name of the resource on the other side of the link
   * @param {object} [sort] Sortable object
   * @param {*} [options] Override http request option.
   * @throws {@link @zerobias-org/types-core-js#ParameterRequiredError} if any required parameter is not provided
   * @example
   * ```typescript
   * const result = await api.listLinkedResources('00000000-0000-0000-0000-000000000000', 1, 1, null, null, 'name', 'description', null);
   * ```
   * @openapi operation=listLinkedResources path=/alerts/{id}/resources method=GET
   * @memberof AlertApi
   */
  listLinkedResources(id: UUID, pageNumber?: number, pageSize?: number, resourceTypes?: Array<Nmtoken>, alertResourceLinkTypes?: Array<Nmtoken>, name?: string, description?: string, sort?: object): Promise<PagedResults<AlertLinkExtendedResource>>;

  /**
   * Returns options/filters for resources associated with an alert
   * @summary Returns options/filters for resources associated with an alert
   * @param {UUID} id The ID of the alert
   * @param {*} [options] Override http request option.
   * @throws {@link @zerobias-org/types-core-js#ParameterRequiredError} if any required parameter is not provided
   * @example
   * ```typescript
   * const result = await api.listLinkedResourcesOptions('00000000-0000-0000-0000-000000000000');
   * ```
   * @openapi operation=listLinkedResourcesOptions path=/alerts/{id}/resources/options method=GET
   * @memberof AlertApi
   */
  listLinkedResourcesOptions(id: UUID): Promise<ResultsColumnOptionsWrapper>;

  /**
   * 
   * @summary Retrieves a list of resources that are impacted by the given alert. This is a recursive search where all children of a resource which may be impacted by this alert will be returned Results are orderd by hierarchy level.
   * @param {UUID} id The ID of the alert to fetch
   * @param {number} [pageNumber] The requested page. This value is 1-indexed.
   * @param {number} [pageSize] The number of items in each page of data.
   * @param {Array<Nmtoken>} [resourceTypes] resource types to filter by
   * @param {string} [name] the name of the resource on the other side of the link
   * @param {string} [description] the name of the resource on the other side of the link
   * @param {object} [sort] Sortable object
   * @param {*} [options] Override http request option.
   * @throws {@link @zerobias-org/types-core-js#ParameterRequiredError} if any required parameter is not provided
   * @example
   * ```typescript
   * const result = await api.listResourcesImpactedByAlert('00000000-0000-0000-0000-000000000000', 1, 1, null, 'name', 'description', null);
   * ```
   * @openapi operation=listResourcesImpactedByAlert path=/alerts/{id}/impacts method=GET
   * @memberof AlertApi
   */
  listResourcesImpactedByAlert(id: UUID, pageNumber?: number, pageSize?: number, resourceTypes?: Array<Nmtoken>, name?: string, description?: string, sort?: object): Promise<PagedResults<ResourceView>>;

  /**
   * 
   * @summary Retrieves a list of triggers
   * @param {number} [pageNumber] The requested page. This value is 1-indexed.
   * @param {number} [pageSize] The number of items in each page of data.
   * @param {*} [options] Override http request option.
   * @throws {@link @zerobias-org/types-core-js#ParameterRequiredError} if any required parameter is not provided
   * @example
   * ```typescript
   * const result = await api.listTriggers(1, 1);
   * ```
   * @openapi operation=listTriggers path=/alertTriggers method=GET
   * @memberof AlertApi
   */
  listTriggers(pageNumber?: number, pageSize?: number): Promise<PagedResults<AlertTriggerView>>;

}

/**
 * AlertProducerApi - interface
 * Producer interface for Alert
 * @export
 * @interface AlertProducerApi
 */
export interface AlertProducerApi {
  /**
  * 
  * @summary Create an Alert Trigger
  * @param {CreateAlertTrigger} createAlertTrigger The trigger body
  * @param {*} [options] Override http request option.
  * @throws {@link @zerobias-org/types-core-js#ParameterRequiredError} if any required parameter is not provided
  * @openapi operation=createTrigger path=/alertTriggers method=POST
  * @memberof Alert
  */
  createTrigger(createAlertTrigger: CreateAlertTrigger): Promise<void>;
  /**
  * 
  * @summary Retrieves a list of alerts
  * @param {UUID} id The ID of the alert to fetch
  * @param {*} [options] Override http request option.
  * @throws {@link @zerobias-org/types-core-js#ParameterRequiredError} if any required parameter is not provided
  * @openapi operation=getAlert path=/alerts/{id} method=GET
  * @memberof Alert
  */
  getAlert(id: UUID): Promise<AlertView>;
  /**
  * 
  * @summary Retrieves all alert/resource linktypes available in this application
  * @param {*} [options] Override http request option.
  * @throws {@link @zerobias-org/types-core-js#ParameterRequiredError} if any required parameter is not provided
  * @openapi operation=getAlertLinkTypes path=/alertLinkTypes method=GET
  * @memberof Alert
  */
  getAlertLinkTypes(): Promise<Array<AlertLinkType>>;
  /**
  * 
  * @summary Retrieves a trigger
  * @param {UUID} id The ID of the trigger to fetch
  * @param {*} [options] Override http request option.
  * @throws {@link @zerobias-org/types-core-js#ParameterRequiredError} if any required parameter is not provided
  * @openapi operation=getTrigger path=/alertTriggers/{id} method=GET
  * @memberof Alert
  */
  getTrigger(id: UUID): Promise<AlertTriggerView>;
  /**
  * 
  * @summary Retrieves a list of alerts
  * @param {UUID} [triggerId] a trigger id
  * @param {*} [options] Override http request option.
  * @throws {@link @zerobias-org/types-core-js#ParameterRequiredError} if any required parameter is not provided
  * @openapi operation=listAlerts path=/alerts method=GET
  * @memberof Alert
  */
  listAlerts(results: PagedResults<AlertView>, triggerId?: UUID): Promise<void>;
  /**
  * Returns options/filters for resources impacted by an alert
  * @summary Returns options/filters for resources impacted by an alert
  * @param {UUID} id The ID of the alert
  * @param {*} [options] Override http request option.
  * @throws {@link @zerobias-org/types-core-js#ParameterRequiredError} if any required parameter is not provided
  * @openapi operation=listImpactedResourcesOptions path=/alerts/{id}/impacts/options method=GET
  * @memberof Alert
  */
  listImpactedResourcesOptions(id: UUID): Promise<ResultsColumnOptionsWrapper>;
  /**
  * 
  * @summary Retrieves a list of resources that are linked to the given alert alongside linktype information.  This takes away any link that is an `impactedBy` link. Those should be queried using listResourcesImpactedByAlert
  * @param {UUID} id The ID of the alert
  * @param {Array<Nmtoken>} [resourceTypes] resource types to filter by
  * @param {Array<Nmtoken>} [alertResourceLinkTypes] alert resource link types to filter by
  * @param {string} [name] the name of the resource on the other side of the link
  * @param {string} [description] the name of the resource on the other side of the link
  * @param {object} [sort] Sortable object
  * @param {*} [options] Override http request option.
  * @throws {@link @zerobias-org/types-core-js#ParameterRequiredError} if any required parameter is not provided
  * @openapi operation=listLinkedResources path=/alerts/{id}/resources method=GET
  * @memberof Alert
  */
  listLinkedResources(results: PagedResults<AlertLinkExtendedResource>, id: UUID, resourceTypes?: Array<Nmtoken>, alertResourceLinkTypes?: Array<Nmtoken>, name?: string, description?: string, sort?: object): Promise<void>;
  /**
  * Returns options/filters for resources associated with an alert
  * @summary Returns options/filters for resources associated with an alert
  * @param {UUID} id The ID of the alert
  * @param {*} [options] Override http request option.
  * @throws {@link @zerobias-org/types-core-js#ParameterRequiredError} if any required parameter is not provided
  * @openapi operation=listLinkedResourcesOptions path=/alerts/{id}/resources/options method=GET
  * @memberof Alert
  */
  listLinkedResourcesOptions(id: UUID): Promise<ResultsColumnOptionsWrapper>;
  /**
  * 
  * @summary Retrieves a list of resources that are impacted by the given alert. This is a recursive search where all children of a resource which may be impacted by this alert will be returned Results are orderd by hierarchy level.
  * @param {UUID} id The ID of the alert to fetch
  * @param {Array<Nmtoken>} [resourceTypes] resource types to filter by
  * @param {string} [name] the name of the resource on the other side of the link
  * @param {string} [description] the name of the resource on the other side of the link
  * @param {object} [sort] Sortable object
  * @param {*} [options] Override http request option.
  * @throws {@link @zerobias-org/types-core-js#ParameterRequiredError} if any required parameter is not provided
  * @openapi operation=listResourcesImpactedByAlert path=/alerts/{id}/impacts method=GET
  * @memberof Alert
  */
  listResourcesImpactedByAlert(results: PagedResults<ResourceView>, id: UUID, resourceTypes?: Array<Nmtoken>, name?: string, description?: string, sort?: object): Promise<void>;
  /**
  * 
  * @summary Retrieves a list of triggers
  * @param {*} [options] Override http request option.
  * @throws {@link @zerobias-org/types-core-js#ParameterRequiredError} if any required parameter is not provided
  * @openapi operation=listTriggers path=/alertTriggers method=GET
  * @memberof Alert
  */
  listTriggers(results: PagedResults<AlertTriggerView>): Promise<void>;
}

export class AlertApiMappingImpl implements AlertApi {
  private producer: AlertProducerApi;
  constructor(producer: AlertProducerApi) {
    this.producer = producer;
  }

  /**
   * 
   * @summary Create an Alert Trigger
   * @param createAlertTrigger The trigger body
   * @openapi operation=createTrigger path=/alertTriggers method=POST
   */
  public async createTrigger(createAlertTrigger: CreateAlertTrigger): Promise<void> {
    // verify required parameter 'createAlertTrigger' is not null or undefined
    if (createAlertTrigger === null || createAlertTrigger === undefined) {
      throw new ParameterRequiredError('createAlertTrigger');
    }
    return this.producer.createTrigger(createAlertTrigger);
  }
  /**
   * 
   * @summary Retrieves a list of alerts
   * @param id The ID of the alert to fetch
   * @openapi operation=getAlert path=/alerts/{id} method=GET
   */
  public async getAlert(id: UUID): Promise<AlertView> {
    // verify required parameter 'id' is not null or undefined
    if (id === null || id === undefined) {
      throw new ParameterRequiredError('id');
    }
    return this.producer.getAlert(id);
  }
  /**
   * 
   * @summary Retrieves all alert/resource linktypes available in this application
   * @openapi operation=getAlertLinkTypes path=/alertLinkTypes method=GET
   */
  public async getAlertLinkTypes(): Promise<Array<AlertLinkType>> {
    return this.producer.getAlertLinkTypes();
  }
  /**
   * 
   * @summary Retrieves a trigger
   * @param id The ID of the trigger to fetch
   * @openapi operation=getTrigger path=/alertTriggers/{id} method=GET
   */
  public async getTrigger(id: UUID): Promise<AlertTriggerView> {
    // verify required parameter 'id' is not null or undefined
    if (id === null || id === undefined) {
      throw new ParameterRequiredError('id');
    }
    return this.producer.getTrigger(id);
  }
  /**
   * 
   * @summary Retrieves a list of alerts
   * @param pageNumber The requested page. This value is 1-indexed.
   * @param pageSize The number of items in each page of data.
   * @param triggerId a trigger id
   * @openapi operation=listAlerts path=/alerts method=GET
   */
  public async listAlerts(pageNumber: number = 1, pageSize: number = 50, triggerId?: UUID): Promise<PagedResults<AlertView>> {
    if (pageNumber) {
      await Int32.parse(pageNumber);
    }
    if (pageSize) {
      await Int32.parse(pageSize);
    }
    const bag = new PagedResults<AlertView>();
    bag.pageNumber = pageNumber;
    bag.pageSize = pageSize;
    await this.producer.listAlerts(bag, triggerId);
    if (bag.items === null || bag.items === undefined) {
      throw new UnexpectedError("Producers must return 'items' for PagedResults queries");
    }
    return bag;
  }
  /**
   * Returns options/filters for resources impacted by an alert
   * @summary Returns options/filters for resources impacted by an alert
   * @param id The ID of the alert
   * @openapi operation=listImpactedResourcesOptions path=/alerts/{id}/impacts/options method=GET
   */
  public async listImpactedResourcesOptions(id: UUID): Promise<ResultsColumnOptionsWrapper> {
    // verify required parameter 'id' is not null or undefined
    if (id === null || id === undefined) {
      throw new ParameterRequiredError('id');
    }
    return this.producer.listImpactedResourcesOptions(id);
  }
  /**
   * 
   * @summary Retrieves a list of resources that are linked to the given alert alongside linktype information.  This takes away any link that is an `impactedBy` link. Those should be queried using listResourcesImpactedByAlert
   * @param id The ID of the alert
   * @param pageNumber The requested page. This value is 1-indexed.
   * @param pageSize The number of items in each page of data.
   * @param resourceTypes resource types to filter by
   * @param alertResourceLinkTypes alert resource link types to filter by
   * @param name the name of the resource on the other side of the link
   * @param description the name of the resource on the other side of the link
   * @param sort Sortable object
   * @openapi operation=listLinkedResources path=/alerts/{id}/resources method=GET
   */
  public async listLinkedResources(id: UUID, pageNumber: number = 1, pageSize: number = 50, resourceTypes?: Array<Nmtoken>, alertResourceLinkTypes?: Array<Nmtoken>, name?: string, description?: string, sort?: object): Promise<PagedResults<AlertLinkExtendedResource>> {
    // verify required parameter 'id' is not null or undefined
    if (id === null || id === undefined) {
      throw new ParameterRequiredError('id');
    }
    if (pageNumber) {
      await Int32.parse(pageNumber);
    }
    if (pageSize) {
      await Int32.parse(pageSize);
    }
    const bag = new PagedResults<AlertLinkExtendedResource>();
    bag.pageNumber = pageNumber;
    bag.pageSize = pageSize;
    await this.producer.listLinkedResources(bag, id, resourceTypes, alertResourceLinkTypes, name, description, sort);
    if (bag.items === null || bag.items === undefined) {
      throw new UnexpectedError("Producers must return 'items' for PagedResults queries");
    }
    return bag;
  }
  /**
   * Returns options/filters for resources associated with an alert
   * @summary Returns options/filters for resources associated with an alert
   * @param id The ID of the alert
   * @openapi operation=listLinkedResourcesOptions path=/alerts/{id}/resources/options method=GET
   */
  public async listLinkedResourcesOptions(id: UUID): Promise<ResultsColumnOptionsWrapper> {
    // verify required parameter 'id' is not null or undefined
    if (id === null || id === undefined) {
      throw new ParameterRequiredError('id');
    }
    return this.producer.listLinkedResourcesOptions(id);
  }
  /**
   * 
   * @summary Retrieves a list of resources that are impacted by the given alert. This is a recursive search where all children of a resource which may be impacted by this alert will be returned Results are orderd by hierarchy level.
   * @param id The ID of the alert to fetch
   * @param pageNumber The requested page. This value is 1-indexed.
   * @param pageSize The number of items in each page of data.
   * @param resourceTypes resource types to filter by
   * @param name the name of the resource on the other side of the link
   * @param description the name of the resource on the other side of the link
   * @param sort Sortable object
   * @openapi operation=listResourcesImpactedByAlert path=/alerts/{id}/impacts method=GET
   */
  public async listResourcesImpactedByAlert(id: UUID, pageNumber: number = 1, pageSize: number = 50, resourceTypes?: Array<Nmtoken>, name?: string, description?: string, sort?: object): Promise<PagedResults<ResourceView>> {
    // verify required parameter 'id' is not null or undefined
    if (id === null || id === undefined) {
      throw new ParameterRequiredError('id');
    }
    if (pageNumber) {
      await Int32.parse(pageNumber);
    }
    if (pageSize) {
      await Int32.parse(pageSize);
    }
    const bag = new PagedResults<ResourceView>();
    bag.pageNumber = pageNumber;
    bag.pageSize = pageSize;
    await this.producer.listResourcesImpactedByAlert(bag, id, resourceTypes, name, description, sort);
    if (bag.items === null || bag.items === undefined) {
      throw new UnexpectedError("Producers must return 'items' for PagedResults queries");
    }
    return bag;
  }
  /**
   * 
   * @summary Retrieves a list of triggers
   * @param pageNumber The requested page. This value is 1-indexed.
   * @param pageSize The number of items in each page of data.
   * @openapi operation=listTriggers path=/alertTriggers method=GET
   */
  public async listTriggers(pageNumber: number = 1, pageSize: number = 50): Promise<PagedResults<AlertTriggerView>> {
    if (pageNumber) {
      await Int32.parse(pageNumber);
    }
    if (pageSize) {
      await Int32.parse(pageSize);
    }
    const bag = new PagedResults<AlertTriggerView>();
    bag.pageNumber = pageNumber;
    bag.pageSize = pageSize;
    await this.producer.listTriggers(bag);
    if (bag.items === null || bag.items === undefined) {
      throw new UnexpectedError("Producers must return 'items' for PagedResults queries");
    }
    return bag;
  }
}

/**
 * Wrap producer with mapping implementation
 */
export function wrapAlertProducer(producer: AlertProducerApi): AlertApi {
  return new AlertApiMappingImpl(producer);
}

/**
 * AlertApiHttpImpl - Direct HTTP implementation
 *
 * Makes direct HTTP calls to the API using Axios.
 * Used by SDK clients for platform service access.
 */
export class AlertApiHttpImpl implements AlertProducerApi {
  private client: AxiosInstance;
  private headers: Record<string, string>;

  constructor(client: AxiosInstance, headers: Record<string, string> = {}) {
    this.client = client;
    this.headers = headers;
  }

  async createTrigger(createAlertTrigger: CreateAlertTrigger): Promise<void> {
  const _queryParams = {
      
  };
  const _bodyParams = {
      ...createAlertTrigger,
  };
  let _path = '/alertTriggers';
  return this.client.post(
    _path,
    _bodyParams)
    .then((response) => {
      // BaseApiClient uses validateStatus: () => true, so we must check status manually
      if (response.status >= 400) {
        throw CoreError.deserialize(response.data);
      }
      return ObjectSerializer.deserialize(response.data, '')
    })
    .catch((error) => {
      if (error.data) {
        throw CoreError.deserialize(error.data);
      } else {
        throw error;
      }
    });
  }
  async getAlert(id: UUID): Promise<AlertView> {
  const _queryParams = {
      
  };
  const _bodyParams = {
      
  };
  let _path = '/alerts/{id}';
  _path = _path.replace('{id}', encodeURIComponent(String(id)));
  return this.client.get(
    _path,
    { params: _queryParams })
    .then((response) => {
      // BaseApiClient uses validateStatus: () => true, so we must check status manually
      if (response.status >= 400) {
        throw CoreError.deserialize(response.data);
      }
      return ObjectSerializer.deserialize(response.data, 'AlertView')
    })
    .catch((error) => {
      if (error.data) {
        throw CoreError.deserialize(error.data);
      } else {
        throw error;
      }
    });
  }
  async getAlertLinkTypes(): Promise<Array<AlertLinkType>> {
  const _queryParams = {
      
  };
  const _bodyParams = {
      
  };
  let _path = '/alertLinkTypes';
  return this.client.get(
    _path,
    { params: _queryParams })
    .then((response) => {
      // BaseApiClient uses validateStatus: () => true, so we must check status manually
      if (response.status >= 400) {
        throw CoreError.deserialize(response.data);
      }
      return ObjectSerializer.deserialize(response.data, 'Array<AlertLinkType>')
    })
    .catch((error) => {
      if (error.data) {
        throw CoreError.deserialize(error.data);
      } else {
        throw error;
      }
    });
  }
  async getTrigger(id: UUID): Promise<AlertTriggerView> {
  const _queryParams = {
      
  };
  const _bodyParams = {
      
  };
  let _path = '/alertTriggers/{id}';
  _path = _path.replace('{id}', encodeURIComponent(String(id)));
  return this.client.get(
    _path,
    { params: _queryParams })
    .then((response) => {
      // BaseApiClient uses validateStatus: () => true, so we must check status manually
      if (response.status >= 400) {
        throw CoreError.deserialize(response.data);
      }
      return ObjectSerializer.deserialize(response.data, 'AlertTriggerView')
    })
    .catch((error) => {
      if (error.data) {
        throw CoreError.deserialize(error.data);
      } else {
        throw error;
      }
    });
  }
  async listAlerts(results: PagedResults<AlertView>, triggerId?: UUID): Promise<void> {
  const _body = {
      triggerId,
  };
  let _path = '/alerts';
  return this.client.get(
    _path,
    {
      params: {
        ..._body,
        pageNumber: results.pageNumber,
        pageSize: results.pageSize,
      }
    })
    .then((response) => {
      // BaseApiClient uses validateStatus: () => true, so we must check status manually
      if (response.status >= 400) {
        throw CoreError.deserialize(response.data);
      }
      results.items = ObjectSerializer.deserialize(response.data, 'Array<AlertView>');
      results.count = response.headers.count ? Number(response.headers.count) : -1;
      results.pageToken = response.headers.pagetoken ?? response.headers.pageToken;
      results.headers = this.headers;
      results.baseUrl = new URL(`${this.client.getUri()}/alerts`);
      results.httpMethod = HttpMethod.Get;
      results.body = _body;
      results.mapper = (obj) => ObjectSerializer.deserialize(obj, 'AlertView');
    })
    .catch((error) => {
      if (error.data) {
        throw CoreError.deserialize(error.data);
      } else {
        throw error;
      }
    });
  }
  async listImpactedResourcesOptions(id: UUID): Promise<ResultsColumnOptionsWrapper> {
  const _queryParams = {
      
  };
  const _bodyParams = {
      
  };
  let _path = '/alerts/{id}/impacts/options';
  _path = _path.replace('{id}', encodeURIComponent(String(id)));
  return this.client.get(
    _path,
    { params: _queryParams })
    .then((response) => {
      // BaseApiClient uses validateStatus: () => true, so we must check status manually
      if (response.status >= 400) {
        throw CoreError.deserialize(response.data);
      }
      return ObjectSerializer.deserialize(response.data, 'ResultsColumnOptionsWrapper')
    })
    .catch((error) => {
      if (error.data) {
        throw CoreError.deserialize(error.data);
      } else {
        throw error;
      }
    });
  }
  async listLinkedResources(results: PagedResults<AlertLinkExtendedResource>, id: UUID, resourceTypes?: Array<Nmtoken>, alertResourceLinkTypes?: Array<Nmtoken>, name?: string, description?: string, sort?: object): Promise<void> {
  const _body = {
      id,resourceTypes,alertResourceLinkTypes,name,description,sort,
  };
  let _path = '/alerts/{id}/resources';
  _path = _path.replace('{id}', encodeURIComponent(String(id)));
  return this.client.get(
    _path,
    {
      params: {
        ..._body,
        pageNumber: results.pageNumber,
        pageSize: results.pageSize,
      }
    })
    .then((response) => {
      // BaseApiClient uses validateStatus: () => true, so we must check status manually
      if (response.status >= 400) {
        throw CoreError.deserialize(response.data);
      }
      results.items = ObjectSerializer.deserialize(response.data, 'Array<AlertLinkExtendedResource>');
      results.count = response.headers.count ? Number(response.headers.count) : -1;
      results.pageToken = response.headers.pagetoken ?? response.headers.pageToken;
      results.headers = this.headers;
      results.baseUrl = new URL(`${this.client.getUri()}/alerts/{id}/resources`);
      results.httpMethod = HttpMethod.Get;
      results.body = _body;
      results.mapper = (obj) => ObjectSerializer.deserialize(obj, 'AlertLinkExtendedResource');
    })
    .catch((error) => {
      if (error.data) {
        throw CoreError.deserialize(error.data);
      } else {
        throw error;
      }
    });
  }
  async listLinkedResourcesOptions(id: UUID): Promise<ResultsColumnOptionsWrapper> {
  const _queryParams = {
      
  };
  const _bodyParams = {
      
  };
  let _path = '/alerts/{id}/resources/options';
  _path = _path.replace('{id}', encodeURIComponent(String(id)));
  return this.client.get(
    _path,
    { params: _queryParams })
    .then((response) => {
      // BaseApiClient uses validateStatus: () => true, so we must check status manually
      if (response.status >= 400) {
        throw CoreError.deserialize(response.data);
      }
      return ObjectSerializer.deserialize(response.data, 'ResultsColumnOptionsWrapper')
    })
    .catch((error) => {
      if (error.data) {
        throw CoreError.deserialize(error.data);
      } else {
        throw error;
      }
    });
  }
  async listResourcesImpactedByAlert(results: PagedResults<ResourceView>, id: UUID, resourceTypes?: Array<Nmtoken>, name?: string, description?: string, sort?: object): Promise<void> {
  const _body = {
      id,resourceTypes,name,description,sort,
  };
  let _path = '/alerts/{id}/impacts';
  _path = _path.replace('{id}', encodeURIComponent(String(id)));
  return this.client.get(
    _path,
    {
      params: {
        ..._body,
        pageNumber: results.pageNumber,
        pageSize: results.pageSize,
      }
    })
    .then((response) => {
      // BaseApiClient uses validateStatus: () => true, so we must check status manually
      if (response.status >= 400) {
        throw CoreError.deserialize(response.data);
      }
      results.items = ObjectSerializer.deserialize(response.data, 'Array<ResourceView>');
      results.count = response.headers.count ? Number(response.headers.count) : -1;
      results.pageToken = response.headers.pagetoken ?? response.headers.pageToken;
      results.headers = this.headers;
      results.baseUrl = new URL(`${this.client.getUri()}/alerts/{id}/impacts`);
      results.httpMethod = HttpMethod.Get;
      results.body = _body;
      results.mapper = (obj) => ObjectSerializer.deserialize(obj, 'ResourceView');
    })
    .catch((error) => {
      if (error.data) {
        throw CoreError.deserialize(error.data);
      } else {
        throw error;
      }
    });
  }
  async listTriggers(results: PagedResults<AlertTriggerView>): Promise<void> {
  const _body = {
      
  };
  let _path = '/alertTriggers';
  return this.client.get(
    _path,
    {
      params: {
        ..._body,
        pageNumber: results.pageNumber,
        pageSize: results.pageSize,
      }
    })
    .then((response) => {
      // BaseApiClient uses validateStatus: () => true, so we must check status manually
      if (response.status >= 400) {
        throw CoreError.deserialize(response.data);
      }
      results.items = ObjectSerializer.deserialize(response.data, 'Array<AlertTriggerView>');
      results.count = response.headers.count ? Number(response.headers.count) : -1;
      results.pageToken = response.headers.pagetoken ?? response.headers.pageToken;
      results.headers = this.headers;
      results.baseUrl = new URL(`${this.client.getUri()}/alertTriggers`);
      results.httpMethod = HttpMethod.Get;
      results.body = _body;
      results.mapper = (obj) => ObjectSerializer.deserialize(obj, 'AlertTriggerView');
    })
    .catch((error) => {
      if (error.data) {
        throw CoreError.deserialize(error.data);
      } else {
        throw error;
      }
    });
  }
}
