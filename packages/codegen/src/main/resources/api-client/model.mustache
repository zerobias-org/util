/* eslint-disable */
// ===============================================
// This file is autogenerated - Please do not edit
// ===============================================
{{#models}}
{{#model}}
{{#tsImports}}
import { {{classname}} } from '{{filename}}';
{{/tsImports}}
import { ObjectSerializer, RequestFile } from './index.js';

{{#description}}
/**
* {{{description}}}
*/
{{/description}}
{{^isEnum}}
{{^oneOf}}
export class {{classname}} {{#parent}}extends {{{parent}}} {{/parent}}{
{{#vars}}
{{#description}}
  /**
  * {{{description}}}
  */
{{/description}}
  '{{name}}'{{^required}}?{{/required}}: {{{datatypeWithEnum}}}{{#isNullable}} | null{{/isNullable}};
{{/vars}}

  {{#discriminator}}
  static readonly discriminator: string | undefined = "{{discriminatorName}}";
  {{/discriminator}}
  {{^discriminator}}
  static readonly discriminator: string | undefined = undefined;
  {{/discriminator}}

  {{^isArrayModel}}
  static attributeTypeMap: ReadonlyArray<{name: string, baseName: string, type: string, format: string}> = [
    {{#vars}}
    {
      "name": "{{name}}",
      "baseName": "{{baseName}}",
      // {{ isEnum }}
      // {{ dataType }}
      // {{ datatypeWithEnum }}
      "type": "{{{dataType}}}",
      "format": "{{dataFormat}}"
    }{{^-last}},
    {{/-last}}
    {{/vars}}
  ];

  static getAttributeTypeMap() {
    {{#parent}}
    return super.getAttributeTypeMap().concat({{classname}}.attributeTypeMap);
    {{/parent}}
    {{^parent}}
    return {{classname}}.attributeTypeMap;
    {{/parent}}
  }
  {{/isArrayModel}}

  static newInstance(obj: any): {{classname}} {
    return ObjectSerializer.deserialize(obj, '{{classname}}');
  }

  constructor({{#parentVars}}{{#required}}{{name}}: {{{datatypeWithEnum}}}, {{/required}}{{/parentVars}}{{#vars}}{{#required}}{{name}}: {{{datatypeWithEnum}}}, {{/required}}{{/vars}}{{#parentVars}}{{^required}}{{name}}?: {{{datatypeWithEnum}}}, {{/required}}{{/parentVars}}{{#vars}}{{^required}}{{name}}?: {{{datatypeWithEnum}}}{{^-last}}, {{/-last}}{{/required}}{{/vars}}) {
  {{#parent}}
    super({{#parentVars}}{{#required}}{{name}}, {{/required}}{{/parentVars}}{{#parentVars}}{{^required}}{{name}}{{^-last}}, {{/-last}}{{/required}}{{/parentVars}});
  {{/parent}}
  {{#vars}}
    this.{{name}} = {{name}};
  {{/vars}}
  }
}
{{/oneOf}}
{{#oneOf}}
{{#-first}}
/**
 * @type {{classname}}{{#description}}
 * {{{description}}}{{/description}}
 * @export
 */
export type {{classname}} = {{#oneOf}}{{{.}}}{{^-last}} | {{/-last}}{{/oneOf}};
{{/-first}}
{{/oneOf}}

{{#hasEnums}}
export namespace {{classname}} {
{{#vars}}
{{#isEnum}}
  export const {{enumName}} = {
    {{#allowableValues}}
    {{#enumVars}}
    /** {{enumDescription}} */
    {{name}}: EnumValue.instance('{{classname}}.{{enumName}}', '{{{name}}}', {{{value}}}{{#escapedEnumDescription}}, '{{{.}}}'{{/escapedEnumDescription}}),
    {{/enumVars}}
    {{/allowableValues}}

    from(val: string | number): EnumValue {
      if ({{enumName}}[val]) {
        return {{enumName}}[val];
      }
      const byValue = {{enumName}}.values.find((v) => v.value === val);
      if (byValue) {
        return byValue;
      }
      throw new IllegalArgumentError(`${val} is not a valid {{enumName}}`);
    },

    get values(): EnumValue[] {
      return Object
        .keys({{enumName}})
        .filter((k) => k !== 'values' && k !== 'from')
        .map((t) => {{enumName}}[t]);
    }
  } as const;

  export type {{enumName}}Def = typeof {{enumName}}[keyof typeof {{enumName}}];
{{/isEnum}}
{{/vars}}
}
{{/hasEnums}}
{{/isEnum}}
{{#isEnum}}
export const {{classname}} = {
  {{#allowableValues}}
  {{#enumVars}}
  /** {{enumDescription}} */
  {{name}}: EnumValue.instance('{{classname}}', '{{{name}}}', {{{value}}}{{#escapedEnumDescription}}, '{{{.}}}'{{/escapedEnumDescription}}),
  {{/enumVars}}
  {{/allowableValues}}

  from(val: string | number): EnumValue {
    if ({{classname}}[val]) {
      return {{classname}}[val];
    }
    const byValue = {{classname}}.values.find((v) => v.value === val);
    if (byValue) {
      return byValue;
    }
    throw new IllegalArgumentError(`${val} is not a valid {{classname}}`);
  },

  get values(): EnumValue[] {
    return Object
      .keys({{classname}})
      .filter((k) => k !== 'values' && k !== 'from')
      .map((t) => {{classname}}[t]);
  }
} as const;

export type {{classname}}Def = typeof {{classname}}[keyof typeof {{classname}}];
{{/isEnum}}
{{/model}}
{{/models}}
