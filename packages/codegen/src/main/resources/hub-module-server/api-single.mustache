/* eslint-disable */
// ===============================================
// This file is autogenerated - Please do not edit
// ===============================================
import * as stream from 'stream';
import { Express, Request, Response, NextFunction } from 'express';
import { {{coreTypes}} } from '@auditmation/types-core-js';
{{#imports}}
import { {{classname}}, {{apiName}} } from '{{modulePackage}}';
{{/imports}}
import { {{classname}}, ObjectSerializer, RequestFile, RequestDetailedFile } from '{{modulePackage}}';
import { {{apiName}}Factory } from './index.js';

{{#operations}}
{{#description}}
/**
 * REST controller for {{classname}}
 *
 * {{&description}}
 */
{{/description}}
export class {{classname}}Controller {

  private factory: {{apiName}}Factory;
  private basePath: string;

  constructor(factory: {{apiName}}Factory, basePath: string) {
    this.factory = factory;
    this.basePath = basePath;
  }

  /**
   * @param {app} the Express app to install this API into
   */
  async install(app: Express): Promise<void> {

  {{#operation}}
    app.{{vendorExtensions.x-lower-http-method}}(`${this.basePath}{{path}}`.replace(/\{/g, ':').replace(/\}/g, ''), (req, res, next) => this.{{nickname}}(req, res, next));
  {{/operation}}

  }

{{#operation}}
  /**
   * {{&notes}}
   {{#summary}}
   * @summary {{&summary}}
   {{/summary}}
   {{#allParams}}
   * @param {{paramName}} {{description}}
   {{/allParams}}
   */
  async {{nickname}}(req: Request, res: Response, next: NextFunction): Promise<void> {

  {{#pathParams}}
    let {{paramName}}: {{{datatypeWithEnum}}} = await ObjectSerializer.deserialize(req.params['{{paramName}}'], "{{{datatypeWithEnum}}}"{{#dataFormat}}, '{{{.}}}'{{/dataFormat}});
  {{/pathParams}}
  {{#queryParams}}
    let {{paramName}}: {{{datatypeWithEnum}}} = await ObjectSerializer.deserialize(req.query['{{paramName}}'], "{{{datatypeWithEnum}}}"{{#dataFormat}}, '{{{.}}}'{{/dataFormat}});
  {{/queryParams}}
  {{#headerParams}}
    let {{baseName}}: {{{dataType}}} = await ObjectSerializer.deserialize(req.headers['{{baseName}}'], "{{{dataType}}}"{{#dataFormat}}, '{{{.}}}'{{/dataFormat}});
  {{/headerParams}}
  {{#formParams}}
    let {{baseName}}: {{{dataType}}} = await ObjectSerializer.deserialize(req.body['{{baseName}}'], "{{{dataType}}}"{{#dataFormat}}, '{{{.}}}'{{/dataFormat}});
  {{/formParams}}
  {{#bodyParam}}
    let {{paramName}}: {{{dataType}}} = await ObjectSerializer.deserialize(req.body, "{{{dataType}}}")
  {{/bodyParam}}
    const api = await this.factory.onRequest(req, res);
    try {
    {{#hasAuthMethods}}
      await api.preAuthorize({{#authMethods}}{{#isOAuth}}[{{#scopes}}'{{scope}}'{{^-last}}, {{/-last}}{{/scopes}}]{{/isOAuth}}{{/authMethods}});
    {{/hasAuthMethods}}
      const impl = api.get{{classname}}();
  {{#vendorExtensions.x-returns-paged-results}}
      const pr = await impl.{{nickname}}({{#allParams}}{{paramName}}{{^-last}}, {{/-last}}{{/allParams}});
      pr.baseUrl = new URL(`${req.protocol}://${req.headers.host}${req.originalUrl}`);
      if (req.query) {
        pr.params = req.query;
      } else if (req.params) {
        pr.params = req.params;
      }

      pr.headers['Authorization'] = req.headers.authorization;
      pr.headers['dana-org-id'] = req.headers['dana-org-id'];
      res.header('link', pr.getLinks().join(','));
      if(pr.count){
        res.header('count', pr.count.toString());
      }
      if (pr.pageToken) {
        res.header('pageToken', pr.pageToken);
      }
      res.send(pr.items);
  {{/vendorExtensions.x-returns-paged-results}}
  {{#vendorExtensions.x-produces-plaintext}}
      res.type('txt');
  {{/vendorExtensions.x-produces-plaintext}}
  // {{ returnType }}
  {{^vendorExtensions.x-returns-paged-results}}
    {{#vendorExtensions.x-returns-any}}
        // attempt to auto-detect PagedResults being returned in case of an 'any' return type
        let results: any = await impl.{{nickname}}({{#allParams}}{{paramName}}{{^-last}}, {{/-last}}{{/allParams}});
        if (results instanceof PagedResults) {
          results.baseUrl = new URL(`${req.protocol}://${req.headers.host}${req.originalUrl}`);
          res.header('link', results.getLinks().join(','));
          if (results.count) {
            res.header('count', results.count.toString());
          }
          if (results.pageToken) {
            res.header('pageToken', results.pageToken);
          }
          results = results.items;
        }
        if (results) {
          res.send(results);
        } else {
          res.status(200).end();
        }
    {{/vendorExtensions.x-returns-any}}
    {{^vendorExtensions.x-returns-any}}
      {{#vendorExtensions.x-returns-file}}
        const rf = await impl.{{nickname}}({{#allParams}}{{paramName}}{{^-last}}, {{/-last}}{{/allParams}});
        let val = rf;
        if ((rf as RequestDetailedFile).value) {
          val = (rf as RequestDetailedFile).value;
        }
        if ((rf as RequestDetailedFile).options?.contentType) {
          res.contentType((rf as RequestDetailedFile).options!.contentType!);
        }
        if ((rf as RequestDetailedFile).options?.attachment) {
          let cd = 'attachment';
          if ((rf as RequestDetailedFile).options?.filename) {
            cd = `${cd}; filename="${(rf as RequestDetailedFile).options?.filename}"`;
          }
          res.setHeader('Content-Disposition', cd);
        }
        if (typeof val === 'string' || val instanceof Buffer) {
          res.send(val);
        } else {
          (val as stream.Readable).pipe(res);
        } 
      {{/vendorExtensions.x-returns-file}}
      {{^vendorExtensions.x-returns-file}}
        res.send(await impl.{{nickname}}({{#allParams}}{{paramName}}{{^-last}}, {{/-last}}{{/allParams}}));
      {{/vendorExtensions.x-returns-file}}
    {{/vendorExtensions.x-returns-any}}
  {{/vendorExtensions.x-returns-paged-results}}
    } finally {
      await this.factory.afterRequest(req, api, res);
    }
    next();
  }
{{/operation}}
}
{{/operations}}

