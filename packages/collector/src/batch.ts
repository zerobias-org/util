/**
 * Batch processing utilities for collector bots
 * Provides helpers for error handling and batch lifecycle management
 */

import { UUID, Tag, UnexpectedError } from '@zerobias-org/types-core-js';
import {
  PlatformApiClient,
  BatchLogLevelEnum,
  BatchImportItem,
  type BatchLogLevelEnumDef,
  type NewBatch,
  type NewBatchLog,
} from '@zerobias-com/platform-sdk';
import type { LoggerEngine } from '@zerobias-org/logger';

/**
 * Batch item with payload and optional raw data
 */
export interface BatchItem<T> {
  payload: T;
  rawData?: Record<string, unknown>;
}

/**
 * Support class for data collectors to handle the creation of new batches of data.
 * Uses an object type "T" for batch items that must be of type `Record<string, unknown>`, or extend that type.
 *
 * @example
 * ```typescript
 * const batch = new Batch<UserRecord>(
 *   'User',
 *   platform,
 *   logger,
 *   jobId,
 *   tags
 * );
 *
 * await batch.add(user);
 * await batch.addItems(users.map(u => ({ payload: u })));
 * await batch.end();
 * ```
 */
export class Batch<T extends object = Record<string, unknown>> {
  private readonly className: string;
  private readonly platform: PlatformApiClient;
  private readonly logger: LoggerEngine;
  private readonly jobId: UUID;
  private readonly tags?: Tag[];
  private readonly groupId?: string;
  private readonly deletesEnabled?: boolean;

  private initialized = false;
  private batchId: UUID | null = null;
  private itemCount = 0;

  /**
   * Registers a new batch for the given class name.
   *
   * @param className - The name of the class for which to create a batch of data
   * @param platform - The platform instance providing batch API access
   * @param logger - Logger instance from @zerobias-org/logger
   * @param jobId - The UUID of the job generated by the cron server
   * @param tags - Optional list of tags to assign to this batch of data
   * @param groupId - Optional Group Id for this Batch
   * @param deletesEnabled - Whether deletes are enabled for this batch
   */
  constructor(
    className: string,
    platform: PlatformApiClient,
    logger: LoggerEngine,
    jobId: UUID,
    tags?: Tag[],
    groupId?: string,
    deletesEnabled?: boolean
  ) {
    this.className = className;
    this.platform = platform;
    this.logger = logger;
    this.jobId = jobId;
    this.tags = tags;
    this.groupId = groupId;
    this.deletesEnabled = deletesEnabled;
  }

  /**
   * Initializes a new batch if not already created.
   */
  private async init(): Promise<UUID | null> {
    if (!this.initialized) {
      if (!this.platform.isConnected()) {
        throw new UnexpectedError('PlatformApiClient was not properly connected, please call connect() with a connection profile.');
      }

      const tagIds = this.tags ? this.tags.map((x) => x.id) : [];
      const newBatch: NewBatch = {
        className: this.className,
        jobId: this.jobId,
        tagIds,
        groupId: this.groupId,
        deletesEnabled: this.deletesEnabled,
      };

      const result = await this.platform.getBatchApi().createBatch(newBatch);
      this.batchId = result.id ?? null;
      this.initialized = true;
    }

    return this.batchId;
  }

  /**
   * Logs a debug message to app logger and platform batch.
   */
  async debug(message: string, data?: object | Error): Promise<void> {
    this.logger.debug(message, data);
    return this.logToPlatform(BatchLogLevelEnum.Debug, message, data);
  }

  /**
   * Logs an info message to app logger and platform batch.
   */
  async info(message: string, data?: object | Error): Promise<void> {
    this.logger.info(message, data);
    return this.logToPlatform(BatchLogLevelEnum.Info, message, data);
  }

  /**
   * Logs a warning message to app logger and platform batch.
   */
  async warn(message: string, data?: object | Error): Promise<void> {
    this.logger.warn(message, data);
    return this.logToPlatform(BatchLogLevelEnum.Warn, message, data);
  }

  /**
   * Logs an error message to app logger and platform batch.
   */
  async error(message: string, data?: object | Error): Promise<void> {
    this.logger.error(message, data);
    return this.logToPlatform(BatchLogLevelEnum.Error, message, data);
  }

  /**
   * Logs a critical message to app logger and platform batch.
   */
  async crit(message: string, data?: object | Error): Promise<void> {
    this.logger.crit(message, data);
    return this.logToPlatform(BatchLogLevelEnum.Crit, message, data);
  }

  /**
   * Logs a message to platform batch only.
   */
  private async logToPlatform(level: BatchLogLevelEnumDef, message: string, data?: object | Error): Promise<void> {
    await this.init();
    if (this.batchId) {
      const batchLog: NewBatchLog = {
        message,
        logLevel: level,
        data: data ?? {},
      };
      await this.platform.getBatchApi().createBatchLog(this.batchId, batchLog);
    }
  }

  /**
   * Returns the UUID of the ID that was assigned to this batch.
   */
  async getId(): Promise<UUID | null> {
    if (!this.initialized) {
      await this.init();
    }
    return this.batchId;
  }

  /**
   * Retrieves the tags assigned with this batch ID.
   */
  getTags(): Tag[] {
    return this.tags ?? [];
  }

  /**
   * Retrieves the name of the class associated with objects in this Batch.
   */
  getClassName(): string {
    return this.className;
  }

  /**
   * Adds a payload to the batch.
   *
   * @param batchItem - The batch object to load
   * @param rawData - Optional raw data for this batch item
   */
  async add(batchItem: T, rawData?: Record<string, object>): Promise<void> {
    if (!this.initialized) {
      await this.init();
    }

    if (this.batchId) {
      const item = new BatchImportItem(batchItem as any, rawData);
      await this.platform.getBatchApi().addBatchItem(this.batchId, item);
      this.itemCount++;
    }
  }

  /**
   * Adds a set of items to the batch.
   *
   * @param items - The batch items with payloads and optional raw data
   */
  async addItems(items: BatchItem<T>[]): Promise<void> {
    if (!this.initialized) {
      await this.init();
    }

    if (this.batchId) {
      const batchItems = items.map((item) => new BatchImportItem(item.payload as any, item.rawData as any));
      await this.platform.getBatchApi().addBatchItems(this.batchId, batchItems);
      this.itemCount += items.length;
    }
  }

  /**
   * Returns the number of items added to this batch.
   */
  getItemCount(): number {
    return this.itemCount;
  }

  /**
   * Marks an item for deletion.
   *
   * @param externalId - The id of the item to be deleted
   */
  async markDeleted(externalId: string): Promise<void> {
    if (!this.initialized) {
      await this.init();
    }

    if (this.batchId) {
      await this.platform.getBatchApi().markDeleted(this.batchId, externalId);
    }
  }

  /**
   * Ends the current batch. Performs no operation if the batch is not initialized.
   */
  async end(): Promise<void> {
    await this.init();

    if (this.batchId) {
      await this.platform.getBatchApi().endBatch(this.batchId);
    }
  }
}

/**
 * Tracked batch entry
 */
export interface BatchEntry {
  className: string;
  uuid: UUID | null;
}

/**
 * Manages batch creation and tracking for collectors.
 *
 * @example
 * ```typescript
 * const batchManager = new BatchManager(platform, logger, jobId, tags);
 *
 * // Create and track batches
 * const userBatch = await batchManager.initBatch('User');
 * await userBatch.add(user);
 * await userBatch.end();
 *
 * const groupBatch = await batchManager.initBatch('Group');
 * await groupBatch.add(group);
 * await groupBatch.end();
 *
 * // Get summary
 * logger.info(batchManager.getSummary());
 * ```
 */
export class BatchManager {
  private readonly platform: PlatformApiClient;
  private readonly logger: LoggerEngine;
  private readonly jobId: UUID;
  private readonly tags: Tag[];
  private readonly batches: Batch<any>[] = [];

  constructor(platform: PlatformApiClient, logger: LoggerEngine, jobId: UUID, tags: Tag[] = []) {
    this.platform = platform;
    this.logger = logger;
    this.jobId = jobId;
    this.tags = tags;
  }

  /**
   * Creates a new batch for the given class, initializes it, and tracks it.
   * @param classType - The class constructor (e.g., ElementType, MitreFolder)
   */
  async initBatch<T extends object>(classType: new (...args: any[]) => T, groupId?: string): Promise<Batch<T>>;
  /**
   * Creates a new batch for the given class name, initializes it, and tracks it.
   * @param className - The class name string
   * @param groupId - Optional group ID for this batch
   */
  async initBatch(className: string, groupId?: string): Promise<Batch<object>>;
  async initBatch<T extends object>(classOrName: (new (...args: any[]) => T) | string, groupId?: string): Promise<Batch<T>> {
    const className = typeof classOrName === 'string' ? classOrName : classOrName.name;
    const batch = new Batch<T>(className, this.platform, this.logger, this.jobId, this.tags, groupId);
    await batch.getId();
    this.batches.push(batch);
    return batch;
  }

  /**
   * Gets all tracked batch entries.
   */
  getBatchIds(): BatchEntry[] {
    return this.batches.map((b) => ({
      className: b.getClassName(),
      uuid: b['batchId'],
    }));
  }

  /**
   * Gets a summary of all processed batches.
   */
  getSummary(): string {
    if (this.batches.length === 0) {
      return 'No batches processed';
    }

    const lines = this.batches.map((b) => `  - ${b.getClassName()}: ${b['batchId'] ?? 'no-id'} (${b.getItemCount()} items)`);
    const totalItems = this.batches.reduce((sum, b) => sum + b.getItemCount(), 0);
    return `${lines.join('\n')}\nTotal: ${this.batches.length} batches, ${totalItems} items`;
  }
}

/**
 * Creates a temporary directory and ensures cleanup
 *
 * @param fn - Function to execute with the temp directory path
 * @returns Result of the function
 *
 * @example
 * ```typescript
 * await withTempDir(async (tempDir) => {
 *   await downloadFile(url, path.join(tempDir, 'data.xlsx'));
 *   // ... process files ...
 * }); // Directory is automatically cleaned up
 * ```
 */
export async function withTempDir<T>(fn: (tempDir: string) => Promise<T>): Promise<T> {
  const { mkdtemp, rm } = await import('node:fs/promises');
  const { tmpdir } = await import('node:os');
  // eslint-disable-next-line unicorn/import-style
  const { join } = await import('node:path');

  const tempDir = await mkdtemp(join(tmpdir(), 'collector-'));

  try {
    return await fn(tempDir);
  } finally {
    await rm(tempDir, { recursive: true, force: true }).catch(() => {
      // Ignore cleanup errors
    });
  }
}

export { UnexpectedError, UUID, Tag } from '@zerobias-org/types-core-js';
export {
  PlatformApiClient, 
  BatchLogLevelEnum, 
  BatchImportItem, 
  type BatchLogLevelEnumDef, 
  type NewBatch, 
  type NewBatchLog
} from '@zerobias-com/platform-sdk';
export { type LoggerEngine } from '@zerobias-org/logger';
